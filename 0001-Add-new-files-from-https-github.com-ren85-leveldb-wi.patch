From 90a4b1d139d062a7ef76cb39eb2ab13e67d4f9ea Mon Sep 17 00:00:00 2001
From: Ray Donnelly <mingw.android@gmail.com>
Date: Thu, 27 Apr 2017 06:16:19 -0500
Subject: [PATCH 1/3] Add new files from
 https://github.com/ren85/leveldb-windows

.. Currently the VS files are set to use the 2008 toolset
---
 LevelDB.sln                                        |   61 +
 LevelDB/LevelDB.rc                                 |  Bin 0 -> 4828 bytes
 LevelDB/LevelDB.vcxproj                            |  307 ++++
 LevelDB/LevelDB.vcxproj.filters                    |  350 +++++
 LevelDB/dllmain.cpp                                |   19 +
 LevelDB/packages.config                            |    5 +
 LevelDB/resource.h                                 |   14 +
 PackageTest/PackageTest.cpp                        |   12 +
 PackageTest/PackageTest.vcxproj                    |  176 +++
 PackageTest/PackageTest.vcxproj.filters            |   45 +
 PackageTest/packages.config                        |    6 +
 PackageTest/stdafx.cpp                             |    8 +
 PackageTest/stdafx.h                               |   15 +
 PackageTest/targetver.h                            |    8 +
 RunTests/RunTests.cpp                              |   12 +
 RunTests/RunTests.vcxproj                          |  193 +++
 RunTests/RunTests.vcxproj.filters                  |  112 ++
 RunTests/packages.config                           |    5 +
 db/leveldb_main.cc                                 |  238 +++
 nuget/LevelDB.nuspec                               |   37 +
 nuget/LevelDB.props                                |   18 +
 packages/Crc32C.1.0.4/Crc32C.1.0.4.nupkg           |  Bin 0 -> 42322 bytes
 packages/Crc32C.1.0.4/Crc32C.1.0.4.nuspec          |   18 +
 packages/Crc32C.1.0.4/build/native/Crc32C.props    |   14 +
 packages/Crc32C.1.0.4/lib/native/include/crc32c.h  |   29 +
 packages/Crc32C.1.0.4/lib/native/src/crc32c.cpp    |  413 ++++++
 .../lib/native/src/generated-constants.cpp         |   39 +
 packages/LevelDB.1.16.0.5/LevelDB.1.16.0.5.nupkg   |  Bin 0 -> 201019 bytes
 packages/LevelDB.1.16.0.5/LevelDB.1.16.0.5.nuspec  |   22 +
 .../LevelDB.1.16.0.5/build/native/LevelDB.props    |   18 +
 .../lib/native/include/leveldb/c.h                 |  302 ++++
 .../lib/native/include/leveldb/cache.h             |   99 ++
 .../lib/native/include/leveldb/comparator.h        |   63 +
 .../lib/native/include/leveldb/db.h                |  166 +++
 .../lib/native/include/leveldb/env.h               |  333 +++++
 .../lib/native/include/leveldb/filter_policy.h     |   70 +
 .../lib/native/include/leveldb/iterator.h          |  100 ++
 .../lib/native/include/leveldb/options.h           |  195 +++
 .../lib/native/include/leveldb/slice.h             |  109 ++
 .../lib/native/include/leveldb/status.h            |  106 ++
 .../lib/native/include/leveldb/table.h             |   85 ++
 .../lib/native/include/leveldb/table_builder.h     |   92 ++
 .../lib/native/include/leveldb/write_batch.h       |   64 +
 .../LevelDB.1.16.0.5/lib/native/src/db/builder.cc  |   88 ++
 .../LevelDB.1.16.0.5/lib/native/src/db/builder.h   |   34 +
 packages/LevelDB.1.16.0.5/lib/native/src/db/c.cc   |  595 ++++++++
 .../LevelDB.1.16.0.5/lib/native/src/db/db_bench.cc |  980 +++++++++++++
 .../LevelDB.1.16.0.5/lib/native/src/db/db_impl.cc  | 1513 ++++++++++++++++++++
 .../LevelDB.1.16.0.5/lib/native/src/db/db_impl.h   |  211 +++
 .../LevelDB.1.16.0.5/lib/native/src/db/db_iter.cc  |  317 ++++
 .../LevelDB.1.16.0.5/lib/native/src/db/db_iter.h   |   28 +
 .../LevelDB.1.16.0.5/lib/native/src/db/dbformat.cc |  140 ++
 .../LevelDB.1.16.0.5/lib/native/src/db/dbformat.h  |  230 +++
 .../LevelDB.1.16.0.5/lib/native/src/db/filename.cc |  144 ++
 .../LevelDB.1.16.0.5/lib/native/src/db/filename.h  |   85 ++
 .../lib/native/src/db/leveldb_main.cc              |  238 +++
 .../lib/native/src/db/log_format.h                 |   35 +
 .../lib/native/src/db/log_reader.cc                |  266 ++++
 .../lib/native/src/db/log_reader.h                 |  108 ++
 .../lib/native/src/db/log_writer.cc                |  103 ++
 .../lib/native/src/db/log_writer.h                 |   48 +
 .../LevelDB.1.16.0.5/lib/native/src/db/memtable.cc |  145 ++
 .../LevelDB.1.16.0.5/lib/native/src/db/memtable.h  |   91 ++
 .../LevelDB.1.16.0.5/lib/native/src/db/repair.cc   |  462 ++++++
 .../LevelDB.1.16.0.5/lib/native/src/db/skiplist.h  |  379 +++++
 .../LevelDB.1.16.0.5/lib/native/src/db/snapshot.h  |   66 +
 .../lib/native/src/db/table_cache.cc               |  127 ++
 .../lib/native/src/db/table_cache.h                |   61 +
 .../lib/native/src/db/version_edit.cc              |  266 ++++
 .../lib/native/src/db/version_edit.h               |  107 ++
 .../lib/native/src/db/version_set.cc               | 1498 +++++++++++++++++++
 .../lib/native/src/db/version_set.h                |  396 +++++
 .../lib/native/src/db/write_batch.cc               |  147 ++
 .../lib/native/src/db/write_batch_internal.h       |   49 +
 .../lib/native/src/helpers/memenv/memenv.cc        |  384 +++++
 .../lib/native/src/helpers/memenv/memenv.h         |   20 +
 .../lib/native/src/leveldb-single-file.cpp         |   52 +
 .../lib/native/src/port/atomic_pointer.h           |  224 +++
 .../LevelDB.1.16.0.5/lib/native/src/port/port.h    |   21 +
 .../lib/native/src/port/port_example.h             |  135 ++
 .../lib/native/src/port/port_posix.cc              |   54 +
 .../lib/native/src/port/port_posix.h               |  157 ++
 .../lib/native/src/port/port_win.cc                |  134 ++
 .../lib/native/src/port/port_win.h                 |  162 +++
 .../lib/native/src/port/thread_annotations.h       |   59 +
 .../lib/native/src/port/win/crc32c_win.cc          |   13 +
 .../lib/native/src/port/win/unistd.h               |    0
 .../LevelDB.1.16.0.5/lib/native/src/table/block.cc |  268 ++++
 .../LevelDB.1.16.0.5/lib/native/src/table/block.h  |   44 +
 .../lib/native/src/table/block_builder.cc          |  109 ++
 .../lib/native/src/table/block_builder.h           |   57 +
 .../lib/native/src/table/filter_block.cc           |  111 ++
 .../lib/native/src/table/filter_block.h            |   68 +
 .../lib/native/src/table/format.cc                 |  145 ++
 .../LevelDB.1.16.0.5/lib/native/src/table/format.h |  108 ++
 .../lib/native/src/table/iterator.cc               |   67 +
 .../lib/native/src/table/iterator_wrapper.h        |   63 +
 .../lib/native/src/table/merger.cc                 |  197 +++
 .../LevelDB.1.16.0.5/lib/native/src/table/merger.h |   26 +
 .../LevelDB.1.16.0.5/lib/native/src/table/table.cc |  275 ++++
 .../lib/native/src/table/table_builder.cc          |  270 ++++
 .../lib/native/src/table/two_level_iterator.cc     |  182 +++
 .../lib/native/src/table/two_level_iterator.h      |   34 +
 .../LevelDB.1.16.0.5/lib/native/src/util/arena.cc  |   68 +
 .../LevelDB.1.16.0.5/lib/native/src/util/arena.h   |   68 +
 .../LevelDB.1.16.0.5/lib/native/src/util/bloom.cc  |   95 ++
 .../LevelDB.1.16.0.5/lib/native/src/util/cache.cc  |  325 +++++
 .../LevelDB.1.16.0.5/lib/native/src/util/coding.cc |  194 +++
 .../LevelDB.1.16.0.5/lib/native/src/util/coding.h  |  104 ++
 .../lib/native/src/util/comparator.cc              |   81 ++
 .../LevelDB.1.16.0.5/lib/native/src/util/crc32c.cc |  332 +++++
 .../LevelDB.1.16.0.5/lib/native/src/util/crc32c.h  |   45 +
 .../LevelDB.1.16.0.5/lib/native/src/util/env.cc    |   96 ++
 .../lib/native/src/util/env_posix.cc               |  607 ++++++++
 .../lib/native/src/util/env_win.cc                 | 1015 +++++++++++++
 .../lib/native/src/util/filter_policy.cc           |   11 +
 .../LevelDB.1.16.0.5/lib/native/src/util/hash.cc   |   52 +
 .../LevelDB.1.16.0.5/lib/native/src/util/hash.h    |   19 +
 .../lib/native/src/util/histogram.cc               |  139 ++
 .../lib/native/src/util/histogram.h                |   42 +
 .../lib/native/src/util/logging.cc                 |   81 ++
 .../LevelDB.1.16.0.5/lib/native/src/util/logging.h |   47 +
 .../lib/native/src/util/mutexlock.h                |   41 +
 .../lib/native/src/util/options.cc                 |   29 +
 .../lib/native/src/util/posix_logger.h             |   98 ++
 .../LevelDB.1.16.0.5/lib/native/src/util/random.h  |   64 +
 .../LevelDB.1.16.0.5/lib/native/src/util/status.cc |   75 +
 .../lib/native/src/util/testharness.cc             |   77 +
 .../lib/native/src/util/testharness.h              |  140 ++
 .../lib/native/src/util/testutil.cc                |   51 +
 .../lib/native/src/util/testutil.h                 |   53 +
 packages/Snappy.1.1.1.7/Snappy.1.1.1.7.nupkg       |  Bin 0 -> 61562 bytes
 packages/Snappy.1.1.1.7/Snappy.1.1.1.7.nuspec      |   18 +
 packages/Snappy.1.1.1.7/build/native/Snappy.props  |   14 +
 .../Snappy.1.1.1.7/lib/native/include/snappy-c.h   |  152 ++
 .../lib/native/include/snappy-internal.h           |  150 ++
 .../lib/native/include/snappy-sinksource.h         |  137 ++
 .../lib/native/include/snappy-stubs-internal.h     |  521 +++++++
 .../lib/native/include/snappy-stubs-public.h       |   38 +
 .../lib/native/include/snappy-test.h               |  598 ++++++++
 .../Snappy.1.1.1.7/lib/native/include/snappy.h     |  184 +++
 packages/Snappy.1.1.1.7/lib/native/src/snappy-c.cc |   90 ++
 .../lib/native/src/snappy-single-file.cpp          |   12 +
 .../lib/native/src/snappy-sinksource.cc            |   71 +
 .../lib/native/src/snappy-stubs-internal.cc        |   42 +
 .../Snappy.1.1.1.7/lib/native/src/snappy-test.cc   |  606 ++++++++
 packages/Snappy.1.1.1.7/lib/native/src/snappy.cc   | 1310 +++++++++++++++++
 .../lib/native/src/snappy_unittest.cc              | 1371 ++++++++++++++++++
 packages/repositories.config                       |    6 +
 port/win/crc32c_win.cc                             |   13 +
 port/win/unistd.h                                  |    0
 151 files changed, 25756 insertions(+)
 create mode 100644 LevelDB.sln
 create mode 100644 LevelDB/LevelDB.rc
 create mode 100644 LevelDB/LevelDB.vcxproj
 create mode 100644 LevelDB/LevelDB.vcxproj.filters
 create mode 100644 LevelDB/dllmain.cpp
 create mode 100644 LevelDB/packages.config
 create mode 100644 LevelDB/resource.h
 create mode 100644 PackageTest/PackageTest.cpp
 create mode 100644 PackageTest/PackageTest.vcxproj
 create mode 100644 PackageTest/PackageTest.vcxproj.filters
 create mode 100644 PackageTest/packages.config
 create mode 100644 PackageTest/stdafx.cpp
 create mode 100644 PackageTest/stdafx.h
 create mode 100644 PackageTest/targetver.h
 create mode 100644 RunTests/RunTests.cpp
 create mode 100644 RunTests/RunTests.vcxproj
 create mode 100644 RunTests/RunTests.vcxproj.filters
 create mode 100644 RunTests/packages.config
 create mode 100644 db/leveldb_main.cc
 create mode 100644 nuget/LevelDB.nuspec
 create mode 100644 nuget/LevelDB.props
 create mode 100644 packages/Crc32C.1.0.4/Crc32C.1.0.4.nupkg
 create mode 100644 packages/Crc32C.1.0.4/Crc32C.1.0.4.nuspec
 create mode 100644 packages/Crc32C.1.0.4/build/native/Crc32C.props
 create mode 100644 packages/Crc32C.1.0.4/lib/native/include/crc32c.h
 create mode 100644 packages/Crc32C.1.0.4/lib/native/src/crc32c.cpp
 create mode 100644 packages/Crc32C.1.0.4/lib/native/src/generated-constants.cpp
 create mode 100644 packages/LevelDB.1.16.0.5/LevelDB.1.16.0.5.nupkg
 create mode 100644 packages/LevelDB.1.16.0.5/LevelDB.1.16.0.5.nuspec
 create mode 100644 packages/LevelDB.1.16.0.5/build/native/LevelDB.props
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/c.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/cache.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/comparator.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/db.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/env.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/filter_policy.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/iterator.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/options.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/slice.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/status.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/table.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/table_builder.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/include/leveldb/write_batch.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/builder.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/builder.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/c.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/db_bench.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/db_impl.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/db_impl.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/db_iter.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/db_iter.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/dbformat.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/dbformat.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/filename.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/filename.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/leveldb_main.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/log_format.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/log_reader.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/log_reader.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/log_writer.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/log_writer.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/memtable.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/memtable.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/repair.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/skiplist.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/snapshot.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/table_cache.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/table_cache.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/version_edit.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/version_edit.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/version_set.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/version_set.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/write_batch.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/db/write_batch_internal.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/helpers/memenv/memenv.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/helpers/memenv/memenv.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/leveldb-single-file.cpp
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/port/atomic_pointer.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/port/port.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/port/port_example.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/port/port_posix.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/port/port_posix.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/port/port_win.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/port/port_win.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/port/thread_annotations.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/port/win/crc32c_win.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/port/win/unistd.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/block.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/block.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/block_builder.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/block_builder.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/filter_block.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/filter_block.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/format.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/format.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/iterator.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/iterator_wrapper.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/merger.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/merger.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/table.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/table_builder.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/two_level_iterator.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/table/two_level_iterator.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/arena.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/arena.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/bloom.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/cache.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/coding.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/coding.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/comparator.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/crc32c.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/crc32c.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/env.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/env_posix.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/env_win.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/filter_policy.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/hash.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/hash.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/histogram.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/histogram.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/logging.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/logging.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/mutexlock.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/options.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/posix_logger.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/random.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/status.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/testharness.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/testharness.h
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/testutil.cc
 create mode 100644 packages/LevelDB.1.16.0.5/lib/native/src/util/testutil.h
 create mode 100644 packages/Snappy.1.1.1.7/Snappy.1.1.1.7.nupkg
 create mode 100644 packages/Snappy.1.1.1.7/Snappy.1.1.1.7.nuspec
 create mode 100644 packages/Snappy.1.1.1.7/build/native/Snappy.props
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/include/snappy-c.h
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/include/snappy-internal.h
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/include/snappy-sinksource.h
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/include/snappy-stubs-internal.h
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/include/snappy-stubs-public.h
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/include/snappy-test.h
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/include/snappy.h
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/src/snappy-c.cc
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/src/snappy-single-file.cpp
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/src/snappy-sinksource.cc
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/src/snappy-stubs-internal.cc
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/src/snappy-test.cc
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/src/snappy.cc
 create mode 100644 packages/Snappy.1.1.1.7/lib/native/src/snappy_unittest.cc
 create mode 100644 packages/repositories.config
 create mode 100644 port/win/crc32c_win.cc
 create mode 100644 port/win/unistd.h

diff --git a/LevelDB.sln b/LevelDB.sln
new file mode 100644
index 0000000..6c7f6b4
--- /dev/null
+++ b/LevelDB.sln
@@ -0,0 +1,61 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 2013
+VisualStudioVersion = 12.0.30110.0
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LevelDB", "LevelDB\LevelDB.vcxproj", "{5B593D71-934A-4D5C-9581-1F89BB839E48}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Benchmark", "Benchmark\Benchmark.vcxproj", "{BD8D65E7-9D22-48BE-A446-B5EF79C27364}"
+	ProjectSection(ProjectDependencies) = postProject
+		{5B593D71-934A-4D5C-9581-1F89BB839E48} = {5B593D71-934A-4D5C-9581-1F89BB839E48}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RunTests", "RunTests\RunTests.vcxproj", "{805EF4EC-9054-42C0-95D5-63DDE5CCA875}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PackageTest", "PackageTest\PackageTest.vcxproj", "{893A8EC0-5BB4-4D90-96C6-2FEB0C0C313D}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{5B593D71-934A-4D5C-9581-1F89BB839E48}.Debug|Win32.ActiveCfg = Debug|Win32
+		{5B593D71-934A-4D5C-9581-1F89BB839E48}.Debug|Win32.Build.0 = Debug|Win32
+		{5B593D71-934A-4D5C-9581-1F89BB839E48}.Debug|x64.ActiveCfg = Debug|x64
+		{5B593D71-934A-4D5C-9581-1F89BB839E48}.Debug|x64.Build.0 = Debug|x64
+		{5B593D71-934A-4D5C-9581-1F89BB839E48}.Release|Win32.ActiveCfg = Release|Win32
+		{5B593D71-934A-4D5C-9581-1F89BB839E48}.Release|Win32.Build.0 = Release|Win32
+		{5B593D71-934A-4D5C-9581-1F89BB839E48}.Release|x64.ActiveCfg = Release|x64
+		{5B593D71-934A-4D5C-9581-1F89BB839E48}.Release|x64.Build.0 = Release|x64
+		{BD8D65E7-9D22-48BE-A446-B5EF79C27364}.Debug|Win32.ActiveCfg = Debug|Win32
+		{BD8D65E7-9D22-48BE-A446-B5EF79C27364}.Debug|Win32.Build.0 = Debug|Win32
+		{BD8D65E7-9D22-48BE-A446-B5EF79C27364}.Debug|x64.ActiveCfg = Debug|x64
+		{BD8D65E7-9D22-48BE-A446-B5EF79C27364}.Debug|x64.Build.0 = Debug|x64
+		{BD8D65E7-9D22-48BE-A446-B5EF79C27364}.Release|Win32.ActiveCfg = Release|Win32
+		{BD8D65E7-9D22-48BE-A446-B5EF79C27364}.Release|Win32.Build.0 = Release|Win32
+		{BD8D65E7-9D22-48BE-A446-B5EF79C27364}.Release|x64.ActiveCfg = Release|x64
+		{BD8D65E7-9D22-48BE-A446-B5EF79C27364}.Release|x64.Build.0 = Release|x64
+		{805EF4EC-9054-42C0-95D5-63DDE5CCA875}.Debug|Win32.ActiveCfg = Debug|Win32
+		{805EF4EC-9054-42C0-95D5-63DDE5CCA875}.Debug|Win32.Build.0 = Debug|Win32
+		{805EF4EC-9054-42C0-95D5-63DDE5CCA875}.Debug|x64.ActiveCfg = Debug|x64
+		{805EF4EC-9054-42C0-95D5-63DDE5CCA875}.Debug|x64.Build.0 = Debug|x64
+		{805EF4EC-9054-42C0-95D5-63DDE5CCA875}.Release|Win32.ActiveCfg = Release|Win32
+		{805EF4EC-9054-42C0-95D5-63DDE5CCA875}.Release|Win32.Build.0 = Release|Win32
+		{805EF4EC-9054-42C0-95D5-63DDE5CCA875}.Release|x64.ActiveCfg = Release|x64
+		{805EF4EC-9054-42C0-95D5-63DDE5CCA875}.Release|x64.Build.0 = Release|x64
+		{893A8EC0-5BB4-4D90-96C6-2FEB0C0C313D}.Debug|Win32.ActiveCfg = Debug|Win32
+		{893A8EC0-5BB4-4D90-96C6-2FEB0C0C313D}.Debug|Win32.Build.0 = Debug|Win32
+		{893A8EC0-5BB4-4D90-96C6-2FEB0C0C313D}.Debug|x64.ActiveCfg = Debug|x64
+		{893A8EC0-5BB4-4D90-96C6-2FEB0C0C313D}.Debug|x64.Build.0 = Debug|x64
+		{893A8EC0-5BB4-4D90-96C6-2FEB0C0C313D}.Release|Win32.ActiveCfg = Release|Win32
+		{893A8EC0-5BB4-4D90-96C6-2FEB0C0C313D}.Release|Win32.Build.0 = Release|Win32
+		{893A8EC0-5BB4-4D90-96C6-2FEB0C0C313D}.Release|x64.ActiveCfg = Release|x64
+		{893A8EC0-5BB4-4D90-96C6-2FEB0C0C313D}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff --git a/LevelDB/LevelDB.rc b/LevelDB/LevelDB.rc
new file mode 100644
index 0000000000000000000000000000000000000000..682ff061fc407399326562fa28233e9d12a05272
GIT binary patch
literal 4828
zcmdUyYfl?T6o${|O8pNbBUP=MfVrqrKVs~pG$tV1aasupnHVUlV<TTm(;uJod1pM{
z9q*cp!v~_(?(EK-IoJ1`Is4`FmTj4{BfGW_Hnx#XxG!zWT$j0t&8%kwz7FhXE@xME
zVMFdQ^Hat?b7MyBoALI6cgL5wUE2*boA$kZhm<WpZZJD!bpUnW(^d-mH|;O0tfU^W
z>mTj``_JL3XSPGKHazD`FG<?$+ljTUWAChPhjwgd*0Kh(b>81v)Ba?p&GX1=%rtqA
z8cXZvcSY^u=<GHASdPjiejV9I?4ROK`Jsc=fABoS>I3YQKN`&Ma4*O3{;1u0|Au|3
z|DT`7qDBE7GkhiNU1Ilo*a&>C;jo&Iyxav(Z}4&bn?qDNRwCjw>fXKsRa&oM`)iLk
zeYyEnp7Ezvoo9Um&jpWZm(W?Rjq^IJl2KM^Dpo{o#ZE#0DVPW~C)0A3M!Rcj^jJ9?
zKCAoWnUESTA-N2-MYPFxx+C_V-x#%vqs|<iEE6mq5sx^pQFoWhe8#gu{cih8{+4f9
z{)#-)?)*xe*G>n;Ar-H&MB^57O%PWr;eJGg_#N&od+`8T$$S{?34A+L;osm}_0~B~
zsTRBI)a3)#QfnTk=|iY9UGJyPYwH&JMxVaIGyCLun-g@O=NtT8wSR3F+%~;!%Ehc!
zo?&AHZ@*(t8l8+&;IO^euk(HaI_{>g=IB-9B{kh~jDCUl9y;pUoA1dm(xDePLBl||
zQ&?}Kd5s9=siNfaYE*;AF;SIgDrhhT<?4g3z~wcTU4YIZx{j7=P&v0)3sSDKq-wu<
zi_Uqb)hydnR*~as9J|C({egT?L2vaDH*|bM`vk&!d|fdA!mqYiJ@<JVy2hUU=PAqO
zmrICVsKY1UJBB(CB{f+Mou6{m;kgM<Y2{e?=(Xtk6Ios9-^_iom+VjnJLAi-rmnRI
zWzVC@`SU>ik;D6%lMU)^g`Uto-TGLm*NxJ|Jx_fBec!LDcaD-HA9c(VI@ERik=DcD
zhgii{RV;P7EngKwcBQ%Z-mm-uRzhCHc%)+*e_>Phj~V65Wdx*g5${d>G2jX|>m18x
zZz?N(eT~drx`d+4v;ssq>6l8DC0E`?Vg3gEC{M4z$8>@B;)=5$$&sIk{0@1y&GmBr
zw#VG6{BZUIt23ksb?T#)SE|J+%GF^8)JvmqK1RRhtLi$DJ)YaATBOLvJk(b{$5Wl2
zCc^8<eyT{HVEG7?&iEId-h*gm`v`hx?|s!)Ww<43kICp%-c#gtiepEuj$LzHDbA!P
zMwcj$7cpPw1WL1~12<L92}n|%%~x;r1L1tqsj=<zBlbN(-%Q)=O*Jasp^ho1SN*xE
rqxp9KxW4WmUjHO_|HDT=KEMBfsF5^W{m(Nb>vTF7|JaLh7pMOLf4y1L

literal 0
HcmV?d00001

diff --git a/LevelDB/LevelDB.vcxproj b/LevelDB/LevelDB.vcxproj
new file mode 100644
index 0000000..6f9aab7
--- /dev/null
+++ b/LevelDB/LevelDB.vcxproj
@@ -0,0 +1,307 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="..\packages\Snappy.1.1.1.7\build\native\Snappy.props" Condition="Exists('..\packages\Snappy.1.1.1.7\build\native\Snappy.props')" />
+  <Import Project="..\packages\Crc32C.1.0.4\build\native\Crc32C.props" Condition="Exists('..\packages\Crc32C.1.0.4\build\native\Crc32C.props')" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{5B593D71-934A-4D5C-9581-1F89BB839E48}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>LevelDB</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140_xp</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140_xp</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140_xp</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v90</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)$(PlatformTarget)\$(Configuration)\</OutDir>
+    <IntDir>$(PlatformTarget)\$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)32</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <TargetName>$(ProjectName)64</TargetName>
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)$(PlatformTarget)\$(Configuration)\</OutDir>
+    <IntDir>$(PlatformTarget)\$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)32</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <TargetName>$(ProjectName)64</TargetName>
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>LEVELDB_PLATFORM_WINDOWS;LEVELDB_WITH_SNAPPY;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_WINDOWS;_USRDLL;LEVELDB_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)include;$(SolutionDir)port\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+    <ResourceCompile>
+      <AdditionalIncludeDirectories>$(SolutionDir)include</AdditionalIncludeDirectories>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>LEVELDB_PLATFORM_WINDOWS;LEVELDB_WITH_SNAPPY;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_WINDOWS;_USRDLL;LEVELDB_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)include;$(SolutionDir)port\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+    <ResourceCompile>
+      <PreprocessorDefinitions>WIN64;_USING_V110_SDK71_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir)include</AdditionalIncludeDirectories>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>LEVELDB_PLATFORM_WINDOWS;LEVELDB_WITH_SNAPPY;_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_WINDOWS;_USRDLL;LEVELDB_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)include;$(SolutionDir)port\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+    <ResourceCompile>
+      <AdditionalIncludeDirectories>$(SolutionDir)include</AdditionalIncludeDirectories>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>LEVELDB_PLATFORM_WINDOWS;LEVELDB_WITH_SNAPPY;_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_WINDOWS;_USRDLL;LEVELDB_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)include;$(SolutionDir)port\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+    <ResourceCompile>
+      <PreprocessorDefinitions>WIN64;_USING_V110_SDK71_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir)include</AdditionalIncludeDirectories>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\db\builder.cc" />
+    <ClCompile Include="..\db\c.cc" />
+    <ClCompile Include="..\db\dbformat.cc" />
+    <ClCompile Include="..\db\db_bench.cc" />
+    <ClCompile Include="..\db\db_impl.cc" />
+    <ClCompile Include="..\db\db_iter.cc" />
+    <ClCompile Include="..\db\filename.cc" />
+    <ClCompile Include="..\db\log_reader.cc" />
+    <ClCompile Include="..\db\log_writer.cc" />
+    <ClCompile Include="..\db\memtable.cc" />
+    <ClCompile Include="..\db\repair.cc" />
+    <ClCompile Include="..\db\table_cache.cc" />
+    <ClCompile Include="..\db\version_edit.cc" />
+    <ClCompile Include="..\db\version_set.cc" />
+    <ClCompile Include="..\db\write_batch.cc" />
+    <ClCompile Include="..\helpers\memenv\memenv.cc" />
+    <ClCompile Include="..\port\port_win.cc" />
+    <ClCompile Include="..\port\win\crc32c_win.cc" />
+    <ClCompile Include="..\table\block.cc" />
+    <ClCompile Include="..\table\block_builder.cc" />
+    <ClCompile Include="..\table\filter_block.cc" />
+    <ClCompile Include="..\table\format.cc" />
+    <ClCompile Include="..\table\iterator.cc" />
+    <ClCompile Include="..\table\merger.cc" />
+    <ClCompile Include="..\table\table.cc" />
+    <ClCompile Include="..\table\table_builder.cc" />
+    <ClCompile Include="..\table\two_level_iterator.cc" />
+    <ClCompile Include="..\util\arena.cc" />
+    <ClCompile Include="..\util\bloom.cc" />
+    <ClCompile Include="..\util\cache.cc" />
+    <ClCompile Include="..\util\coding.cc" />
+    <ClCompile Include="..\util\comparator.cc" />
+    <ClCompile Include="..\util\env.cc" />
+    <ClCompile Include="..\util\env_win.cc" />
+    <ClCompile Include="..\util\filter_policy.cc" />
+    <ClCompile Include="..\util\hash.cc" />
+    <ClCompile Include="..\util\histogram.cc" />
+    <ClCompile Include="..\util\logging.cc" />
+    <ClCompile Include="..\util\options.cc" />
+    <ClCompile Include="..\util\status.cc" />
+    <ClCompile Include="..\util\testharness.cc" />
+    <ClCompile Include="..\util\testutil.cc" />
+    <ClCompile Include="dllmain.cpp">
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+      </PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+      </PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+      </PrecompiledHeader>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="packages.config" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\db\builder.h" />
+    <ClInclude Include="..\db\dbformat.h" />
+    <ClInclude Include="..\db\db_impl.h" />
+    <ClInclude Include="..\db\db_iter.h" />
+    <ClInclude Include="..\db\filename.h" />
+    <ClInclude Include="..\db\log_format.h" />
+    <ClInclude Include="..\db\log_reader.h" />
+    <ClInclude Include="..\db\log_writer.h" />
+    <ClInclude Include="..\db\memtable.h" />
+    <ClInclude Include="..\db\skiplist.h" />
+    <ClInclude Include="..\db\snapshot.h" />
+    <ClInclude Include="..\db\table_cache.h" />
+    <ClInclude Include="..\db\version_edit.h" />
+    <ClInclude Include="..\db\version_set.h" />
+    <ClInclude Include="..\db\write_batch_internal.h" />
+    <ClInclude Include="..\helpers\memenv\memenv.h" />
+    <ClInclude Include="..\include\leveldb\c.h" />
+    <ClInclude Include="..\include\leveldb\cache.h" />
+    <ClInclude Include="..\include\leveldb\comparator.h" />
+    <ClInclude Include="..\include\leveldb\db.h" />
+    <ClInclude Include="..\include\leveldb\env.h" />
+    <ClInclude Include="..\include\leveldb\filter_policy.h" />
+    <ClInclude Include="..\include\leveldb\iterator.h" />
+    <ClInclude Include="..\include\leveldb\options.h" />
+    <ClInclude Include="..\include\leveldb\slice.h" />
+    <ClInclude Include="..\include\leveldb\status.h" />
+    <ClInclude Include="..\include\leveldb\table.h" />
+    <ClInclude Include="..\include\leveldb\table_builder.h" />
+    <ClInclude Include="..\include\leveldb\write_batch.h" />
+    <ClInclude Include="..\port\port.h" />
+    <ClInclude Include="..\port\port_win.h" />
+    <ClInclude Include="..\port\win\unistd.h" />
+    <ClInclude Include="..\table\block.h" />
+    <ClInclude Include="..\table\block_builder.h" />
+    <ClInclude Include="..\table\filter_block.h" />
+    <ClInclude Include="..\table\format.h" />
+    <ClInclude Include="..\table\iterator_wrapper.h" />
+    <ClInclude Include="..\table\merger.h" />
+    <ClInclude Include="..\table\two_level_iterator.h" />
+    <ClInclude Include="..\util\arena.h" />
+    <ClInclude Include="..\util\coding.h" />
+    <ClInclude Include="..\util\crc32c.h" />
+    <ClInclude Include="..\util\hash.h" />
+    <ClInclude Include="..\util\histogram.h" />
+    <ClInclude Include="..\util\logging.h" />
+    <ClInclude Include="..\util\mutexlock.h" />
+    <ClInclude Include="..\util\posix_logger.h" />
+    <ClInclude Include="..\util\random.h" />
+    <ClInclude Include="..\util\testharness.h" />
+    <ClInclude Include="..\util\testutil.h" />
+    <ClInclude Include="resource.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="LevelDB.rc">
+      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)include;$(SolutionDir)port\win</AdditionalIncludeDirectories>
+    </ResourceCompile>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets" />
+  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
+    <PropertyGroup>
+      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
+    </PropertyGroup>
+    <Error Condition="!Exists('..\packages\Crc32C.1.0.4\build\native\Crc32C.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Crc32C.1.0.4\build\native\Crc32C.props'))" />
+    <Error Condition="!Exists('..\packages\Snappy.1.1.1.7\build\native\Snappy.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Snappy.1.1.1.7\build\native\Snappy.props'))" />
+  </Target>
+</Project>
\ No newline at end of file
diff --git a/LevelDB/LevelDB.vcxproj.filters b/LevelDB/LevelDB.vcxproj.filters
new file mode 100644
index 0000000..ecb3712
--- /dev/null
+++ b/LevelDB/LevelDB.vcxproj.filters
@@ -0,0 +1,350 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Source Files\util">
+      <UniqueIdentifier>{889adccd-658d-4b5e-a4a0-5eb69177a710}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\table">
+      <UniqueIdentifier>{8fd751aa-9e25-4e7c-be84-866a0adfceea}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\db">
+      <UniqueIdentifier>{a793ec2f-5901-48cc-833d-4d34bf221920}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\helpers">
+      <UniqueIdentifier>{865a41a9-e0cf-4247-b3aa-7598baee67a5}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\port">
+      <UniqueIdentifier>{4e76ddec-5e87-4137-aae4-f8eab808ff46}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\include">
+      <UniqueIdentifier>{d6c9f360-105f-47e7-8d29-273affb1db82}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\db">
+      <UniqueIdentifier>{1fd59ae8-33f8-4904-9162-8a4403ffa263}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\helpers">
+      <UniqueIdentifier>{b6c214fb-c9fd-4fdc-8ec6-731e89672766}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\port">
+      <UniqueIdentifier>{212f380a-746d-4a0c-9152-f6e84f71f7cb}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\table">
+      <UniqueIdentifier>{a981f194-cfa3-4e74-b130-3e7365173d61}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\util">
+      <UniqueIdentifier>{2041432a-1e4b-4953-94ed-c69878c8fd57}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\util\arena.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\bloom.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\cache.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\coding.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\comparator.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\env.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\env_win.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\filter_policy.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\hash.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\logging.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\options.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\status.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="dllmain.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\table\block.cc">
+      <Filter>Source Files\table</Filter>
+    </ClCompile>
+    <ClCompile Include="..\table\block_builder.cc">
+      <Filter>Source Files\table</Filter>
+    </ClCompile>
+    <ClCompile Include="..\table\filter_block.cc">
+      <Filter>Source Files\table</Filter>
+    </ClCompile>
+    <ClCompile Include="..\table\format.cc">
+      <Filter>Source Files\table</Filter>
+    </ClCompile>
+    <ClCompile Include="..\table\iterator.cc">
+      <Filter>Source Files\table</Filter>
+    </ClCompile>
+    <ClCompile Include="..\table\merger.cc">
+      <Filter>Source Files\table</Filter>
+    </ClCompile>
+    <ClCompile Include="..\table\table.cc">
+      <Filter>Source Files\table</Filter>
+    </ClCompile>
+    <ClCompile Include="..\table\table_builder.cc">
+      <Filter>Source Files\table</Filter>
+    </ClCompile>
+    <ClCompile Include="..\table\two_level_iterator.cc">
+      <Filter>Source Files\table</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\c.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\db_impl.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\db_iter.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\dbformat.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\filename.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\log_reader.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\log_writer.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\memtable.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\repair.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\table_cache.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\version_edit.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\version_set.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\write_batch.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\helpers\memenv\memenv.cc">
+      <Filter>Source Files\helpers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\port\port_win.cc">
+      <Filter>Source Files\port</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\builder.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\port\win\crc32c_win.cc">
+      <Filter>Source Files\port</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\db_bench.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\histogram.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\testutil.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\lib\native\src\crc32c.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\lib\native\src\snappy-single-file.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\testharness.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="packages.config" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\include\leveldb\c.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\leveldb\cache.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\leveldb\comparator.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\leveldb\db.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\leveldb\env.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\leveldb\filter_policy.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\leveldb\iterator.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\leveldb\options.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\leveldb\slice.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\leveldb\status.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\leveldb\table.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\leveldb\table_builder.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\include\leveldb\write_batch.h">
+      <Filter>Header Files\include</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\builder.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\db_impl.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\db_iter.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\dbformat.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\filename.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\log_format.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\log_reader.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\log_writer.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\memtable.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\skiplist.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\snapshot.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\table_cache.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\version_edit.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\version_set.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\db\write_batch_internal.h">
+      <Filter>Header Files\db</Filter>
+    </ClInclude>
+    <ClInclude Include="..\helpers\memenv\memenv.h">
+      <Filter>Header Files\helpers</Filter>
+    </ClInclude>
+    <ClInclude Include="..\util\arena.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\util\coding.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\util\crc32c.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\util\hash.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\util\histogram.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\util\logging.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\util\mutexlock.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\util\posix_logger.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\util\random.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\util\testharness.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\util\testutil.h">
+      <Filter>Header Files\util</Filter>
+    </ClInclude>
+    <ClInclude Include="..\table\block.h">
+      <Filter>Header Files\table</Filter>
+    </ClInclude>
+    <ClInclude Include="..\table\block_builder.h">
+      <Filter>Header Files\table</Filter>
+    </ClInclude>
+    <ClInclude Include="..\table\filter_block.h">
+      <Filter>Header Files\table</Filter>
+    </ClInclude>
+    <ClInclude Include="..\table\format.h">
+      <Filter>Header Files\table</Filter>
+    </ClInclude>
+    <ClInclude Include="..\table\iterator_wrapper.h">
+      <Filter>Header Files\table</Filter>
+    </ClInclude>
+    <ClInclude Include="..\table\merger.h">
+      <Filter>Header Files\table</Filter>
+    </ClInclude>
+    <ClInclude Include="..\table\two_level_iterator.h">
+      <Filter>Header Files\table</Filter>
+    </ClInclude>
+    <ClInclude Include="..\port\port.h">
+      <Filter>Header Files\port</Filter>
+    </ClInclude>
+    <ClInclude Include="..\port\port_win.h">
+      <Filter>Header Files\port</Filter>
+    </ClInclude>
+    <ClInclude Include="..\port\win\unistd.h">
+      <Filter>Header Files\port</Filter>
+    </ClInclude>
+    <ClInclude Include="resource.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="LevelDB.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/LevelDB/dllmain.cpp b/LevelDB/dllmain.cpp
new file mode 100644
index 0000000..5d98ae7
--- /dev/null
+++ b/LevelDB/dllmain.cpp
@@ -0,0 +1,19 @@
+// dllmain.cpp : Defines the entry point for the DLL application.
+#include <Windows.h>
+
+BOOL APIENTRY DllMain( HMODULE hModule,
+                       DWORD  ul_reason_for_call,
+                       LPVOID lpReserved
+					 )
+{
+	switch (ul_reason_for_call)
+	{
+	case DLL_PROCESS_ATTACH:
+	case DLL_THREAD_ATTACH:
+	case DLL_THREAD_DETACH:
+	case DLL_PROCESS_DETACH:
+		break;
+	}
+	return TRUE;
+}
+
diff --git a/LevelDB/packages.config b/LevelDB/packages.config
new file mode 100644
index 0000000..5c738c2
--- /dev/null
+++ b/LevelDB/packages.config
@@ -0,0 +1,5 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<packages>
+  <package id="Crc32C" version="1.0.4" targetFramework="Native" />
+  <package id="Snappy" version="1.1.1.7" targetFramework="Native" />
+</packages>
\ No newline at end of file
diff --git a/LevelDB/resource.h b/LevelDB/resource.h
new file mode 100644
index 0000000..f9d5dfd
--- /dev/null
+++ b/LevelDB/resource.h
@@ -0,0 +1,14 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by LevelDB.rc
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        101
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1001
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
diff --git a/PackageTest/PackageTest.cpp b/PackageTest/PackageTest.cpp
new file mode 100644
index 0000000..4ab67a5
--- /dev/null
+++ b/PackageTest/PackageTest.cpp
@@ -0,0 +1,12 @@
+// PackageTest.cpp : Defines the entry point for the console application.
+//
+
+#include "stdafx.h"
+#include "leveldb/c.h"
+
+int main(int argc, char* argv[])
+{
+    leveldb_benchmark(argc, argv);
+    return 0;
+}
+
diff --git a/PackageTest/PackageTest.vcxproj b/PackageTest/PackageTest.vcxproj
new file mode 100644
index 0000000..7ccdce1
--- /dev/null
+++ b/PackageTest/PackageTest.vcxproj
@@ -0,0 +1,176 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="..\packages\LevelDB.1.16.0.5\build\native\LevelDB.props" Condition="Exists('..\packages\LevelDB.1.16.0.5\build\native\LevelDB.props')" />
+  <Import Project="..\packages\Snappy.1.1.1.7\build\native\Snappy.props" Condition="Exists('..\packages\Snappy.1.1.1.7\build\native\Snappy.props')" />
+  <Import Project="..\packages\Crc32C.1.0.4\build\native\Crc32C.props" Condition="Exists('..\packages\Crc32C.1.0.4\build\native\Crc32C.props')" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{893A8EC0-5BB4-4D90-96C6-2FEB0C0C313D}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>PackageTest</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v90</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)$(PlatformTarget)\$(Configuration)\</OutDir>
+    <IntDir>$(PlatformTarget)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)$(PlatformTarget)\$(Configuration)\</OutDir>
+    <IntDir>$(PlatformTarget)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)port\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="stdafx.h" />
+    <ClInclude Include="targetver.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="PackageTest.cpp" />
+    <ClCompile Include="stdafx.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="packages.config" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets" />
+  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
+    <PropertyGroup>
+      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
+    </PropertyGroup>
+    <Error Condition="!Exists('..\packages\Crc32C.1.0.4\build\native\Crc32C.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Crc32C.1.0.4\build\native\Crc32C.props'))" />
+    <Error Condition="!Exists('..\packages\Snappy.1.1.1.7\build\native\Snappy.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Snappy.1.1.1.7\build\native\Snappy.props'))" />
+    <Error Condition="!Exists('..\packages\LevelDB.1.16.0.5\build\native\LevelDB.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\LevelDB.1.16.0.5\build\native\LevelDB.props'))" />
+  </Target>
+</Project>
\ No newline at end of file
diff --git a/PackageTest/PackageTest.vcxproj.filters b/PackageTest/PackageTest.vcxproj.filters
new file mode 100644
index 0000000..3cce2e1
--- /dev/null
+++ b/PackageTest/PackageTest.vcxproj.filters
@@ -0,0 +1,45 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="stdafx.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="targetver.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="stdafx.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="PackageTest.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\lib\native\src\leveldb-single-file.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\lib\native\src\snappy-single-file.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\lib\native\src\crc32c.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="packages.config" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/PackageTest/packages.config b/PackageTest/packages.config
new file mode 100644
index 0000000..f0fb38d
--- /dev/null
+++ b/PackageTest/packages.config
@@ -0,0 +1,6 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<packages>
+  <package id="Crc32C" version="1.0.4" targetFramework="Native" />
+  <package id="LevelDB" version="1.16.0.5" targetFramework="Native" />
+  <package id="Snappy" version="1.1.1.7" targetFramework="Native" />
+</packages>
\ No newline at end of file
diff --git a/PackageTest/stdafx.cpp b/PackageTest/stdafx.cpp
new file mode 100644
index 0000000..49514aa
--- /dev/null
+++ b/PackageTest/stdafx.cpp
@@ -0,0 +1,8 @@
+// stdafx.cpp : source file that includes just the standard includes
+// PackageTest.pch will be the pre-compiled header
+// stdafx.obj will contain the pre-compiled type information
+
+#include "stdafx.h"
+
+// TODO: reference any additional headers you need in STDAFX.H
+// and not in this file
diff --git a/PackageTest/stdafx.h b/PackageTest/stdafx.h
new file mode 100644
index 0000000..b005a83
--- /dev/null
+++ b/PackageTest/stdafx.h
@@ -0,0 +1,15 @@
+// stdafx.h : include file for standard system include files,
+// or project specific include files that are used frequently, but
+// are changed infrequently
+//
+
+#pragma once
+
+#include "targetver.h"
+
+#include <stdio.h>
+#include <tchar.h>
+
+
+
+// TODO: reference additional headers your program requires here
diff --git a/PackageTest/targetver.h b/PackageTest/targetver.h
new file mode 100644
index 0000000..87c0086
--- /dev/null
+++ b/PackageTest/targetver.h
@@ -0,0 +1,8 @@
+#pragma once
+
+// Including SDKDDKVer.h defines the highest available Windows platform.
+
+// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
+// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.
+
+#include <SDKDDKVer.h>
diff --git a/RunTests/RunTests.cpp b/RunTests/RunTests.cpp
new file mode 100644
index 0000000..3aa995f
--- /dev/null
+++ b/RunTests/RunTests.cpp
@@ -0,0 +1,12 @@
+#include "util/testharness.h"
+
+int main(int argc, char** argv)
+{
+    if (argc > 1)
+    {
+        std::string setting = "LEVELDB_TESTS=";
+        setting += argv[1];
+        putenv(setting.c_str());
+    }
+    return leveldb::test::RunAllTests();
+}
diff --git a/RunTests/RunTests.vcxproj b/RunTests/RunTests.vcxproj
new file mode 100644
index 0000000..fbe56ea
--- /dev/null
+++ b/RunTests/RunTests.vcxproj
@@ -0,0 +1,193 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="..\packages\Snappy.1.1.1.7\build\native\Snappy.props" Condition="Exists('..\packages\Snappy.1.1.1.7\build\native\Snappy.props')" />
+  <Import Project="..\packages\Crc32C.1.0.4\build\native\Crc32C.props" Condition="Exists('..\packages\Crc32C.1.0.4\build\native\Crc32C.props')" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\db\autocompact_test.cc" />
+    <ClCompile Include="..\db\corruption_test.cc" />
+    <ClCompile Include="..\db\dbformat_test.cc" />
+    <ClCompile Include="..\db\db_test.cc" />
+    <ClCompile Include="..\db\filename_test.cc" />
+    <ClCompile Include="..\db\log_test.cc" />
+    <ClCompile Include="..\db\skiplist_test.cc" />
+    <ClCompile Include="..\db\version_edit_test.cc" />
+    <ClCompile Include="..\db\version_set_test.cc" />
+    <ClCompile Include="..\db\write_batch_test.cc" />
+    <ClCompile Include="..\helpers\memenv\memenv_test.cc" />
+    <ClCompile Include="..\issues\issue178_test.cc" />
+    <ClCompile Include="..\issues\issue200_test.cc" />
+    <ClCompile Include="..\leveldb-single-file.cpp" />
+    <ClCompile Include="..\table\filter_block_test.cc" />
+    <ClCompile Include="..\table\table_test.cc" />
+    <ClCompile Include="..\util\arena_test.cc" />
+    <ClCompile Include="..\util\bloom_test.cc" />
+    <ClCompile Include="..\util\cache_test.cc" />
+    <ClCompile Include="..\util\coding_test.cc" />
+    <ClCompile Include="..\util\crc32c_test.cc" />
+    <ClCompile Include="..\util\env_test.cc" />
+    <ClCompile Include="RunTests.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="packages.config" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{805EF4EC-9054-42C0-95D5-63DDE5CCA875}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>SampleTest</RootNamespace>
+    <ProjectName>RunTests</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)$(PlatformTarget)\$(Configuration)\</OutDir>
+    <IntDir>$(PlatformTarget)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)$(PlatformTarget)\$(Configuration)\</OutDir>
+    <IntDir>$(PlatformTarget)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>LEVELDB_STATIC;LEVELDB_PLATFORM_WINDOWS;LEVELDB_WITH_SNAPPY;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)include;$(SolutionDir)port\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>LEVELDB_STATIC;LEVELDB_PLATFORM_WINDOWS;LEVELDB_WITH_SNAPPY;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)include;$(SolutionDir)port\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>LEVELDB_STATIC;LEVELDB_PLATFORM_WINDOWS;LEVELDB_WITH_SNAPPY;_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)include;$(SolutionDir)port\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>LEVELDB_STATIC;LEVELDB_PLATFORM_WINDOWS;LEVELDB_WITH_SNAPPY;_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(SolutionDir)include;$(SolutionDir)port\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets" />
+  <Target Name="EnsureNuGetPackageBuildImports" BeforeTargets="PrepareForBuild">
+    <PropertyGroup>
+      <ErrorText>This project references NuGet package(s) that are missing on this computer. Enable NuGet Package Restore to download them.  For more information, see http://go.microsoft.com/fwlink/?LinkID=322105. The missing file is {0}.</ErrorText>
+    </PropertyGroup>
+    <Error Condition="!Exists('..\packages\Crc32C.1.0.4\build\native\Crc32C.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Crc32C.1.0.4\build\native\Crc32C.props'))" />
+    <Error Condition="!Exists('..\packages\Snappy.1.1.1.7\build\native\Snappy.props')" Text="$([System.String]::Format('$(ErrorText)', '..\packages\Snappy.1.1.1.7\build\native\Snappy.props'))" />
+  </Target>
+</Project>
\ No newline at end of file
diff --git a/RunTests/RunTests.vcxproj.filters b/RunTests/RunTests.vcxproj.filters
new file mode 100644
index 0000000..f140e4d
--- /dev/null
+++ b/RunTests/RunTests.vcxproj.filters
@@ -0,0 +1,112 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Source Files\db">
+      <UniqueIdentifier>{f6239bb9-80fc-40a9-aefb-706aa966e2b9}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\util">
+      <UniqueIdentifier>{928fdc77-dac4-45a9-99a0-4118f2ab15c5}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\helpers">
+      <UniqueIdentifier>{6c23d653-9ec8-4f04-b290-3e8e72384d3f}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\table">
+      <UniqueIdentifier>{aa0a6920-57db-4ee6-beaf-29cbc68c05c4}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\issues">
+      <UniqueIdentifier>{c2d593bd-e344-43b4-81c7-6d526359fdf6}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\leveldb-single-file.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="RunTests.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\db_test.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\autocompact_test.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\corruption_test.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\dbformat_test.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\filename_test.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\log_test.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\skiplist_test.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\version_edit_test.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\version_set_test.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\db\write_batch_test.cc">
+      <Filter>Source Files\db</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\arena_test.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\bloom_test.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\cache_test.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\coding_test.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\crc32c_test.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\util\env_test.cc">
+      <Filter>Source Files\util</Filter>
+    </ClCompile>
+    <ClCompile Include="..\helpers\memenv\memenv_test.cc">
+      <Filter>Source Files\helpers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\table\filter_block_test.cc">
+      <Filter>Source Files\table</Filter>
+    </ClCompile>
+    <ClCompile Include="..\table\table_test.cc">
+      <Filter>Source Files\table</Filter>
+    </ClCompile>
+    <ClCompile Include="..\issues\issue178_test.cc">
+      <Filter>Source Files\issues</Filter>
+    </ClCompile>
+    <ClCompile Include="..\issues\issue200_test.cc">
+      <Filter>Source Files\issues</Filter>
+    </ClCompile>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\lib\native\src\crc32c.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\lib\native\src\snappy-single-file.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="packages.config" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/RunTests/packages.config b/RunTests/packages.config
new file mode 100644
index 0000000..5c738c2
--- /dev/null
+++ b/RunTests/packages.config
@@ -0,0 +1,5 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<packages>
+  <package id="Crc32C" version="1.0.4" targetFramework="Native" />
+  <package id="Snappy" version="1.1.1.7" targetFramework="Native" />
+</packages>
\ No newline at end of file
diff --git a/db/leveldb_main.cc b/db/leveldb_main.cc
new file mode 100644
index 0000000..995d761
--- /dev/null
+++ b/db/leveldb_main.cc
@@ -0,0 +1,238 @@
+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include <stdio.h>
+#include "db/dbformat.h"
+#include "db/filename.h"
+#include "db/log_reader.h"
+#include "db/version_edit.h"
+#include "db/write_batch_internal.h"
+#include "leveldb/env.h"
+#include "leveldb/iterator.h"
+#include "leveldb/options.h"
+#include "leveldb/status.h"
+#include "leveldb/table.h"
+#include "leveldb/write_batch.h"
+#include "util/logging.h"
+
+namespace leveldb {
+
+namespace {
+
+bool GuessType(const std::string& fname, FileType* type) {
+  size_t pos = fname.rfind('/');
+  std::string basename;
+  if (pos == std::string::npos) {
+    basename = fname;
+  } else {
+    basename = std::string(fname.data() + pos + 1, fname.size() - pos - 1);
+  }
+  uint64_t ignored;
+  return ParseFileName(basename, &ignored, type);
+}
+
+// Notified when log reader encounters corruption.
+class CorruptionReporter : public log::Reader::Reporter {
+ public:
+  virtual void Corruption(size_t bytes, const Status& status) {
+    printf("corruption: %d bytes; %s\n",
+            static_cast<int>(bytes),
+            status.ToString().c_str());
+  }
+};
+
+// Print contents of a log file. (*func)() is called on every record.
+bool PrintLogContents(Env* env, const std::string& fname,
+                      void (*func)(Slice)) {
+  SequentialFile* file;
+  Status s = env->NewSequentialFile(fname, &file);
+  if (!s.ok()) {
+    fprintf(stderr, "%s\n", s.ToString().c_str());
+    return false;
+  }
+  CorruptionReporter reporter;
+  log::Reader reader(file, &reporter, true, 0);
+  Slice record;
+  std::string scratch;
+  while (reader.ReadRecord(&record, &scratch)) {
+    printf("--- offset %llu; ",
+           static_cast<unsigned long long>(reader.LastRecordOffset()));
+    (*func)(record);
+  }
+  delete file;
+  return true;
+}
+
+// Called on every item found in a WriteBatch.
+class WriteBatchItemPrinter : public WriteBatch::Handler {
+ public:
+  uint64_t offset_;
+  uint64_t sequence_;
+
+  virtual void Put(const Slice& key, const Slice& value) {
+    printf("  put '%s' '%s'\n",
+           EscapeString(key).c_str(),
+           EscapeString(value).c_str());
+  }
+  virtual void Delete(const Slice& key) {
+    printf("  del '%s'\n",
+           EscapeString(key).c_str());
+  }
+};
+
+
+// Called on every log record (each one of which is a WriteBatch)
+// found in a kLogFile.
+static void WriteBatchPrinter(Slice record) {
+  if (record.size() < 12) {
+    printf("log record length %d is too small\n",
+           static_cast<int>(record.size()));
+    return;
+  }
+  WriteBatch batch;
+  WriteBatchInternal::SetContents(&batch, record);
+  printf("sequence %llu\n",
+         static_cast<unsigned long long>(WriteBatchInternal::Sequence(&batch)));
+  WriteBatchItemPrinter batch_item_printer;
+  Status s = batch.Iterate(&batch_item_printer);
+  if (!s.ok()) {
+    printf("  error: %s\n", s.ToString().c_str());
+  }
+}
+
+bool DumpLog(Env* env, const std::string& fname) {
+  return PrintLogContents(env, fname, WriteBatchPrinter);
+}
+
+// Called on every log record (each one of which is a WriteBatch)
+// found in a kDescriptorFile.
+static void VersionEditPrinter(Slice record) {
+  VersionEdit edit;
+  Status s = edit.DecodeFrom(record);
+  if (!s.ok()) {
+    printf("%s\n", s.ToString().c_str());
+    return;
+  }
+  printf("%s", edit.DebugString().c_str());
+}
+
+bool DumpDescriptor(Env* env, const std::string& fname) {
+  return PrintLogContents(env, fname, VersionEditPrinter);
+}
+
+bool DumpTable(Env* env, const std::string& fname) {
+  uint64_t file_size;
+  RandomAccessFile* file = NULL;
+  Table* table = NULL;
+  Status s = env->GetFileSize(fname, &file_size);
+  if (s.ok()) {
+    s = env->NewRandomAccessFile(fname, &file);
+  }
+  if (s.ok()) {
+    // We use the default comparator, which may or may not match the
+    // comparator used in this database. However this should not cause
+    // problems since we only use Table operations that do not require
+    // any comparisons.  In particular, we do not call Seek or Prev.
+    s = Table::Open(Options(), file, file_size, &table);
+  }
+  if (!s.ok()) {
+    fprintf(stderr, "%s\n", s.ToString().c_str());
+    delete table;
+    delete file;
+    return false;
+  }
+
+  ReadOptions ro;
+  ro.fill_cache = false;
+  Iterator* iter = table->NewIterator(ro);
+  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
+    ParsedInternalKey key;
+    if (!ParseInternalKey(iter->key(), &key)) {
+      printf("badkey '%s' => '%s'\n",
+             EscapeString(iter->key()).c_str(),
+             EscapeString(iter->value()).c_str());
+    } else {
+      char kbuf[20];
+      const char* type;
+      if (key.type == kTypeDeletion) {
+        type = "del";
+      } else if (key.type == kTypeValue) {
+        type = "val";
+      } else {
+        snprintf(kbuf, sizeof(kbuf), "%d", static_cast<int>(key.type));
+        type = kbuf;
+      }
+      printf("'%s' @ %8llu : %s => '%s'\n",
+             EscapeString(key.user_key).c_str(),
+             static_cast<unsigned long long>(key.sequence),
+             type,
+             EscapeString(iter->value()).c_str());
+    }
+  }
+  s = iter->status();
+  if (!s.ok()) {
+    printf("iterator error: %s\n", s.ToString().c_str());
+  }
+
+  delete iter;
+  delete table;
+  delete file;
+  return true;
+}
+
+bool DumpFile(Env* env, const std::string& fname) {
+  FileType ftype;
+  if (!GuessType(fname, &ftype)) {
+    fprintf(stderr, "%s: unknown file type\n", fname.c_str());
+    return false;
+  }
+  switch (ftype) {
+    case kLogFile:         return DumpLog(env, fname);
+    case kDescriptorFile:  return DumpDescriptor(env, fname);
+    case kTableFile:       return DumpTable(env, fname);
+
+    default: {
+      fprintf(stderr, "%s: not a dump-able file type\n", fname.c_str());
+      break;
+    }
+  }
+  return false;
+}
+
+bool HandleDumpCommand(Env* env, char** files, int num) {
+  bool ok = true;
+  for (int i = 0; i < num; i++) {
+    ok &= DumpFile(env, files[i]);
+  }
+  return ok;
+}
+
+}
+}  // namespace leveldb
+
+static void Usage() {
+  fprintf(
+      stderr,
+      "Usage: leveldbutil command...\n"
+      "   dump files...         -- dump contents of specified files\n"
+      );
+}
+
+int main(int argc, char** argv) {
+  leveldb::Env* env = leveldb::Env::Default();
+  bool ok = true;
+  if (argc < 2) {
+    Usage();
+    ok = false;
+  } else {
+    std::string command = argv[1];
+    if (command == "dump") {
+      ok = leveldb::HandleDumpCommand(env, argv+2, argc-2);
+    } else {
+      Usage();
+      ok = false;
+    }
+  }
+  return (ok ? 0 : 1);
+}
diff --git a/nuget/LevelDB.nuspec b/nuget/LevelDB.nuspec
new file mode 100644
index 0000000..7eafb81
--- /dev/null
+++ b/nuget/LevelDB.nuspec
@@ -0,0 +1,37 @@
+<?xml version="1.0"?>
+<package >
+  <metadata>
+    <id>LevelDB</id>
+    <title>LevelDB for C++</title>
+    <version>1.16.0.5</version>
+    <authors>Robert Važan</authors>
+    <owners>Robert Važan</owners>
+    <licenseUrl>http://leveldb.angeloflogic.com/license/</licenseUrl>
+    <projectUrl>http://leveldb.angeloflogic.com/</projectUrl>
+    <iconUrl>http://leveldb.angeloflogic.com/images/nuget-icon.png</iconUrl>
+    <requireLicenseAcceptance>false</requireLicenseAcceptance>
+    <description>LevelDB is an embedded key-value database with fast random writes and fast reads of key ranges. This is a source code package that embeds LevelDB into your project.</description>
+    <releaseNotes>Initial release.</releaseNotes>
+    <copyright>Copyright (C) 2011-2014 Robert Vazan &amp; upstream LevelDB developers</copyright>
+    <tags>leveldb, nosql, database, data, fast, native</tags>
+    <dependencies>
+      <dependency id="Crc32C" version="1.0.4" />
+      <dependency id="Snappy" version="1.1.1.7" />
+    </dependencies>
+  </metadata>
+  <files>
+    <file src="..\include\**\*.h" target="\lib\native\include\" />
+    <file src="..\db\**\*.h" target="\lib\native\src\db\" />
+    <file src="..\db\**\*.cc" target="\lib\native\src\db\" exclude="**\*_test.cc" />
+    <file src="..\helpers\**\*.h" target="\lib\native\src\helpers\" />
+    <file src="..\helpers\**\*.cc" target="\lib\native\src\helpers\" exclude="**\*_test.cc" />
+    <file src="..\port\**\*.h" target="\lib\native\src\port\" />
+    <file src="..\port\**\*.cc" target="\lib\native\src\port\" exclude="**\*_test.cc" />
+    <file src="..\table\**\*.h" target="\lib\native\src\table\" />
+    <file src="..\table\**\*.cc" target="\lib\native\src\table\" exclude="**\*_test.cc" />
+    <file src="..\util\**\*.h" target="\lib\native\src\util\" />
+    <file src="..\util\**\*.cc" target="\lib\native\src\util\" exclude="**\*_test.cc" />
+    <file src="..\leveldb-single-file.cpp" target="\lib\native\src\leveldb-single-file.cpp" />
+    <file src="LevelDB.props" target="\build\native\LevelDB.props" />
+  </files>
+</package>
\ No newline at end of file
diff --git a/nuget/LevelDB.props b/nuget/LevelDB.props
new file mode 100644
index 0000000..11f8a7b
--- /dev/null
+++ b/nuget/LevelDB.props
@@ -0,0 +1,18 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <PreprocessorDefinitions>LEVELDB_STATIC;LEVELDB_PLATFORM_WINDOWS;LEVELDB_WITH_SNAPPY;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(MSBuildThisFileDirectory)..\..\lib\native\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\lib\native\src\leveldb-single-file.cpp">
+      <AdditionalIncludeDirectories>$(MSBuildThisFileDirectory)..\..\lib\native\src\port\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/packages/Crc32C.1.0.4/Crc32C.1.0.4.nupkg b/packages/Crc32C.1.0.4/Crc32C.1.0.4.nupkg
new file mode 100644
index 0000000000000000000000000000000000000000..d464909d9d80d0d9b2f5a3368be0793b88f80449
GIT binary patch
literal 42322
zcmb5V1#BF_)9AV0H8V4;nVBJGcFfGo%*>9N*^ZeR6US_?nPO(fm^p@+a``^Jr@Q|>
z-MhPyy49oUs;=t!wOU<MqoM$UMg;uV72mEYDFxSWaSjCl{8vE&5Ce?eEFIigS^ldA
zm*4~Fim?B?>;JvF?&=c~@o{tjds(`<+d4aaqF`rXqX1hvnLAt9I$3|B@bs`^=A#f1
z7E-fxF!lJ?!`;T##U1=l#L4{=g^h=YivTODySa^}qp3TKvx}wEzb97CZjPoN|8Cu^
zSzS!c?M<yMSvlC)cv$~g^MC4~_)nc+4PO__|3#ytt+|`CyR(%Ci@CGo|4{bNu7B#-
z*;v_lSshKCY^^NaJt)8$rf$}j9-k;!CEUz8IV4z|Jl$O^%_+cg7N028c+B|B*v+`v
zI83dqxXie?D8Q`$Uq=7`<qxZ)rH847sfQ`6xwD%kvy0n5X*UmBOZWeaZU1vN+%4U_
zY|Sm*{~u*oEi5gp_&9mF%&pisxGYWi`8iDa`AoU3*w`((cr49KSzO#5EzDj1hkuq9
z=Kp+Sw=&~m=iuToxBPGaSpVad39J0$1seba!2dTdmf8ushyPfa0|5Xi|9JV2S^M7+
zlc28XyvT;$LwQRk?O&|Pd+W3T5^tzwfOiF;W=sU0ea2KDMQvNy`rvnZW2Moptb0!O
zi}`f$WHfR=a_6_B?^A}J;H_Qj*r97!yV7_V@&cs~6!yHeTPo-3#-cb&^ozH2_PCkj
ztzPWKgR66`=i71kVRo<8&W>6(8Ca*y1Pk_;*D)X9-(Ov<L44WoP7V9PpHr)1An8j#
zjQMN9B9&TmOABUUw`?H0$#Xkb-6kO9?Ba7Qhz85$b3U5t){8$PLht?z*-4qsJi(E7
z;s@-J!-!7lxKt;S){*o{wU1$m{rJns%koJF4gq}`-@Zi#`LlD`0+L1<-vA5A!gf!H
zou3zT3lwv?*?xMseaCoC{xC3*OtDBgiqQF61$ps88R55-vgd2xUn|(2Y!bN_f1-=G
zO^bj8R`ez%gr7xp&c><p*mjAYD_sTC1fmZ_p$L@*xzy5dWtO+^b(ojMon)Ezdc2)6
zZvu1K=fxmV>wL({e`w3GM`46_)-a`C_OYZMAQv4I+e2gKf-$a&iA$BWWDpL`*FE~|
zHia5JFP9SK(9!pj-5KhDksAOnw{b8^aQwXU9mm+J^zcW$DUYjBY<Ekgf{<f@{&(2X
z`~VAktH-yBp}Er3KNzVmF#m~4W(<xz<R2<&|4<?Nhl+!(8LQL3b?jxyYU^a~;AvsW
zYW`nq&YZ>Oe+!P<mi-1BdNA5yFyDF<b+MxK9mfeiwsTW|QTb03e~#FI*rbWn6eXwD
zz98CB!!*bAv*G2_AhIV{r4db=qIO2D$&xn#()`H`Vp1t8uUyZ*j_tZQ;Q;LSyMxDH
zPVRrv1|Kd7CtAcE&Ex#kbmNrk(S$NSf5X@T6#YW$*R(K#>MgVISK81Z4~RENIq-d_
zkHTxcg+IjZwZ$@@I#CE6EK^BYn)X#tpXEM_%Fg8vNJ?$>ihnc|qJ!!fBe$iw4nal-
zNvY&h)VARs!+j7nunVaTy%li8grN?S#*c~qjwI6*?a=Mgd=XP=9rlS(j)y>WUA;CF
zsUEc_Q^nwV^v=}2*QfLI!;^>@^`Gi84GFN*e?2Wy=h-9XdCmNGay6Wb{Sf5xwvJI!
zC>*MVYG$V&DsauhuaebaJA3j+>}=$RYJ;*%PC#6THcnF(2Ax}vBUS)NvE_5U)GCcR
z+mM);KY{d4INE#|0YAanaNL0PFhd$bqYz*PQfbJ%6J#&CmX9{%$=M|J@<rTy?y|kW
z=>76ZpA62~FO0!GZuo8I9Ci7Z@6QjBv1#=Op&_c_$&XtLzoo|WruIIl|D=L!0)DF%
z831_U1po;ClL~h?^Z!YNxr@vHj)_Ymd-ny|J3-C2s5J+uHgh6<uNEd>4Y9;88e&DV
zk6w*#5NZWVdr`FODY`^&#;1)&f9a$YrcuNQ{VOL!4Tl+zr{7)rmwT?qAD_e%_y44}
z=CI05+G5$W5vP#$CX5q(4W^jc47p?RB~zx)I=p_o_VV~kx}X2&GdhO9o2k3}?tR{9
z)>Ju*uSFawR#K-0q>PL<b#*RvwwAwAJUJT+cN!#ZNCj-)OgwB+9&?o}$(~gploLe;
zQUuChK-0N!ln+&gDgdpNLGnU6;<*hZ>zoY9$v<;U=Hh*XP;sm%=wd!S+qkT)<n@&b
zS%^3BiMLsg0bH2P%Lrt!MaaDnxJBFxZhV<+@DQ5E5HRtQJonkkHch=mFZgATS24%p
zSc+^WLd(GI8aw=+Imvm7SO~Fcvf~Hou#+qp<G(3AsY;5_jfkOdfoOm&sL0YP;UzQV
zR}&CAX8dRgj;>rbJOW`xl@NNC`l5)G>eCp9(p@0c5j2m)_cb*~W*??%Gf^zKYB!uz
zb7e@KjVxot>It0FzHEB_>U1TY5%gmI7aQ$WnHqX%S94m3XE{?#G#1;f1_qGY4e?BJ
zFeG<Yi4L){j~aP#MFziCxu94NN^%Ino35jbxSrvg1Ne#fFgA=D0g?ta1?z-0x}wGY
zJA841L41~8YIwySid{O81SA>`*(>guTKs8?Zw$on$Vrzt$~qCDukC;X^oiEr<2$~5
zx~ItUvvB+U;o$bNe{%f9N<-^R+b857>=tl$hYc{v3XN)jD@vIZQdHolrPfFFmd;#w
z`myLHzjt`~^&pLRCWssG1ex3PA%FQWjp+}<j${HlQGQpiLpp8ofgv0iPZ-23BAF8X
zGLMFH^6u}(UrAR9YD=Yp+E=DY^{9wBR_(1cMf|YlDk1(<T)9iGC$*C^^Mfl-^x73W
zB?U&K-(3_A%j5~Oq&cH89Jf=l5a7h8+%E$2nm?c<TAK5F<LUZ6REwHnUjLMo63(It
z&iR#om2_>}$`K`d-~g!#MD_7rR9)B_*JGxi0<APAqj*g@>ko9^*ti5%6)g<>7?j{}
z0Chl?(n5nESz71D?N8`G1P-@0R{q*ljvAcvDp?LtmVwS!s)|NQ+#+>bkHh3`G^nDv
z^k$bF_t(T`zlyg%E=-~Ry`ZPL-a}1cDnl1Yj-}Hc6|IN{gDh_MHa3?u0T+W<`Q;qq
zZRiLkaG&LOfh5?;Vgw$r$W=nIOaQ7>H;1VW3=NPR=rcAdc0x8%ex8OLdRQbF4erUc
zndRgR#Bha$T*{4VYEJT1c2RPiUPq!)Hk87T8X}I!vm~UpL1J&`FThQN3Q0%k`JGY1
z6aZ^kS3UzqBMUQ3nJ@rGIeHFB+(~>5fSYcaUP-4q4v)LfeC$Lm2^E2&A@vTOPVJma
zYuk(MF*+Ng{z1>_;RE3NejLOH&evjbk-6>Eo>@o3J6_ks5wzs}n>=t)aluIA47)`y
z8r4N)G73}2y$uj#Fp*h?)u|03LF4I1MOjsBLHSk#@UUL_Of-Sj2EiZEvnw%b*0Ub?
z8^2OEPLovGMx*EU)aRD0ntsLiD%w}H{)IQq*n9N*_=!IuyxxVy=v7X>_#TPpY0a;A
zXAys~$mhJ@8Q0G@LXr$k%p?hxL7#0S1yMM*T{eY|P-K3L`AVGQ$~p6OODz+jI;A`Y
zbxW=Ln^pAqq0>=J;1bnFhuP^!bF4~xQh}T_WI1-FGyba~@3ss3ohrPZm1b~j-7b~Y
zIIBfEO^58gquI$Z+B4&~ow?y<y4j~MKg|L+jiOBJC3Fi(BNgWdi+uf_Z*kX(;koVK
z>Lc|qY|kk_*Y>K~=q9MuA#|sVi;aZ*YGG-wd)aN7+MWM`*B5l~X`}UzkWNkHvG;_z
z*gn5-^k8e98A6msh{2hU4)(4Gc@okdr?L{DMpJiQ+%Qi+xvaB%yUfN<O-nHXl8gVM
z5=OX9ENN+CFM*#?EMo;Gs1b-A<WIa$+$MXFUQU_IK4WQV_|(&^{TuJ070HLQYsizC
zB4C5D9`y4k$w5(EaMW4j_sS!<J&Ky+QgwN+QHzN(JI@$GruT{nodxU6Q_ZhRMMB5l
zvUpZIA7HmAdKO>d{-~567V>wd*?p3bYDnd8VQ@)CMr>K~@#;*UeJ_O;;*7Ib_&Q}C
z0K41Kyo8*sk{9`e9@W1fbGROm!>K8GVa?S`H%*01EAN_iD5tOy1Vkft6Is|G_d6)s
zT5@%Q{r%`w9$5{~I?%P;&8-(ELnH=?Y?d+V`{c{dAL#kEple<BeUbWitU%17-#+%I
z<?@qMzJ8eBZ$9^8NKFo-G7~Vv8s|L)1z4O@WH;Dw4d)CJ<bt$|KR|?D?j?OH<Ptu4
zXQ}FfZdr%?)>rXoF_*WNkNK;cw>f2~RPYuAb->EkN9qggk>9>~Qvv8C)WZ;AM3K>`
zwsNf5212F{swV1$ymHc_(r!ELMP1^~1dLOBie)|DDyx8U>e?3Q^@xmb=5%8O=uQR!
zJYy?@^H=TV;q`;nZZ`0Y)jc)%&1a+85=)ie6n}868Wr<9D78|_Z9!>mK`qy#HchNI
zlB)5tc1$Bz@jR(MWT2vC=q^@+6RofwaNf=$pNHm{7*0@ab-7WbbobrdL-U8Loc^xM
zrZjv|%dHl_^w8wm_9gAZNS~k9{&-dp&jf_6{-L_tJ>>eP8xbQ)tpJZ`3XS*CsXk5?
z9VD@dAGIa7i~sv$gK|{k=L%B(SEY`)Rg9piBSV-O$C&!K0zX#v0c)Jymq=X7M22Ql
z4<xyWdex$@1UO{n&+@O$YU%03dN2yCmn=nTW9dD1UtqU}vpT$%NG8-n8y7V;17%#b
zFNgjrv$D4kwkH($a!p6){)&vZneTRFEk;{SMrVZMx}Y8je!w*Tp7l&-OVyjv)L}?@
z+u^!Umhzn1|ED(PIg&7j)%~(YP=lr@b`W$o=vX0;y1_&@B2eqQKSR)4wpppJK+J-W
zgYu(Dj9o^5&BFZ?+;_?~4-LMAgOGOYR~%w2TuRZ3hE?BNU*WF>pYwbNHgOxg#@Vpw
zh=7bH=fHq6ZmQSUp#ku-lJ!Ie*8A{KFZ9pawd>IF5DrqCDB#cfQfA_?#JbY)R`1br
z+uboY8o$mz{3|WlGI}&fBR{J@AN@JhP*of+_fQ*;BlW^j{VQag<nL%yAn5Pv$K(5P
zuPoBzqwMAFCEb-#zpyeY!>Tl{V!XleI~q1uJnH1&%TQ(_>F5vscA~{aGt})fAGxxZ
zU9X0k&x$!=>zX~}w@MejtC5vETz?1fo4iGZROz^bVF9omLgwUpkJMk3rz=bOAV0M#
z1j^`u-Df)K^Tfs@^QZ;2K1^O28$R(!d9o7L$|&-)PVRwnZQ?BMNap+r7YxS9dx&jM
z8J#Qdk*U=SO)O>O8oI~wHE~m$Yu=nMD7WCOj6Gzw->THtXWx5~^_0IU#7H@&Yat$K
zL|49uu)R<5)y`LF)MxZ?r1|hjhU-?`J7nt0*(I@I;V_YH+r)l$cFL<Vj)|421gR&H
zST=ox2x(Q8$-1Nd?pa<2-KINuB1B4E1%vy<F3@l4*>}Bb$dJDr9==E<bq9Rtym10+
zU^7M$E8nyV84=Y$N!@FbHL12=JPL(TbQd`;mbuM}4CUIh*xfZrzVQ#oQp=B16cq^3
zQzQ2*Q`4k(E*itA#|a4X*>q2Q*T%^i&ew)9GxGg;5mK4oid2UaOA%mn9hvj1h-sJm
zd^YpO<5RhtSaJ5TcQ}kMc+s7|cbto79P~u*>mtQs`Xo=^oxGKtbn3ZVqJN|A>gP9X
zVZX}K_4@EKQLb22i~DH4+d5zMeWK*0;eMz*3*TmQi}Mixr$MMB`WWN8p%0U6XZQhI
z%Y0H>m!IF30$4J%$uDUt*0+c|mR=iARmz`3Zo*k8*G{{I8;FOx%0&=n1fR||c{sIS
zd_l;uf_x<>suEuqPd9bh*`_KJw)>fJ!6e6Mo51OFI#&u6tVhZHCN|HA${u6oDMjK~
zgePOHeU{HKY5g+YY3jLIyI@D4{EnC3`i;4Z<m}kAM~_RC9`BEMTgl%wdDc@2jV$NO
z<9F@tpN9$Y#g$%{V$_!S)&x&|arg1VDAu?Zt>y}AYv{wfO$rR7ne?7<Elnj=PW7^v
zemV9-_3-PGLqug=y0Oge<~<fP@?W0XbPw!v-$bUct>hbo=Fm5cu{mDjP=I}U>5=G`
z{tdBZG4?}#3!0YUAO<Mo9kuQkm|SXx5*anL{AO!zt38z`4vq>5T8`y6>>14jXjrWe
zl>a;hX^4rYz()Z9b>vV0n*a3_WNqnW>1OI-X~As%FLLH#>hv!v_WyDu@-Q4nWM0$C
z!&?-==JRZNwc1^T9ilyxl(hJ9BbuiZ2L9-3_LAJ@z3s*9)_lqn$`RDYYF-!FIR3a5
znRX8T8`bxIyt5hn!$l$Q`}@me;VJ9KBU<p2_TR^(;CJ5OKgxaFJA;KE`(%G#(Ei>i
zzkE%eZ0vh`nGF6A4*GlWa@qIsOx8Dg<J|Z6@iqHz(8q9A@H<|>u5s{doN@4<!hZ$j
z?<?6``oiB2;^5xmDO|&EB4kNKE<e@_1E;P=zFy4KKF-zlJsxK_K8>@!y3-97`sKd+
zR&vV=EPQN^Ty@kx{aLqKb?=$U@)fta4eWhd9*w`gx2<fy3VPynwz0kR7BS!3;O%}L
zZ|`Uy=pwtm)BWCkUWo24e`NUgCDr=!`h}$vOFejH$Fuz6tSe~j;7Vub!MuaF{js4>
zO_{RI`(0S?(z|;m%PZ6PAh373WBTXyef_nbR#4&0hI5o);8TFT?enI8CXT%0>6Ws9
z?M}}2J2bDi;A^)(QdfJ=Qy1LM#HZpu|2XRvk`ezA!kX*JKI<9VhvotQk$vsc=5A}{
z?*$n5U2xqohHtL{PFKG!c8(XOywmT6Mf^XL7e4)Ixt81Rc|HAcjI-HQ*rt{E(fbM+
zo<V-vN=ke*4F0mboPGVm7m4fdw}OVj>Rsmju5Z8d{Ly8-sjz)uxRZrFGJgF+`-Rji
zXr+)6_4@oZz>c8Bc<1=uqxbnySj3Nj_S@5+&M5ox?pIrH#jMG$!rqte^1fI4<IddI
zuEN9f-}={dek)1a`3emVy`{thLQ&TZ83!B5$YneRSq{5V*G0&`g#s_r6S!q$bvYux
z>PWTl`X%LXv~8fYsyuGSI>L?LjI;ZXKYF=BPc-$F!ziyUW2niP4Is#S=ZToB$f#8j
z(7rV6Om^EUz!f{3%kq-vxvInI3wx8E{VMR@8?8F%(LOGJRT(3yI;h<<7V;!h(+S8#
z;dgqX*l4+D$>D(>flig#plCi4j5YVK^gg~4PPwj%G>SdwBBEx^q5{z`Yf%$@*YGF1
zUTf9=p~f@)I~h2x(}+M;e6i>7t1Nyi)5#&dr%7*Gfg@l#v_!3q7kRk^Sw?88J>8Mc
zd{RyT(|J>~^FSIoMnKJFPPJOFwY{mtgDs;V&!crjn9|ebkhn;D@d&}uVE&dA)*`o4
z<g6-AAc)XtqWnr`)26V698PW4LjTcKW!+n3k0+YQaq`%1yS2U7y7oFB*MRQl<F@Bh
zDO1&B*RjEJ2zsA&b;JJob-sAdxzT&ic|7a!Mj<lad%u5X%Dn4+;D?7#V)pj&`_Nwd
zZ{a=`WOc&pAPT3>WidhDbzAzr*R}Khh+}UN0n7=^^h%?@4M_*_j``m2zgUM(yU&k_
z_l`EZK0+|~e)gQt9Cj8y8H!|J3N*Z2)oY5(2NjA8qGkVM4hgSW-KWr-^VwkVRcPus
z!rku)i-+ZExr;2@MaVSZsTDUbEN)RZcF*5?4F+$r$S`(^8UNhdd3#3VE-e%Y2Xg<t
zZP@6JEV3i$cp6VU@4s>*5cK-n0{o41n&tYwNrfc#Nf>Q(?)B>W9%FjE@Ix4FVHK=<
z9rVU>`}lGNXC>S@xBb4Ep?`k4l|=e(DAM7_LVW0-iJypcYZ&~T{x#|Pg_}3~`+LLA
z8ASEk`@O*GjKBN*pbrul<sH~PgcIpsXbckH*?N7u`XP?6bL>it^!GzJ*qO!s)my}A
zu!Q9A)o5W09`?(p1Gf;`C;@TzN$&`>ggS4yIAs2yYn!j?(*fQ}s0Z&_p|G&y(x~>n
z6CsV&6{2hX66JnW=A1^NL=&W&U4rS&$kq!ymT2e)*-qW9dXyk7)wWxc9`(q}o<Cx1
z%am#|Zw}P5-bHL%>N1)3O?-<ag=&pb0@0kkx}7mUqScG1C#rh<!^yuI3JAv~NpvPD
zG$@fMQzmg$y}o<kB|5;T`#P*;3R($&BX?xYqjQWKioG5?CaBoX51H%Y)ix*y@Fs`+
zF&Y=uC5@F_8{_+?KoEj~Z?DRO=yW15zUojcJx*%m@1D+{oqa`N>6}M+t4BWwFr}4i
zbGGYMi#$dR;YoMw;5du!Kk?559Q7=w9PFRQbz->|Z<K|@hzpf}^);l!@oY;xr15Nh
z)HTmYoaq4&RlhckCbvBK7LgU{oe6hiqbECz$x}<N;o2;EeIxgw-AEpG{`-3TR|Mk*
zmU~y%mlL66W)QBos??Ko%(nDd5o$ztTZx=0aO<KJ6<2=cluM9lJ~j<}CfY$0I!eq}
znSHt`nCN~db+I}Fk1d2h34{L}fpTK$75d2sF8Vky3f(lL;g}qbk1mhdSkm4JK@y?@
zH--R%xewGI07b+^l<q6AIwAAYulk0R%<{!I-D;#L5vQ`jq7k=~cQnB?n4N})+|&uR
z62J8PVBLK1&qQFvvPJhAB%kW60;6P4&W$w!Hk68iz5*()0y_u_+z7x>%|IlNEAsf0
zQJ*JRaK2S?^MuN6%63nvLddR4GE4leLmVvn4ThTn7%_HU4}A~VbMplninl{BR36k>
z!>55r4mQbJ@Hq8h6CnHx8j@&&>yA@r<@#vCbXQs13Vo9%C^tmxAMc`po~e|bg<&5`
zXz)gB>KBcIt}-z~Ax;4MKKl#dyaE1%6e50h;@go3gUtiV$eJL>ZRSzBhS)(M>M4zl
zwS0sl-0s5AmtB_NY>6-VY*KFNP3ry{gu$CM&$nP5hOP&Bwq-YxD;h$IXD=Q0UVD+7
zOR0gc>M=R7Ig?N|@HrftCSGx+4pDzXiQ$0x>VoN)ZYC!Jp3qv=JcQCAQRL=645ETe
z!k)Chf)IXfj5FhfZTFh8DHpX~J@TAj{{m2i{U}Rp47+wd6TWhw#$>4)lcxfggHY<k
z%t%f7A&Wbo1l6F{(N!ug8j!c*-OztN;BX}P!W|5MEfeDzpQOU$Tw2>br3cZR`m6BJ
z@S%u(oboSYV_6>fMeCNufA^Z8dKNKVlo&*%XoY;1oe&_sr5ghnI%Et{b?m)8P*EcA
zs-BL?f7$5EnkM=1rA=*zs#iLnC+Fz{xWl&{N0dLN^P;t7+?P3Nk+lJ+WbMLFi=0NF
zvHoo>wu2YR0lswo)a0H7nYB)-VH`IjHaC-c-*JJFehRQPV1fv&2%QvB?k4~2-`*nb
zIq+#*-+^yZ1RJ$bx9X3}Fj*++<2mZrX)OXpJuGUG{x0^PCwSfj-UKa4i%_%kI#oEE
zzE&nusrbnb`LmRMLKj&N&GgQch({khstQMyCN;>p#-6$oIJ*EEdsA=_p?;I04S`zy
zMDH(Z5F|NaLFBmCF1s3<;*1^>Im*FzUw{E@1zM5@ff(crWzF|jt0~c;vYpOQT^Kjv
zJSSGRixjTcLf=e_s>3m6E0OBNO<C)n1qWg6&IB#1S3sX735cG>Ptto3>I(`u5O8tr
zO6v$Gg%ddfyg+Cb4m(&Jbzn!S8GAISZdYYQ)uExmIW_Nrf>ziw>=T2Ww9ZWAnUVXH
zp;a1BtmoBN+5G(3sRcR(P+6nEgpP47graxH?gwB^g@$!g_B>rPd}~`h(p$FwKHae@
z7O8-P3~_tDjAe*8w7gPu1r`ze2KC{aY(5Y!)>dWZ4B7%sN|Yr_pz3SCfr>Yb5w`DP
zS8cnh8FG67x{Fy7{QNQ&JAx>y4{|eNJVQJO`{%VF-~(Hgn@fl<!&t{=&ycvNQn7|v
znJ=MJ_$oqMA7MfT@}MrMSv^b>%&0`y-X_d;sdAFJ42;e$$NTyaX0c*Bwiz;-vny{i
zoKq1t%u9dZu@0gUPScSja#|?;3q>2$if*#ui#&YWABVG#svdMoh(2f=Q&22nfNn^m
za?jD&tX^=i7jeD;Ny|Ov=dRj%&5#35HyQEC-PTq<13RqfGobc&fHziEdN$R75a2?3
zLb|>feeijfM0T;l0kDK;M%rF?s*SnE-$R|^issxDo$rMYSRK+}LnCdF8L9`2V}x^y
zq7mb;Ujm!Pl_11`BnhSzMvXFb^K^I)|L9M<(YyvcM<`W{hGsZu5_Z{n0@<c2(T@8a
zIBXF*&Ackh)D*;8KZj&*X55|4XenRlvD6{wgUCKGaDXK&_EqR`m@}%11lq{OedU<`
zF{=U`)4}tpSXfXF2zM6#sdYy7jT~PO?85;6yMIS~R23^EEziWE2u^hLx@$v__>X_T
z-a+U>2^1Pmzd6Ic^`;qC|EQ+{(KSR_1hwKz6dGE_D7f7Xx2*W?D!?T&KnFd7ge9Zr
z;BuPT8ZHYt?(-ljU+NGS+-Lo-9-^pDGjV~HUVCb(B`pg!P-04#ldqDIIQ`D%=@L=W
zOP|Z*U|3mZ$Gq`7^TwAUE<nj=Lo93(tpaJ94rC$GQon(Se=)HF%ON=$BUgbx9B1ut
zyLVO*1RtzjKV=<eLVB`P)x*^R?-~O5a3&g1D*~PI$`O+uIRiOoz-wb5L&!tnp5qNo
z3XuOXR3fVw)MqP|QqI-iie1fj^Q)TCzeSJ1;^}Gx)<Y>Y!Z0UMRb9xhUP*QHViF-9
zKU^FDGe6elDdqw%jvDerz%|gMOER5ejl=*y{KTaKMaRZKWT^^fSdZ*ji-RSACWSUt
z_YLh7YT8#X`DIe*U6NXXpdu@?c8pxqrcCfNHLE%vmPHR&*B2UFDJ{h%dPc}7g-mv^
zM4}M)K*uPD1T929T(^6e1m_5FXOjS??RTY;VuesbeX&jNr#*-1t7La52ds7P!0Zz=
z1zdZZ9vq+odqQA8VHB~<{v;r91x9&sVi*kT_$P7E{K&#Vs2T{N);J`)sy|Tk=ymZ^
zI>Zy0iv_ew={nOqkBj!OGnViv5IjuG!J++8ktFG_P)<R5KI_F6^Ym5%eqCcBhRe^|
zx!(oD2Qd&saI-@*Ul`5YOb9qjT|_a0w51(FL`9(pbi)cqPB~(~tOO-m4+&f79FAQe
z6X%Ss{7IAsshIwv$byxnlEH!;9*LTY6gdJj!Hl)&A<O{7Xf_bW2I~!~fEFNvQ3cOM
zBUvhJ3RJR^8;0ORAFevIdpr`z7Ml%@Nx)zOL@s5uNbx(mu&2BL?I)1q$jA@N<1dlF
zYXOH{M5j2RZh)dFIsHXG)~@uhad(%3n7@^HiLfI@%|ga}1T4FY5sjy;qr@w=@$=}L
zuY3_OGq2gmr`kQ^*o^sy=BBSadM|$?YA9?Ocy3Q$e0H?5WVNie<jYVZ(0`^+(Tz)H
z%s%);Hvwj&1DhV8zp=svfhh=J<KHOoZGMD(#bRP^hfmf?A$0ko2J(bsE9QeO5~$Ls
zq2k_1xDrB;4ab20lEVSc{E{V|57X@Sg<w^c;`a@u0fZ3=*{yqON{xoubM#_c5$mcj
zrT;C}FkVmj%^HbH?U&%LAY~?4*Ax~wfK*9D9GbAxgqRo-9QJKlwB#FZof<hlqsve-
zGc2!J96Ca8Y0Cf$6>AU^9VVxW&-aF*;;BhKN)AEW;_H)~nDGA1H>s^27!`s&11xOu
z6rCF#XW{tHS<^=ZCZcHPZK?iOadf$Kt*@hom@L`SvwXBgFz}lQsjN+=7gR9>tWMF3
zWf{A+0%GRg7$G^jlkjp=`NCEG(94vwtB?gED5EVC$}EEZz|!)aix~iB@n~&bb5c?E
zl*J$77GMEJWS4TvNqG1f6}NRAiuOSCl_SzexCOcXs+<@=hT*0`B6?_70xlM6KcJ5&
zwB{=<Y=|+CMgtb{=AAF~T<_W-L#!zu<)iNyhWpD})evd_9AKR4<3l`8&IlYi8gTP^
z1+^|q<-O~Jha4Lkht!AzZvd5Nh)CtpG)5|!5#b#^#tKVjpzxh6^*aa%SNj=ROG2N*
zo*j4*WAbQb6dMZc&-8;sSiAxYC-irLj6n~v@vj`jtyTU*T6ry<=pjVeP*HN{Jr<U5
zxEjhiB+*OqQ%%I}=XLQo21+#rVlnHYL}obrdbnBCunmr%l`*q!p7`vnD&+G3D9GC^
zh5FRD#3Z6ZSp9_okdtf}C6`(MS~JsKOUBmgt4Mtd+^%W18H*9Sa9fFQIm1fyP}_GT
zzHk}>>&h_z0Ok!h6e+RH@ETo>ZK$RI-<wK^NW2<4n4gq`SSC{W85{jruDq9;`i21*
zbK3m{X-DD#@G9?u)P~ZfaI;f%60#Q`J17U7RRM(EFR25jVffX#c0Ec1JdD_3(2fVL
zaq*bbZyNYrkrG&Iqcn2$DFju#%f&!CALzThgdifhCRa!#5Diz7Z4mBujfAOhhC#*^
zVsj=~dkB2SooTAfl@xgVmJ1t(s~yG|4t7~d4$X)65bHZGHf3doLAvQZx0p@*iTA0f
zj(ml+3uE1I;urRDY{?MqAvv2v2+V5KF8cIPY95#Hjiej_oJzjG#yWI&A@qg5=MfV|
zW_<W01CnhKVpa%0Y16=GOz#o}C8~1B{azJ3W=Plog^gUtP(eDg9aM=JOdp@hsx)D+
zj&dU%oCb#R43IoIyBuDVc`tew*+uM`F$_zkPX9E1f<DB+h>D^kzpPsYdesxNfnUCt
zix5|?=Z``$ivkXMvbWE62_}+tUgXeE2nwJMi)s^Vfo3+>G~_Q<^57OMx=2P>cQoR-
zl1-+7#$j+rj&1a=MgE4oyF{i8b#_EbR3i<6GVYB01XF)|fdpVvETGu&jb(FnUH8b^
zXYHX%=ydf+GmP8qC$u)MQ%{`jk&yP-Fk@O+-x^g%dH5&IR6ckHgV*#@D4-nlQgR#@
z9!V%%`^^{FCV|-)1rr1xRWq9YDkOk8rUP1^%Qt<CLs3;Z(gdQtL|NJMo1!L<I*?F5
zOnD7Cbv`WaBC1n%;&@G_C>+iuv_7)x+%OcSl$qx`WgC?@Dc3jc3<TXo6={4HX4J4%
zQal?tF}x`PVssK2yO8I^5OU<wETFi_ZpfosE~9?OY8M=S`96UL6dqTjoLZBTA_Iui
zWT~s4*}z$2h)5U=1>I{64Y=J7Tr2q{gH=3<{vx_>@)-*{6)Kh;5T{{;1Dg#RZ^3cw
zSNXSrYkvwqWbDLErQ}CZ(c8retF>@VWT-@T%!96KXV?A|`VM#{4VNTR8W+q6f+&qH
z6X5H@T<|f3xM-g;n7S29iHfglS{K8Gp_`!Jps@nFF=d5C%&FN!Lw3qBAj&yg=O$~$
zT5}}mSgAC9%skR+2F@UP6BWydj7;-nhRa`XRD94>Kh=+LSJIm?rlJJvGE;=BLM-Xi
z+<rmo*>C1U$P8(Vd8Ctgi>5fT_h?RFT%mX<PXYZ1Z1l)}8h|9pWZxv}@3KND3*{wK
zb)zK4uy!vkWyUyQ=+I9L2z()Xa=O#p@;g+L+k>Zc{_yO;2x6c!2sRy3h0sG52Z;dQ
zTqBNKHDhntO=KrQt2a&sG2S#nYs0PQ5#Zly&9ot8W-g6tgbmICs!+$Jep<oED!n!d
zQG`=z{mY{Y2bi>wGf7P{>#4N>?TZ$pBso|pe^IIYAwK@0-48`tiwWLJq{S#gIUVlA
zr(znOshc`Q9>1Hp?jonsF~eL%qU<2J;OLFUq9_hY9{f#Dh(?uDDj#h4Gph{W046W8
zsNrH?7~KfV#nsHj!XtZcFk~jTVSpid2uEnKmmvXGpcZ+6$pz9zV1bXTse%jYUI=}w
zp%T<pWWI(lIN>4?2AC&M2shx>QkvYfLWB8W@k^z~X0Uyg*)EY)xOD!0C*TVkSMZT7
zD2573$pUB>B8{)~6mLr1k?xY}n}8=vCW_fb=K|$LI}zUmoFTJMT?A+Na`QwNdD`Wp
zQ23WhR7hjoL1jgddtVq%PNQuLm#z?R7R%8(hmLQoSXuo?Qs_4n=is?;5TZ79u*rnW
zSE`R)Rc`52RuO{};07PzCRaEPXq^vk{DX@P3*UuBxP1<P)ng8(NE?;`?ejV@gEq+B
zmFm~*s~a4M1I4N?*2Y5TzW(lli*#Q-vKc^4XOlyY%y5i~+Xm`=qsIVTJv~!PtxK$C
zMG9~u5vboJD)e`2oNc+Sclw^FGsog4!sfaQTU$s`KofbdsA*WSaiSVLXrpg)RmRug
zSk!9GI^Xn(f#9KBMx3koZv1mX+6<$!E5*M0P+#4^Y$1sR!#8Pvhqh3uH>`feoU$$&
zr+++i9$=l-h0ZoKvE$&wN`;Jxp!4k}PLxYmbJlKB18mVOxk6aII_0y%v!?1!0-F#?
z2ocBV;X$PqCRS{G92dI|;Ui7`=b^nEVHjOf7k|W$o9kF%FyZGJ!nXN8tNfB2<T!}z
zoL9YSy~!xoxDeh5CWvZ{qusq8=C}dMR_-ClCYn%KcR=Udkf8w7xT~;uB`Ie^gS^xt
zf*<%b&p=N*n;M<&x*6p8Ob%<z;fV0(t_E6UG6Md;C_q6gqzsC;*3KE$=}uCAq35AA
zhC0gDon4Fx?D!~Wu?hbyTf@Q9@ZX7Ikevcr)`cf+ENbicIM$~F>HG8!-ulm&aY@aV
z5iaa$+5PbK{db=(ME$@Q9z%FQ@+f~$-Pid|qzD+k6cg5GuB0<&xH4T`d}q!0tTKcE
z;AYP5tPls4!kjkzOnHm)^Cw<}GXSIMce%t6nBC8|7A&IYc^=FCW0qC|xj@KPcs~<Y
z;e^W2suFqJvvZOJhUri+a~5FrQm1b2D4%?`NV9YS!vaLgRih<zjkCAL2bNOug2fW1
zA~D@^g8chXAi9C>f%)fqr8_j$uwNnz%5#_{W5Moag(-$}YU5I9m&QouI?P}7aTO6k
zj0oqQ2B=Z*!oaY=xhhl<o>}rzMw3lTbbLuPnq&kI`@TRcOy2Gf*ucz#RrerzH>7ue
zffo|zC^4%XT;vpWG8GP*U$Wxo-?%y{{9Rc>Ov0l0Z*DwT%BQ$n^R5Z}ku3a@A2<>z
z{-C6efnkd@|H7k2gJ$s&UYY%`B%`{f3DqBNj*utiIn6cevW^*QHeKEVjEg;t?^Jw`
zLtoTMO^9O^(xdFTQ)2F#CY1cuNMXlDwI+J?fm%7~C`7;hC9wSN3JGtGFc*&{IqJ~!
z9odR4N@Tk}<}%&uy(o^#kz35#>e@+rnHQ^@*fiE+2Ns~8_yO*U)oM}4$0qb%)XB5H
z{dv#iuSz1%7ih%8@23|y^H;iY03usn9yS1YgqqcV6D=d6hdx3-ojj^~1bT|}fz{e>
zlGKCqen8VhbWk0)nUZ4!Jp+ul7=)omMy9R(QWE3!@6)4t81cD}pxmIl<$OU#ZK-Im
zyap`-Jg_Kwk+<dDkT(d4dVxat0YUn)$vhkOi9P9d?j15JbcJLfR1=V_thYZdKCp_F
zvmYhs;T{y`6W4EQsQ(H3rWu{)%pCPkJ0n}L7%l7r3EN8mHOuqw$ZFGyE-e>(80wqT
zob>lbHelML#pdjdS`K}r3ID^xVNg9VL2|yZiR7KTDVKEu2-@fK)<lHKI?+G?Oc+j*
zlj`(T)(1tL6Tu%~)3;v1!JuKu7Rr~-<d#>lx=F|wQf&9f_*51&LPH~qkDf()9!w8$
zvg>w)Obh}dAIXgb;Aj+e5%8x@gl^SDXwxOSu@&H!z@+Y#y7#o>{y9a|=jTv$`UH$O
z$1PI(H>Ef-vf>zB%}6kb@jjT>TQ-*4Lup8nbMz|96cK`!mR4Ee=vBcecw`b#v0Q*O
z0x2|{hKLVB!ug6Y=Kc<An*C5=CS2i+YN#*j;DOJ%noNB=^|+B(yM3lv65X!FH=-yL
zkDY?=YK_L1_n0&N?>{c1tpk4g+zxR<C5{^I=X_^wlj-&lqs^PpqD6JANV*tQRopLc
zI#|!~nL2JdMu)7CGW}pohB^BhGiq>OS+&TYi*2;uv%a6}T_YsuKqvBg2ljhKSKdb-
z`OP5c@I5@I>TfgG>U&`pEXkOXYHK7;8k!6b2J;B-L&%6TV`+ddYdboBosoZ|2lP)f
z7WodnJi<r`j7pueLOY~Uhcj;3n}C$L8kB7u3%Y$HcIp;cIM`(kbvO<W<r1;T*oKp_
z_Jo!rIhb1)x-Ep~P*@`=PrH!PIyvt7+N@!l`xEY@i81naby!o)!yU*X%u<b1ZIY>^
zA5ZcaC7Td)CKK4Zu`ga}v&Tu1YYb`Gdb?qfVO2%#;B#-$vZ5jx<I)xm1VGPZ2e_?<
zoT=jP3Ww9SZZN-4vANVyEiB{=s5;Ssc5HhAhBY|EnG4D6{L6O=N5JJ)0ayl4Pqs9m
zHVT_A#&FyEMgCeSCKRQ(M#SH?qD~0ARyZj-HiVpudju$0*=UOLV!oL&hpZDNfG>xH
zv^^|{k$3vzOh}@amXt7!dwIO3w6`*{!Htk{t}|z1RZI|NN>0~GRe+;jE2;!;@U8_i
zj-R^L+ZqOmPE>-DUTJYmmyosdj`x5hzP6l{xf!&ZTNRmzKI%=;a0z~4NCtqD7j2TB
zu)<0<0U4wFF4qD@bczonG#q^VXNJ&UdfpWdfMXaQp+A*t6@#tah>7#gkOQIp%)c#L
zPZCr~LN#ExO<~gC40rbi#eO%(sj7Oe*2G>@>eaT&9|^^Yow}kX3+*~7vvX>)<ysG%
zVk6>&-#$CU%I8>|^PAwdC|XX#FGpt96g9~-QJhU@-9j71i<M_GFtlC}>$heSq6!s*
z<NDiTOKpYprH>N<g(??=%KE*<*q2BJ&ZljDb22rJp}h9MN;>K3d#6DLmyWNfiI%<I
zTMw2E_hb(Y2Axmy+z-3!Yhc)+Zu$2BRo&cLEgU6&Xy2BrO>delPZOyL=5AY+pF+?e
zzCr*IF&(eeVmQv<<1%tswsG28tJPmvv!;KLP%B9@QA@Ly7&VZ(-K-yJzu-En(0I?l
z2T3Nk8i10@^7`8xE#0-gplb*ih|WX9%k6_Wwj^g$jU(l3(cB*()u;YcO$NYgJE;#K
z{xYZqvz2O4+$xJ;W|8J|37%X>E3XxW=p*fCmP=n)PG`-vK@E2eIR<pch2&U#sFX!2
z_#Owb6#ZERIuMCHKc3B3g7RN@(cu)|I`m3Zr~_;VGh$3SXRrV58wTnWH;hZMs0eI?
zSG=@VfUOQsF5vEgwxMduIC8@#{!t`esEwuNO9M{lUEPG9f><SXjXNPcTR&$kq37VY
zZlKr$u(n$;_JWsqTvY|>#5>Jn6ZP^M+Lp~=Iabo2$PRKuue~c_rAR+>#ba4Ms(>AL
z*ohlH!E=_+ZfVsED9fLdJe%Yol?aAPChK|8;?Y?E+wkMgGsI?A!uMWlv_WC%FR}tK
z=)MvV2$|aE6GRvSc>WEFuw+GBMbEdlh)rE^6C|T*%x9kr^P;{|=Nj#Y0?^FR4VewY
z!$Lk_+M~`E(;>-rVkdOiIx5DDhk_dDVpI4EUhyH$=o1HFJ2c1t@UB5ab26|jc}-kK
zmGj^DYI#^K1K7LWZalne$j-3U^X9UIvPzJm&gF$Da;F%xah>$b;BVC-Dm}vPQMP~2
z#A6Hywg%q2RE*_%1_~}E&miItPEoQ2jym4g6)h@&Oz#pct5kpdwlbH+4#?)i4bwlC
zh1tH|mjj#qu51PJ)uiyRxkS>dJ(`frAc8^A1&?-1(4vnh5Ls2IspQ*s{ggi#Pbw83
z1y);43@~{-?qS#8jAp@BM*;eko|xa7Zc4b*L3EtZ+{2X@yNXL7_#%^su4`fCTJF|P
zz*~zS#+&x4NbZD|Heo@;bS_xbi9U)wl&N)p-{QD&VsR^)bSmfLM296x7YE4<f^eI!
z)s!W=-?o9smN<bb3I=foqFT*(!$j=y?NL;DQx3?pha{Uqt6PC#s5~RFR{q5`o<AcS
zZwUhev~-c!JR549$-w8vKlwLBg=)-sTedY5fw73WD~krikJ^L8b%NTS!&|bK+V+Ox
z_BFx6Si6$k&EQX3;*CMjwT6{YPyo=P8b5T=UlIw#)cTfa*q@!IrFnHr0AmKvi{&m>
z3Q!whL;<u^8JNL3=LT_GCW2ki6gaZw-cFMSWkUSiG>>)7QK*E$>6S2xT)-QVV>)g$
zXf_=7E)tb=SgcG$AAg4PlnoU)0eGQ;<mvLG04IKiN{Cc!#RQ)ZJ9jT6$0=A-<P9;t
zq{4bp4d;8v+b?4HU*wcN(7;wpnEo_GGsQSB@oQh@AISKW8s%Ne#r-w6R`7>RYsP{&
z7EqE95dDA^j0zPA>F&>J--Wf!<Z``P&ye#f6+sfAVj38z>qezJv#o$-m8a?A$a{WW
z`?4+nxNbnXZ)2ozJGb(&eaAtIoYxD0$qBlFSLYKVPB-e;KyjG^5Z@c#9$ePQq<K1P
zh#_nSPN-{L5#|>}^`Mh%6Jzo<uDju(GNY6e;X1e7t>cy<@`S%~Bwh|RT783rsW(9H
z#2I>nWcx-r%2ON$`qap*)ZSmefhVm$2tz~Xg-FOmp{T-@h6JRGP14hB++$AYpcopI
z&vs%^KXOd&fDUE#vU;F3R}X>yFg~>~HGIcfhLX_X$#>$~jSy#k#ukhLRsNw!iU(?$
zJZ6c>5I{Rrx-R$NQ~xbL_b1)wuZMUw8;#ew$dP3CMwTMe`(carJ}f)%XLl~2>|(>t
zZ$k4AJG+6DVLe-W2#YRuTNb;@i|UMr%N|9RACQ!?gYv=tRF_ciiY3ipq+?w)1Z*P_
zhx&=XOt5;~9TWrkN|rjPHv<|u&_(@)@Y;{G$=$5Pn*z{3X8Y&NG&;1S*s3dOo?xcy
z>C}ICi7MXKP*&^m@#2?~vmu)uv69%^qfg5MeK>{Y$W_0%T%qg0;=0-HE~n=h0?y?|
zTE8Dw>*9O)75b$o*wsf>(@Qsg(gRQqqfK3BZ))Yp<Y-08Qy|M|<;okpvDYf98Be+x
z9m!1+hFz(W5wJze+sh{rcom{zl-coO9wRKXFS_)6a!K=MhzaGqQxx?Eu~2bq4?OWS
zb~=G$zh#i{)b3%!-}$(49|93Aq_oKMx*FaTP3@jh&VIG`mmv#Vz<aMyW%6Bp5DPG2
z<l%zU2d!XjZ(y9*ugX#x@It5Mf|yYYa$Bmj*b4E-!r0@<=p)ZvT(O|r_VqoXqekth
zmX||-=h7y-NWX)+@)pMeh=j`oT)=l%8f~uiH3_}`Mh5wzEy$+fK(@gaCZ8!$gF!}=
ziRnU1S-l0@073PI2tVg8Mg`2GZfn#Glph_7#Aguc_1PvEMpt_1X7J}5u8D~rV0CF#
zBhEAC=9NI5b*S+A*;6dVl&8*cJ_8~TF=r^Tq*p{9mnBT*Hak8JWAgF(Sz7En(sLR5
zsH-7XbIH%u(#tT^pAAL0IxmX)<-$L%el00@hT_9x+y8K-MWhRrkWrq$H0gZPDs^hn
z+h{-*j1N#tb8x^Fcn?bp+9}<}Wz@)>n9x1N4tHw>nASx2kTHIa&t24TiAG-Le}2T4
zdkigUSilCmX!8NMk*??5H32BO1{pD}2o4GvXe1hEHaFrn2&A8C$k=qfjMOXjY|h-*
zc!XtpXom?+7oGQEku&{7g&MLJc{QAGrFvwO@oF_ou6xU+AD~06K$q;#3s9(cZya-_
z!9zU%63>%FuTGU7xFz{U8;oL>)kV&(0dyn^pD0DY^#~|}nY5C=Y7SV#v{NaL*yXp}
zpahvP_`4ZFVSxq+vd@`dvqH8+_tJe`dAYff22oauV-j7qOle{BcxPuEsqT=5R(=un
zxUcdtr*Ibr-V_Y=0jc`iHw!UCEruKQ&0!^A)Jr*GKuYzv85Yl5Tqq-v_}jIS?KThh
zn2{+cFZ2&s$5||{Sjn~O1diG3OOkO;-`Hy8*z_Fv6QuD;E7C0vfti|$^3CMB)3wc$
zoy?tpwxiX>qO&+px;a~`g>*{GDN7(Hr)PWraV)&}!?Q^Fu~NH}BEO~27sFl}4rhKL
zLQ%dV`B4;3#5DO~ktH)Uu7U&X^S>0}nPMp3mPC&~hg{+lF|MlMTi)16&#%E%6=Q~V
z40+;2xTM{797zvcj0t>V@^6_pppre6?7J=uXn8Pk`UtDkyjM#Yr8EYXjk~JAYD=_R
zi%VE(?YCbI$jg5eQGLIJ6Xqkv^~mbrVsB3Fy__nsGC&a9iwITWjIQ`&9bOImsfwFU
zRrqk0zQbmh7140`oO|J9)NdcxH(RlLC(MD=zK9f409e~OHU5%Ko@G!?P7L;>mH3{Q
z)2ciT?rF+kOxZZ3p#s}D{T}E=f28IWQ8T9I_KBhfd<MGph-RJE)o&vZN1?)m^)yJ^
z`@#8FN7o)@a`7~UK2}!HBW~6BpJ118b9NTrVIm#QilMQcm7lO9<0Kj%(Q&W+#+R0?
zU#+d4=9f7bpz>a+kxUxdIU-zgu`s+*r`KboF{t?)K^8_ZUo~Rzu2IIDZ-amVWYZZq
z#L3xIc`Lh+YY{dNdvpU)b=8Qi(!^Mn8{`vNSN$GV!#1v{<C$dw-estr<Prl<aF^A_
zwL$_Zn}IJdOlsdOK%bNq%f=sdsC0umIvEp=!)hm$zTb`xu;emiy0rg{D|<EF30`6P
z;~-@c`A`?v<c)q=>^k9JW~yj&{n@1H{=*NB0xS%<M20bGsez+f*~ESa#eR{k!5gfZ
zmTPcCK2&M@#=9FPL2EOg_PU~f=%<3XEgv3EcBaa}Sj$@(G5h%D_kDMKVxCVB?z<NA
zZCma@*+(PZ95@7eKJuaknbp75h@uU$XSAejfklwf!Pg<y*jEQF)ZmBW@VtC^rVJ6|
zUH{h1_&Ic9+d-&B{qm(*j)_n||Ne`SeY$ImA?3rN+6kp!?oKikG2f7W^&>&(JGa*i
z$lf_4h0C5ubA;J%u%0jq{zJfqvB9;s+NfSPG$o8<%Y?On=jSTL1p_3Wy1LVEN1A<s
znSxB<f*};QAAC^*RG%JHo|A^^<$ZXK|3e`Y8&rwhSHV<ce520r71^rWh6s|dy8;he
zq_1t#s5F}>Ux?abP<L~0*jl-pUQVJFbairm504WR%Of-p%lq=ObT@piX4NYB%>9yY
zcurzmZ3H}InwaiF(kT{$#?Z;_ZD}+c2WP;qH&MUHTeltq1I=n6Rzc`0hH;Y%mC7Ny
z+3GLC<{7}%T{!2Fr><Yk724c4T8vriv25Xw>DASK!XRxGrT)dD%5SPm(hM4wLH1Eb
zoM3ayDF#}1ymVF7cW8VLE<FM&0kKBirR0|HK{lA+?CAaiMVat|`NsliC9$to#S!(G
zqu(4w>nj?lMT#rGUGjKBg2RR7Ba9gB92?_!_J+9Xv;Op)Td7BC{JIolFjq%#CHSSX
zBM7rW1{~@A_v4~UA#%HkDMBU|uaB_IS00l(Q`*zl{vVMqjFdiY2`N4+7a`<l$1M)w
z2s>RBo^`y9H3)^K+P*X{ZmI`IlK`Q2n&Cf)agBSJ%ty`)xvgBqK(LSAkMxx5X|7AU
zF;HXeX#md+c949IqIHbS`gS((jS%DqikDU=PD5JK^WS#%6v?6?-p^se7_0#);MnI<
zB=$)!9S(jd=HUj)cxe%grB>pgM6kCTx*VnmyKXr&tGv+QN0${;cY}<|Wj%Pb<qA<B
z_fo?QpEcEyF>ekCU0^^+Y)d}a3AQjGg5M7z4kYbi<$-{Oew;s*lDic?;2F1yt>A}2
z(XW6JF($VyoUz?q6sYPUT*{D=i2nmhK()Ug?946I%UKOGs1a)~0V;wRO3t=NfYAVJ
zf4*n_sENf*s<F2Pi+ECi!-ib*V6W{FP^2!q*`rca03%5aFSeQ>bzKvvt7~-CuyCK}
zHS@jTnu@5GoZI9z%~@O7(|eW;GVPPnl&RQogZJz<-(>1c(uT>=S;Yw*kzfGJ*UYm5
ziG^!b+HQE8=tAX%cA4nC@7k<S&---v*}M5%usbcta7DaL_*nsOYaUcd6&R~=%6D%t
z&hTVRi5jlVL8HL31)XT<?#)h(JZUaaBR-cc0`N*N;`TFiD0~WqvtUFhn~CCc*;q;d
zK1LO6U})fPRp5?tbWJOU{B|h#4d}#c0^9DPXw_ISj4OVT%vDEKM6O&5RlH|}lkFOd
z2cm!a(wQ8iAUdl)TvL?W?S8<&2w(tC^BL-Makn)Y4R4jL{0ww`ohw7Say%N}y5J0<
zjGBS(_SFQNi!%sH!P|(N;Kjbnut^kjg0D!$tC0%SeP=aT0s6^+R0n~qn*M=T=e}|d
zMo?*-ttKNTMUSnDL6g30mBi2(Qg>_B=rA)XRkO-1*JUj&G~lj)X|sM3RAFjLNyq)d
zt}-(S>{gV8F|(W7`Xarl9W^cb0HM^Gz_EUf=PQ7P4xULYW*AlG0ne8dJp&HI5Adww
zv>6IfGvv=)nqzMWYAMniLLG1(1f|)Jy)^FFTZmATG+LWZ`y*h1K^HYAKMq(B-X|a<
z{+0I$wrc}{zFJe@GW8;DgSMI$(rrZKR;{&7?&Ndf&PoutO>p6Dt7d+H0;<W&;*#Jp
zyk@P2-{i1hGB2-bgsXQ2A9iy+^O_BID@B!dz;9RegW!?yW_VW6zctjObgr{bKSkb3
zn44z;6SjWT>t?IV)Ls%`nXguVKpI?@vj8yoqHt+i?}qj=fEGFtvDyZdlbN`-I^3b=
zhi9W`1lz^Cwx$|#0p_o=pJ#wcsb2TSW|Nr}p`GcfmV1G$NA)|zbjFEJGx?3ms(cQj
z8hepVu!4!GAp?0QSHBT_fbhEJSj%Q?&?dl%BwiDT4-cb>a1Vql3Y{FFv@#A>Wsrt!
zT{u&_Gg`5{vCbq|)%&-@Vgs`Dua^YSNm<L5ERglXp^q`Y5(r@GtWwP6Z{mFpf6i@u
zu58kLs`e&KYyBs1EzsbizAeDSs9;o^9-cshFOsu5d=hp?D)64M_wBR~1y&fiiO*$5
z*azO{hRIo)TW)RPOQV=06vrR+(e#?8=QS-5SJeEwLE?)_F2Oh^RGz<80lAb31p>??
ztCVYm0iH+TeSj)1f2(;1%I@XsWAB+~RhG?+(V4Vin?O|84TS7964}ZEm01A$wn0SS
zo(O2BnscplUPB>l@r_MLq)mvR%_1^T>*)Ah3;5ilJ|@e5XfjVqHwBF^o(|qAD2Q}-
zhf`6X%c&nB4Iwq3G)SaaFlQ@R<jc1=<T<a=6xnWd7e&Z%4X0p^Q?!(}qTBo%2BR(%
zM<p&6lp9gMwTcb<QPU{E(>I#c-#ZoIhuMI2;BU=WOcrG8&H|BOfD3P>Rh<cFURGHz
zkoL9=8EsvN@I&g?YcS^;nZ9kRQdAalS|yC8RJFMFH*(Wxi8AIk8bI0A6l;K6S4KWr
zEt-O^uoO{4A%=}a(fH+Tdl{0ZHeDC5GBqH!Q2|f9e-CM;y`2u8t!f&N?R|(UtLxx^
ze6AD537QOfY$Z$MH9bTxt2f7GTi&B<!bmpt3&055k}3u_LIT_2Z-M+lyS|bzct4dk
zWw&zGj)nm%2@po2w6irT@Ju?$wT6(i<Hl^-bA;b1=V<6e|4}C0>wqe>@lzrI{|UG-
z6zKxZ_G(gV)<dkC?N~tmG+6@l+?}9th=4?iEU((cM@4=tU2>)-$!xd|M@DQxJ8&bW
z$qwGRN;}>fu%ks$=XhJxK_S1@Up2Ju;ftDU+J@;ZWaX9;A96<i+>8?>@W>;E<uo|~
zS`fdnhYkP6G-ceq1*PUMcp6x|y7kMA+kb}iQ30MwxKndzd$jk-blzzWDz07tc(ka}
z4*0sT6g`8ify}CG=0L$U{%+^(@nm9iHZqoMIu+1$HHt>ip`qz37o=%xaoe!<QHLc=
zFja7YOc~oy3OIg}qv$3~wMG%bZOdsoM=HSkgvnDB%aD~-iSoH@!41=P!FKYfRv8Kn
zTF#P*+)4sLX4J)z3h=k!Z3`LtbQ#7fYt)s4txyEdEKxg}XP&y%?(j@bJ6hu7K^Ae)
zG)iTFTr=tjtaiMJ8$5FEL9Bf5cse6vB`=#}OMrKJw5d$|i~|PIc)ju>`TC5xmZ0zY
zZlm0I4^St^2*b`XePteP+w4)LwqItIrEV1(n>EE^TAi($a3SJ=3_;JnBJeE1d^6I=
z$Vrdq<d67FpfZ&MSq$B%0IxZ10HNk)pXFQ7JG#Rb?D4lCU@G$iX|7(gj&rlR${`sb
z72t2d&uf3d#TmD+91ExmDkvEPYv`(XJ@rS8@y_5ba<Wift6h@}gDo#j@v^4K%928x
zjajbd>H|>&B}+$EJLgDux|LOs+&NMK-sc4RR70Ev-ZWx2w;PYZ5BPm(No7t4-uzza
zI8^Fu{NE|nlN9BH@z=Bp$S*KPl??$LcSW`(bf?9LK&soOgYma){``?#)g85z>H?c5
zjofTFprzW~RGjsh$p(6tM6|c<m{9GjNq-JWXEiOZEE_xU14^&MA&mAdumixZEWxts
zVWR>(lQn?SWZV0KtK``Z4>J-}B9%HYyv8-Z2s|@5!2$6{jnA#YtDm9=n<Vxvdx{pt
zP&ULS^-g6!tqwUTQ`zIylCp7uLVQ;<_>NW1(cjT-W|`%NEWojebie{7uW~XQ7pW;v
z0CICjjb*-T6;0#-q>D=>K-WeKu_ST>c`q$|^tancSVf_6`L2lfvfVL5!w0I%g^|E&
zsW?rE2_eEFH#MY#XfKv$^Z?<}K9t;(HG7aOdm9_8@+8=XtsM$BTXp)QNiWvMoz%<-
z&*ZX3L^d3!vK95_l^8j1R$O=)P2K5@-yr$AVAg8d#VZQ=>m%zv1<%qK@S9+*D15F5
zDl~&V+;2(T8nDzVq3i(=;3$X(0fIhg<YoYl)nczur`KXl+a+|0ss+4F!8l(g6hEP1
z6ac+=U0-jGvz{gXRxYQp407CCZHOk%3c^}hJ{oP_=vISj1>sW3B@o8Aoe|ws*J_&P
z<nJE15VJO^Ef<Sq$-Ax5<;@N@YsiL8M$mu);75z(6Rak<>&YnYu<}&bbq{d|fp%+K
z&0fpqYy+uw3IHywbOe$^8&lJGa<|T$p<ba;lQNZ75E<3z4H>C0?mAmIh`}<IWmA<J
zOK~i>R5evBcT3B8y}N0Zv<!lEV-!JsA~rj)Nd_9MRhMkoYKW)_W);$;U@44zZ%#56
zVb+uhHGtBYp&J(_O7-m}S#MyI4CmnM*Qo0(SFC1jn|xnYQU#}@;Uvp8k>w@bX%Ok6
zQr>F`SY-{yvN2M8E*o>8G04FP3o{yE){s1Ad3FM`NLxB?bsp+{v*G-?sJ!j1Hz9zx
zjVwOPh7{-3j9e0g$9>ClL)hwD@is)YFUeJbtN#KfKoVbn6Ufu3EMtqy)(UCgP;xhv
zEZdk39B2&b1wSo1E1(iZ{+-QUZd<k&3{8u1r#F?=NL7ohimc%-ZHl05yERYV^iv|x
ztzodPuPF&oUKa=WvdvHLW{Saa9x{02!TbH{j%)=TfyXE|yk3)J;sFRFFtc|4Z&PiJ
zHU(KV#>u%^zbOQ^s*q(WaGFER7g+o(ZJveqxv^_jHW=hoiW3Lo)1boIX0f1s2cQ#Y
zM}kQQN7OWxrLTKxBd87z5?<)ICk)%sNK&|1qYeZ=W&bdedkhcq%a;zPI<-S#z!n}Y
zaEWf&K!tDa^r<2Rw%MU28qYbQA8K+83p%}Nh-^RKQJtO*9rIc;Wn0FQB1P3G;wAXE
zv2EKY^*$sUUrj~8EA^Us@wSsF!fAc3K+<$TcJrQqFnMQ`jzV6lP1qwChNqYsb9y%<
zInv0V0^6^K)9PVgokqiLqY4z-JYeR!)9mqK6pe<c?&|_UvTYnIi$uv{SbfrQ!2Vv#
zR=@k%7K@?LF1|S{I(zq1t_QdxpaRwGs@;V#ut8r0vDLcT2+|-^=V~cQjl-7FP;S${
zUkX0A;cf89dln$uvyaBs!3b;A<OC&1s!N2Jo}k4;9fE}?Q{!8Ar-&4{1HMb=du`K$
zCXLuowk81I`rE3adTF~$5&;{|k+wz)LL4kK@b2eW;(`PmRt~mY4m|_m$O!b1Z2uI=
zLJJ<}t4MOTaR~&9Q0ksZY*)%K@^r)vct1}~lF23|a)RAmU?0l)sVAz&7{>M%l>@<E
zo_@CK{Jjm{pdPj2oicF?{^zP`G2eUKNg73K(_>f`g2(VMMH+kCoz-u>XY9~YEyn?w
zyKptiAe=MQt75~2;eIK%aXFjD_3q8ew>7eL8`20@(<(rz&rliRhDjzd_kH+SRgQSJ
zX||@gz}2XM6iRny4C=4()-23-)WJH2wtPmL$whFR)5{cy7`l5D`LBj-8Xc>(6XPER
zF|v6tIvqUZY&7gG=bIEk1yi#_p<Xl_szAbM<ywFqKWg>sCKv<F*sc&rSQPGR0T$E=
zz@EW@JcHHG%lX<$Dw6bI`N&8x+()tn*91Q{`9Wj%tSz<(bnOL@peaV+Krjj<)bP``
zyp=@2s_i|AXB%!0HDBA9iPhBX>}{^J7BfK)rbgu1+WMq`Pq%r0L8TyNMgUhj!L>u{
zB(oq>v7V!5_HEpn(M~tkQAW>O9OyV@oExyy5_!BJ7YwAp<!lggMur{S)Y8oP+Ch0q
z5XwB!a%Jy%mt`VIelvIp{vlADZZ}Oqv5JGE<xmGE*@vZUa*63^+8dnWRGDIc_1x;$
zm{vaL6hL#p{wkft5yH}_d}Z2T)TK;)T(vs&U*sJ$-#+3;w}xieD4`iN&2I#27UtP1
ziudlvP<<i6gc`-%v@>P*Fci53pSCTGB&`nCMdcRNW}glM-DB$mHA{bN;A@ot#Q{tm
zwHUE%xO4_yV5n^xDl;H+?OxQY^(Ks|WXJ*GeHriyVBEgOURx?oqT!<Tmq#@e-{qG|
zdaM^lAP_DJ6of&HY`X-N@i|ubrLE1?*pU{k#%81O;txU!q|5RQAkNwuaBFGCb~LK}
z0Huem(WYS6YIX+61J@&2cnh$!-5c0F#-_2f2QTb0AaH{11N@eVc^lNm2s{9u)0kX9
zo_+UJ8K>>yCNTlW4JG{uq-^}733w2~(N!9n!&0COuQ$f{HS8x)M(qel(VB%xrW%}U
zS>MnY8wjdQ@eWtJZ!D7Sl&QC}FWZ9l?m3Rt)gxB>vSwkG;z02S$u;gK<RrqCXM|=e
zBYZ#&kIHXe7ZjuG%`ylK07jtFtBGnG&~hlkpG-^D1bwaZ*^^wCZdLmXVq42G{!t@v
zjNsM`igp|MA5|)em%Z-Suez(seWwjouRnSW;ebixdkfJ5L+^f$b*GW6r4B2p(saCL
zAcL=;!iDth{b>M#S>sGW%D%o%E0b=^Ys@~Z?A$+Z7LL}NqRnds2xByY&x`}Bny#~8
zxw2a-C7K1kMpGa{x{Xe`TNqC3=9?8&R@L2s;JTP(keg+D2$tT=FHPpLN`yMa{%qi#
zrX}=Lf=0=CE2>r<o$sM<HF<@Wn+=Dhkzb=~30fL+4$URr)`h3ZCuajZtfLxxw}Und
zHz>>1<QB_(x=Vv*Ek;{L@@CNgN~g2Z22N3(InZF%=C~3s47-HQmHW+1cHRTvX&p9r
zqivm`AqqA<L(a$sGHUXShfUJz>I>@uv_ybv>wl7#L}VK_L-23YCHo>^hN>7CR`w*}
z328t!49>a~)B_`JF<L6xEm2Mo*8{@S)DCdwZ+b=;Hnda?p0ke92-5tpOrwBDx1EYw
ztY%g&5d=bcEmBHnbZvbN0X$9(5KnXXVH;8+`5Hh4^HR|u0ye5kjvEkG6CQ49hEJ)a
zux;lX|79Ca)u0XNu+qoGZQ_3<@UZcU#i^;*COao(Nvt%b(V2p5TV=Fn-P@46rjfaL
zk!cFxfw;?v0aS*xw#p%3mb99DTc39n5pDrKii8Nx+}5}eG+wI$(56eHj*60{7cB2;
zT($CHHK*@pfRLmKc(yD}Qo04eM%y_L#3vEV%$6+SrrGAW=`~c}J|H$%lRYfRy;PQV
za77Zd1y!4qq|ydEuByEN4!|{5r9LhEBw$>#tr}qMF;27BrY2%sUIfSHks1<x|Gl>C
zk|KV|R~y3qu9Gd|syWrsrtcHD4vTgsfh%u=-Uyc9>AVfxc+UkV=_<(%oORtXe08C~
zs#+p8ZMdYGMt26^QKKlZ100FK`Lt!ia)Jw2At_E5wz<`B>>l2_qW2)|!x1p}m2Q>O
z1iyrVBiNf0v_v!5PrG2MTaFddk&edRP9v2hk8T|(uqIz+TOq6{bO2w^8pB&Hv`43$
zt=fpBzSwmBsyz|7(Hj{^SuiKdDN@(s^@@Cs`AUg-{Q=LbArcPv+np98Zd<p>dnf=w
zkS1RLTGfmb=&~>$pQQq1uE=K$d0pI^#>Uz%U!}IKn@A;0GxpIV&k$g^oy)V`zS^_}
z{@E2<c&@2mK*L&C3H%Mitumf?b5ZlJ&%>pbG#Ye+B#M016pssERtQK}1Q~R3sX@Eo
zE&90>^*y#lM}1yat2Dk5vLH~D)iGvF>Myu9A4<{e1u;L7G7l>TVDObYS`lkgBkeuA
zecMi(y?W}`vBW~vxZ`1_k$PkUTAKD~?9{S?Dlq*v$cOeJ*#s~(Wmj8yJJhpt09v$M
z%pzs=BR<O@-d7`S)0Al+z?R$0YTl2K7-evx6@RFY!)=??PWxsvL(^682Q)x^2flz<
zskzeT>||{vuBpKF(PkE#KYle`&~~P2bS+*j5S1p0fs;A)7LDGmvPmUFmN?RcrCCE0
zal5uvN*U*|Pao<XvqgL`X&UI^hHLa4_ZV!VPq7y0>okc7BrIr80l4D^aG`&J7i>%Y
zBesuOI}31QpfYMKwNZg8L$x`&Zqg?nL*U91Zkr^nAXQ7ldNk-CvrS{6&z)etHn`z^
zCR>dBs;@A_?Z(%)7=DZ=^_Hp^&~>!{-qOEYd{KLyz;?5(9(~U;2B0Ld1h{UjnzEH!
z!j*_U3K+!Jt|)jQ&?;gT8}$;tk=nZzaB<=j++&MDqqZk_{Z*i28I#vwgxqH%c3Rd1
zr%88tRG=750Gkfxix>=K2*6H51Ns5gAZD|cR`6`%LpQotFKV^2{i~(1*0?dZGC}@!
zEm%AN)ai?~+ezJT`J)j-V$Oz#UrnRS>j{2s4FdtQR(5sU?t`Q`{}CQbQz&Z)mT)7!
zwXsl6!*-la|JAfi8-t=C4>a7Zsjbk%Dwwn>`vqIHd=peWU1D_$RoJxKceXgtqot7D
zBGu8kpA!LRTPzi|^8=4UqnEAuxY1~=XmL%Y!(gblYSL`^aQ9+xVAVrq1I?C6<}Jex
zVct~U1J1m@G#n84RfNjQGjmcmy<;aN4+;vN7&-J-@V$;kCy~9p`?vg4)`&~s5gQ@#
z?jM*dYgIJBDY(9(l&)C~B!$r5`7tK^QlDx9Z5A&3CQ;bhxeqMi26p3t+dRypjdclN
z9?VTmuNN4E5w-wXj$LCjZ6ASGv|o(t-M`KA4-`&-qLGFGs?}nt_8xYzfW(W8%yc57
z<@jhAs<rFT(XL5EEoZ~sH1fHbxG@?GY;rZu)aK1E2^DPcEN6Y=?0POkjl(ugTWP@x
zUaba0Czkl`-^N;B32L(JvC@>u_EgjHtz!MkjAYtE0o%j%?!RuxvnEP`!NKb@`dVz3
znb+L%UWRr_oC-P=wwh#Z4I~vjfu+`{bSDfZFoqh+!1E)c);`q{HQmCA*}nU?6uh!a
z1t7<1-Y*=G4JuO|yH7m{I9U)&8xLRoTlzLdg8a(Bwu_s0TVpWI2{KA)R%<G%Y;%9X
zxfrQl1&>RE0Cq4zbm>sGCH7QKwk_&@zTF3pjlcW9y=V6|eV+?}#OTDaCOA!#Sa6vd
zuL?b|>;}Qc9`$~y<X!Vp^rJ1P(N@ZMopkd3NOTxm6L?^nyGouQRwpVd3kdR3Chz_M
zV3NQj<OnWvXht+62=D#}D1|1Fl)1s9lMJ0pwnp#Wzb)521U%O$jd~xTqX*=c4!xyi
znW}gHrm%z2p4s<aA*u<^N-4jkGq9H$lbdW&q)2WZJ%^~tJoDImYyy}Web$07r>F-F
z^{ho3&kKx62ul4oZ<7?2#tj=jTw^dV#36o@Jvy))OZaBC35U!i4&P4Ia<{R@{-%ln
zZ1l>^j?I7{-%ROl3s+P^V4<Z$Cl%UFRpW>~NT`h>=bvXggVBDNsA0W|{4P+SGL@;X
zGc@&O&-=DT@*V<kB0>Hf*~pZpIW?Q=!$8WkHeY6$t^24b6Lf8c<YmNrS*?YdOmnlI
zX4QdPgKCL#f)<M>Sam=TFen;IV8tU^oHy%Uml54MaF>;tL5NzP+Bm=MG!>b&RA4wm
zQ-)r?U-iu9$uw!C?O>5X%9t$}I_fW|pbJT43LIJ!-oSAI_S7IhQ?r%Kl<jC)X@XcF
zo-@A^)?T(_gg+dh`lh8?7iilttDf!wRnwxby-(CYhL@P?1m_Uhku(b(e7JoZMZ49#
zX#DKhK%tx2C4hwMzg{zd_pmh+{(#RVWz%dBzXD3;%5Ku8dz(P4+GgM^Z*^w0Q5lp=
z<75|@!}iKJ0Qjjvegh^1k!71=1gJ>cehV(z6o|vWB?3!eI^Z~Fe#gNHX(8Rcxw*#d
z%(@mz*1&;1(^m#rtT#$ycr62NDNow`WwQ}ThyeTnVQ6C^0z*N|3KxB@c7Nm^wzA&4
z+Q1l%hqZ~wn&t<*)!+aal`U`<C20CthoRJhFl(m>B-*#coz>F;*k>770^MXAWmx%8
ztVSqCWq~2&li3+(gU;1M<RK_6Xb({ZoE!wn)fNzFaTU0FURs8@ZDUhp1`Rjgv$6~`
zdkfQ&jN51_EqUyKdr<+Lkuu1m22JDuOZn}Jy3Kl2-u>5Q?UD-Y;B+-0!ghrXWs4jP
zX+J6pw<Lo~b3^cOO(Zfk+U5i8v5N3KTfsCKucRGJ$J>x;M$|2s3U0@2ku3!J%C>FP
zrz7znzT}|ZpKBw=1k~4C>wDBwd95_`8?dmKN}i(CcX?(o&4bQf)u#py-L}BIySCNj
z-M<6VR&z9r1FR;=`!<r*ne93OCfPGXVe<?^*QWRg757J_LAIERL6u?oDs3FTwi!iJ
z(N^5WX05*a_op3=H@Cjdt(_Y9IR0zah*wg9pArFUqRJYd1)~QONrMk~+5vh<3i9<q
z#veGQ!1FP3xZ%_~NyO;D`-;qi!Q*l1Q0_h1lEXYq7{g8CU}LDJQqT9`1trxU4@3Og
zfLXltGZDN6Kf0RHvb7wmAqAis(8FtTQ7Bo_Cm0ahgh(e+ci$REhQGJ5qN;7%wQ8Zs
zowh1i5%|7r%DW7y&COP4y<f>EIx+yph<~B7FRO>7Q@br%k)k4XF~@q;)CoGQMoTD{
z4H9E?$N_d&MLeKgxdpLr7`<IIJ!!bDDL}&vf>QrhKUTG@#BCdm)nv41oZ3WeD=v<9
zE{yudjf&7skPel8jTCzM7LGvkqexS*1hN|03czR2nmki2nsFtl2V8*U3s!RYs_|c7
z1c^jx*lgIQ`S!J4;C~ti+shETraU#j>lX#;w)cjhvG?VBks<2v)#|4ARs~51ZPS>*
zr>NA+dLQM)T}j`rgqw<uEv1n+P0@%s@Y}XjdU0~{-wbwmtMVh#-fW#730hjSpX@%8
z=)9Jofqm4Z4U)J=;AE1uiT7-n@O}4KS%P*?jA3I-89j>`Zc`JGVEf0{L^iW+NhUD6
zIlHFuaa2K)IC!I|=nWugU+MulR-%(Ny3P84HS!lA1Qhm*>~&atWn`c$vuGMsYB>lz
z0KbRYNC5o;f~@L^Xbql&K;nQvI1x$6otaNMqh4*CDTzE@?)6UfivAQWI)Oym*iRA)
z@7>a7Sf4#kWNEJZxhZ@TEl%^5#1k$DCQwsH9B9BMz_0;Gp{P!{T);At&0`ye776J*
z7h<MGT@_|G$8Xf?fU98|_qqtM&1ZxFT$R39n?i3{rB>F4OVa9NY*9ot)%eupedbsp
zol46fFGqbn38dS9;3R-?rK*WoJAsqZAp)Sap%JVN%uSQo4v<)Inm?akHk*VUR0NiQ
zQ9&#CC@LKR6vNYybPrp9M*st$-D(gi4&8ra>&n}`O7OF8IqqwoH7lU<14yB>Ww`IV
zu~Z0<8j~w5m$uMm5O6J`va-`Pyr#X?)HOVzKm}7I7>lk=ukGY!NRP_iItcDm<bT-~
zgrhR8HSrCBC<j-q33Abf33+W)->F<R_^+P)5HXLi4OwG^i%-{SjB2srOr1c^wyNMh
z_`4u$QQ2+FD;G7E0!k(*Eu+T)=wI1nxZVN$u3B+Rb$=25=LQw!v+4B&X1zdrujZWF
z(DNaJKjXdX@rl-P9kr(hKmtIT&uGgHJHcKzma1*qpr+spidx&CSWT!aR+PWLIracH
zo`Hg%Y<IVMF4~T;L43xw!B{lTbXn8X)TA0{e`lazfznv$>s`knbrc|kp1I2ag5@mp
z&>#ixL0z`04*a>UYr2=SG5cSS8+a!HXSoip{%De$+g*W$9xmP_fvcr5{kM<6M!5!U
zpa!{^0<kbffNn<s%*Iy{Kvs|duhGz9;_@1q+kjTP%BVKb`wB^=P~k>3;lj<snGuxM
z74a7Yv7y<VIQ0RgxU#mvz9Lse@<DgwR)zvDFg1Z>qg!=kjfY+MHI@6qStd;jG>7ih
zmt;dMPF2}ex4E|jt{W)O3JKnKVJPGD%G$$OXpjr6gX`Z2ZXAd$^m?BeP$FfAZGy^h
z1kXFbaOI)Czcb-V2#oKsT?Q&gJh^?@@M<AEEyjvgEI?pv&c&-d3FsQ%*1}oXzbTL$
z3JyPO8d9h=Is#_!`?D@VH7sNA3cT17d-r3uKYmCHH>*uFQdw+B@SummnYMedRn70a
zy}#`x?=!hu6)T_7_xWuD7Zhc`RUTH8%3z4ioXQ&ax`*wrqim$yx~5+Smu(XTgMrIB
zk*X#ZW|%$oXuzD@rUv|z*4XXq{mD5nuv1G4u4;7fwQZCtGX|z;r)aGGOw|wdB+iJh
z`k(I+usH0dgI-39h8k=eRIoZ3|6N<4^SaB%%o9vz++)?4M;J&5uqKBDORgx*3Z~h<
z?R(Y*DnQc5b~S0)Q|}2fuG!HL!lejdX*Mv1AlaLZJZju%<*1p<YBs#;vc}sfr0#4G
zzVnSYyf|d-FX(OG{*5Ix#-!yDHYxr~wd8__%mkv*TlAFxqg$>^Yq%jqu%#-W*w*3x
zEu^qe8p((Y;L_TCP;#?reBbQ-y;f1<VS_p6i*rCnQ9BWA1F$tMzxxS$q(ddO+{sjm
zzi$AHM37_S+)`J`1gzZD-h{pu;DSberEG~@l89)mR`qW{+fjWDuKK#%*KlXk-USBW
zt)dp(Krn%C^VbBIx1w_;Sfoqk3K=wh(?Q1qE2iuc2aRb9C!BKDE(Sa;a2A!lUwF5k
zzA<8Ovx*WsYXMg#2)~&Rfsjkywhi)G;B|s(`G65%!nOT*H7hgZnOH%#Cg)t+h@hFw
z+2W*$3KcCr)q|o*wqfO4*FJz_2{Pe`cUOZabT<Ntk{o5cl`Tgc;wY*YEf9{PRGqUK
z`<mw*A<X{LcxDT72h}Kg+-BC~8F)e8R0j^w<g~D_TPtk#-z0=(Ztz{lT%gkBrNOEX
z8c%mETdrpF`i3J44A^Y*uQVmv+F+8_GFMa7)B*H0@01!ICMdk;aq?A`Fz#ZISyN?h
zv-sA#XB!2jInw!nvIjZ>n?SO^GBDfp+S1ps+`swW%M`#7ya5{lS58eGi2xNOvt`eN
z=ixbntYu{?9c;r8@qqw?`>Jj~1=|9zW-b_(4<x(ezKC&b71)>{A>Rvfr{y>Ut}c=A
zTK6}eLD{-uz3FP!vjS5(V&I;c)W5Sz05@-%Ofv0s86@ekCCwFw`hmTu{N}#7pPJ%=
zQ`_1S4ooy%`5MdtH?$AJ_^W1*gI?nQx+XQ@aMau#1}K51$E4k?2UHVFY)(FjHVC>K
zTfG>zuexb|H9YdxR&==G4s9k$?5V;<kX!?8fXfp|+;xJc(7;YuQ>{q!n_H?3a)&l+
zLudjxEFbA^78fEIfK=s`G|2>vcxgC8x9tsGBQARb7a<8MF!@vaEG&PcX#cdlou;Vy
zVZ#9k+5y14)n30p!#KxFVClh%S0EsnanF?*C<Cg`wo~E#R`q_W>ASgplX|8?vt=7q
zS+izKT1hH_WXe}No$!rGq8Ffeu-7Ef7FzNGmNt4nk<|N}fk~n!sI26VdS0BZnT#r<
z0`kcOmb0w4x9EKrZx_y9KoOufFyNC0guD`Lhi%)&39edhmIu~2Q#c97;6ST3O5lFw
zTcwIn*uacBG+Y8Wv{hwrpnpzeld&lGl@-CDXhwR1qsj^nWLql70NRF~0CUzv6yuji
z<GXXaTFzx<kX753ZE}5EUeRNiOo85J^Qa3+=rn_q2;c!A$J9vP3fgIF9^dt|O@Clu
zEfiZ}OHu<Gxubd;Pq$7jZFoP^Rsb+MZLtSsrl6U9X#z}gW2~?7yaFV-u52|ZY}Pp6
zcurD<#s=R_R}+xdjWejkw;M-fU~}5YyE_&1C^w7fRSzJQl`({=3#u~@*>>@0M~}s|
zM^ca^mM=JPru7~U0qJ?eQd4sZD`>C`#1X(=li487Srg2BHCLl->;*#Ys-S2VZ)Omt
zrVC!L#$MZ0n;FoX^Vk$w5)JDf`G%H&h`=lnB-<jHs=hGzRd_`P*&tYMYp)QT^qne8
z^D#N~ff`VEUez5otx+Rq_b$73f@-*T7-EucA8d3jgMKw%D@b4vk5H6EpkAosw-oQq
z>tqnAo%J=vw>j`{B$fF8wi=5;r!)afzu_U#=#-krE&Qsz9(m&7m$HGu+Q(IHI<6l}
zBcspk%8G8hilW7@@VKRDWGmF8b+F!_j}L`{T8T9k2X1656>e31PE5bp(r7X9<gBGq
zZ0<t%kBseI0N)fao8YMFC}4|L&dP{Qvwg7IS_r0@?*7uC-U8`V(gWfURX=9?odnbu
zkg;kPz2($21;R%2!WR)VRx=v}2F^-Ew4raqfHf`S0QCbIk)!vveOlXEtqVy_ZIBR<
zAVsvcRSr@a>#+giUG?p8ma6F-ec6sGWkc2++8R88@nJydyhglhHthvSD|<0e>+D+s
z+fYmx76M(M`KZ<5XC&K!@;O<+tfD69X_e!Qcz0W_%liaI?^R9Ku*|ut=0DkpiJ0Xe
zvSp&wxN7ZLQw?``F_-7oK#9MV*41U4teW^n0srQE0ZKHBNrnrF^h(tQ7-VROQqq?4
z6R5Tln)Wpb_A#5Hm$#Qcm6J8wdBn&nBqPsnK@Y%;#?x6rN!0xR3hM^~tH=Y~k7k40
zu7s}9uei(D710GhZ$o7vz~*UOl3$y_zOKe|&GK5!-gQo2?$FT`oVZhV4CcVvbQqnm
z>0fF>+{OyGYR;o=C(<$|2hDKm`UkRtV$<mWEWltfdYoSfQWK(ZP@1&hZ1S8ZnFY-|
z?f)9Pk{oT4>$Y#8@1P^ZJizct1VM<=5@5)HyS*}Wca!-TwQ?JV7W!4H$}hjnh!^A=
zNDZfBxdGWvDUbjRsD~dopd7h3HbkOOG*CZgVV?N=E}cRzYA2Y9axg|zS(VVi6sg0d
zHaT1a6s<@;mrC~rx}3*Buk6i@RNd2%ro)Fx8OeuHi=_W5OEOUd^<^X8OA-*rRX@_e
zuVHm%i2>eRmhnxZDvqRyX_XLz-RJND@L5E7V`ne>UI<}(%f%JAiXF8E#sFfc%BFF~
z{4~|^p}p>@EYtF@1u;-oM#G^6!EMWAu#@W-doPV9?P_bO)KL(?1Ky+wwN?7c1@y4@
zo<8~iEl|f5ro&=-wq!{1(a+nDdXi7<s$u}Af=A2XhP%2+{*fN%0#sN=HRda6O&sq{
z>zwu-S>TNxR?TTf36EB@JcCJP4X$FRWw2lSjyd9PEFpvKf^eiB^|W>qNQ+puMbf@Z
zXBC0W-Gg(g6bDY-4-L1n-$inu4upHDC*NN-@=9?Fdu5a*aRxRjN+cnJ={w1C7C>w#
z)tYnwH<cXl9w)1k45Zvka=z|>Bo6iNo;kdRa4AC?ili6sN%AXMRFaW#6`Qd`Fi?jj
zOGO4%`tIO}@b_JSoLg*9qL5-xO5jw$ZTmTe@w^moDo1JrN*l;dO-kC#3R)$R2Xdw?
zjr~FMdAm<~l580ac?z&i`(CH8|H-}=CCqb?Vps*c*X-L46lJ#O7AU(grsk>&eTA$#
z173BjW;$3ISu)E5_J0a>1>hu0Di#qoW|>GPfP?M?kS-RGDtCDH^T}mr(0GJlBluw+
zEK#*{OrRfIS100tKDG{N3j@$>2^j>jC!i6r18L>=eV2@d8q^+BQ`lGSCEz_YQTVQd
zNOy)27T59y&a?y(2i0V(8SdCgLKb_2nid0}6fy}#ieU?Eb3Q{THbkmTE+m?<+Svqd
z1W2wH;+gRJEK$JBW|GJTC`#$^DP=7uj{rP!ENvrz_cmZyBhhXHGAOA6l!!oYiLbLN
zIN6gxZ*;YmN+ew$ED;BAex0)72+z?;M!1$j(=@{Xso?Ndg^SvbTdH69>IfT}F)1gl
zs$ts#l%V!(aC*w3eBUwB8@s8k=wyH=!(f$??8<m2gxe{Rkm7;Q)!`72_rpH-`a{bs
zRkZ0nZujX~0+2dlVs)cy7VmJTKyss-MsHG9<U{QC9PrLllpslM!2XgwFY`J;3rn_i
zsxsPh-dy~uRtHb3SbHxKhy9J~CD!JZuaM6GbxIoJsGIS5pwJjbGYGE4o27P@aavC=
zk&_kxDb*%Dci2jjClLAl2KHA7^tJl#`G6KXwOZi`RvBnEDroIH{`AjZfBEOX{QAqU
zzx?+5`2FwePyhAzfBYW9Uw{A8zyHTS{_U^7{q67f_uu}U{_^LL%U}NVufP8C-~T&r
zI4(Jy@0L`{1+Q&9qRIAf!^q57c6;`Sb5sYG7)%~mV4A7&BON1}*dE01cD~I8`YK<Y
zbM6gFb{=X}39Eugffqb+5mt<C4|xtzs@uZ%=B7QTNK1xkiFU+;R3xK&1BX5=hIs__
zE!92Z_Z}=UlN$|$rDC=73BpHx`$OZN@4EvWtz#G#WT*s*G#n7Ms<tu)*WN9uJZMm*
ziZmcJg-KM6#~sL52XG7Qz>*N<(9r!E$)<i~7)X>gyj-#Y(vy5t5GoIrf|SfEt!E9(
zq#S?Lr)UPH7Iot2EQj!(sn2N71V<M)xH_8#!kfCE=*u87igS+=g?4V-?XRpAHha&v
zo*@o_zNfHu;wfmI0{FIJ$iW++dp&^@5EI~wCmh12ByrQsaUbJ7Y(LPfZ~}PQ%{~0W
z+PR%q^-%xLVl%<lbw7LyxWLHwzLeC_Ie;ZxoLY%N5GCPE;S&HqsTBgIZ?7aMmiDmw
zL@>C(*!F!n46eCDdhX#6F@A}7j{{omoQ@pA@I~#e$Xqwn?V2QkUEnD>WLYqGymp_7
z@|MCi1K^^2SvLUuE+y|N8x7oU>tXsro1^cV%seRuW1V7$*g9DUamzo^oj@IU&8vZI
zNk|4K;NpbMcMslC+tK2g10sD%R>!d}byeW_&pO|Bo}d~^deM<{NZuI160gFNf@5)9
z!?-oR*pRC{kO25!Q9Eazd)hTC2WOQ)WoJZDcT5D%2tn0pfb<pAS%yW`pSVK9&XDZ%
zpsxS1?~eG|yINe!0wL~Is*NB@T}GogCW{nv7ZIR3+D`l`{5rc3M4X;s_JDy-g~5EY
zIzc!C;i}Fk7x6l54FF-bp+W>gWJ@xuT=e*oO-H~Hb>$rdp1KhQtr~ntdu&Zo_=(by
zc7{w`c1pG!VR#8=`7_*_5`Q8Cw6z)&*rlrI9GV1qw`=aNCCokxsHTh4^ma%XEe?cB
z6<%RXKt0XEUeMhpk0b2fP@?4ku)(Q4V9%tu(ZoCX|8EsE8Wn`DtZcy4aKOCr5g-$B
zg~f@x__{1zkhFjM^kr0J9@L98ZkH}Luaq^%J=9s#oH{_3av?x0Ge6^2*Rg9YNl9Za
zDjt8|on6tI+XnwTF1~^}wWK8!mkKSYpB_NJN}OZ)cR#X5F?>q09Emg2CB@Dxuo(Pr
z+fxyE|JgMZmO0hwS<V8=w{vja5`wze)+|e&cv$AMzhVvoa+NYP;2DLKUJ-*t&tk>q
z44`Hx@pVHN2C0=|$rckTSISWbjqh7yNhN@+sGIW8m{CPhoW!81QmFNmYO!~{*ygOR
z7T~Wi)bbA)MsXAs&pTd`#*)sa_qYoF)K_ilnsn9Ypu$}k6ngxg;Q&hs@^5q?-Af*-
z4%AVdUz0*R)7EOvdE=w4*y#75iuiXw05(VZ76Wm8s{1d2CE;|k?|T5zRGfE+Vpq5x
z+mBS<a;t#&N#if<{z+N$;<OveQfI$}i9zCOHG8R#gU{Wp&RKj{K&GayI!9G8%SB=5
zJBe2Trh%o}d!MBrJYN+OXN*dUb8~I+<BfnqNuBSSU#&<!kXR@|;(s91c&o~pae72t
zZP26VD33^Y&YqM5#*XdsibOo#^{IY_88sq?*FuF(OMYXCHK%pR#7=p|fzDdJ1S2Oa
z_?CCX22S4YfpZ(~N^`{lW=g1!4LW$eD%!7(r*51QVf7U>E^r5hFTUsCBMu~cR`eNl
znx*cuAY$2fuM?+%)J*f?*sDFOdD8UqMU0J7V)pL9)$8-`y&JS`*t=#c&KkA`W<3s1
zS{e`RZ`Sx%Xgf+rhxl|yDZ)m)loq95g0CX$k5ghR8VPlUdJ?vV0TRNJAXB2wnpeXD
zaC%jvP3!6Q(*M|Ypi<dL2CZPFElaw!1={^e8IF24QsQg@uXa6&YoJ&qz`z3=XZr1d
z?0ltC+2X)aER#1M_D})_JKZ-`ww*`#e+2Gg`!*wLS}(R3V%kXr7fS?@*Q!r!&6_$L
z9S*6LoMto^<>#%KK(PdwJyOT1${Z5wDLPeJD8dzFjz>kRqB)xi_L4N3a5)(3tOD7*
zM?A4AF}3rtc&q~N*{U%#0}ZC@r^uWG4w7Ut&2zd8QLD#3u%x?VzhQV*0Mv$1(w&w_
zO8!+u;OE~$#YPH|+I21nt0fm*n%J3|cNwf>syn0MfRhgxP-|F9GEv;VO8BG!U}lki
zY?Kg0*721<`MQ!%Y-q5~sfz7))y{T_Fm_bi<8VWQ6L(^@zr!Ub8lPK0;9gwTtycS|
z5@$e^95K8W$hMtkmtCPwz7)T{%A^8IIh!r?_Ve!7QCG$AI0vjU3;@h#LA%cy#z~s#
z0g_xwY`aOAV~J|E3U-Y<P^BrTFh#>o>}nOP*1^}Z=ievp*a|gnP-oML*aARmcIp;a
z+39RSwIck8bd(dfzz;yvz3ZtAGUH?kHXhZZTH+1(W#g{}p1seS&*sQQkiux22Xsxc
z$21cj60Tq?Zk54fZ~aI`wNl!Ar6(kYAam5-2#y%Ml<E>`fjxf!G+;WrP8-ykR;wc$
zI)l1eXk}-e4xlmA1hJ%-g$;{8>|l~~^bHf6LG76!1Y5<8i_@yed$6t0lZtOVl%tAx
z)omu3L@N8rPv>ACJamcWV5d1HY4F%uP^&Db!@82_m3qioU6YZb<vNUT5+5Zm!9P#b
zY#-20@K>H}i~Ua$OACA`>U0C~yb_qHRCiHV;Qc1JWWs!UX<1|+-+U=iz~bMT>R$9A
z_AQ0E3)JVVs(k&b)O@m^BODG{rhsZ@b$bEdMSM3YJA%Z?(6VPdD$VixilbLm^a4P>
zWc2D;ggll2E{NtJ#+IB0m<<}mz{;ZonbbPVN+NoNt!J;hXHWs5Dfx5Q&285i)schP
z&)pi;3Y)$(x>Xq9rxV;VkN_rof^$mpwLo{k?>gY$h?@q$sPZB|pVOIDlX5KwRb*-n
zf<;{=J2WTn(mH5P`|R8-0nB;LH&e**jw>CGG42S~spR=+<s--G0uJihb%5%R0f}A^
zMAWUOW6%ILD9xVg);S^Ic5J-B<<p!z0Ko~OR7JZ((3Tw#=lsfYQrS!)Nt*r85Ln8l
z-P7V-#<P)j^(uk^$W)0H`3Qt0by$S|dj!Y<xMtT_N%y^ST<H7x0)y_>z1#6*=^FT5
z#}zD%Ed@>AaTFRTa*Y&0`UiKntS+R*VFa102bTP;I}&7$QV5ptxzucuUmRk_Dp|r~
z03lQ4dS^r$0jh}O*H?+n46J_ZzA1M*un~<$eQ@ImD*`O35X1pk*EHXZi)<wT9dpfD
z9j}*eqxReutsm!8f1GE@$JKxR>h}C8WErdg4#szGvO+h)Cr)|;sGuu@S$g|<;EcX~
zE+t;GL}EDZAPa>PK=Gxy(up>^bp-npuw~^7>awE`u>E{Bnk3rKCm^ZjyaV9Rk>Nb{
z7GjOW>YOK?`hFh_AD~u3Q>^l9{uOUA6^VgG{D#Kn*#EZWrRML+V_3HuewDLJQs~47
z1S@I*$*-v7p6@tey8H}DPLs^Bv1PF>EdErMY}KWeu~3?UYJho!5Gy_)vgcDIC`el&
zX^I?*fvUr|kAaU{5(lDI%29`VVl$<EZewqlQ&&4pGp!hlS6-VEi6v74NZnX9-Tl;3
zdyH42fTxa`-sn%?fYntA^GtmOi$5TMaXi3ZLY3!aZ=Sxy7Jo(`L8`Qz!>4J1{TxSx
zI`VkJ^=w^Kr!*joqr?s#G7kGcBmz57n%xeX;dUT3;=hIU#EuhNHSEP12GKm_cb;4I
z7%OiFyAHsN2d*$CKByX0C3=yfSN7u$=4IukzBXmhEGu$2ac4hgki&a1R&_W@R3#<5
z=#OeuM8MYOC3T!U<)3ZAloqkZjoC3-s~KNrIS_jcsJP4~dt+f7mQp1OFyh|o)wRJH
z`}hQDHt>bA1fJc-mSG0W#S@a4L}Q-Pz*S?q*{%bkFv4@>#%l2Hwf{RxL`&#`3WZVC
z<L$5oWyOF<aiuhN(-<1)U-*?JuM!Vdu!3D@Fp;KNTM7%8A_GGYR5T4Z?T9n^M>;oA
z{n40m-JGhD>@oJef;`Sb93ko^+nGMT>Hu1+>j0tz?3J80XGHE#wu)m;^$Dw_aFj9Y
z%um^MzRb2n5hi8xYEwYK`S2=D*}JD$hL5>FRbM7uG?N{`pz&*}WM=Sc5gfK?WxGy}
zaXfQW98oz)7yyS7D5!zz;1P+IktzHWl+}K|z$kGfT2>b9{>noMN8r60qXB@OS#s2_
zbBZHL^1M<_S+n>wlvYs10y{FTrDNA=_Vb7fwp`RsI1X(czu&1?1YI6nxgZc_$;pQT
z_-x%Vc_Ox7WwYn<svvCtxxQH@0pzI$sb>1?t2&H;XY*F8BQqOM`I2M0GZ?V~XKHh*
z?Q{mZc3H*)gs4dI4y@|Bmo4c9)X1ruY1Am+w$Z3pDTTICX`v^@wKJZ2Vx&K-#I67y
z91au<w&!!^vrfGQrmF194Y9D1<huv3*HqQ55ZHHU2T*hPDr)(krJk!U68s@nvw$B5
zKeJtDQBHeFh~fb5cPSR*VF8|4_J-xlEwH)}K$GSa$)waKe;a+Yib&R_r>sPY$|~|V
zJLNX~56MNB3dUs>@)E|7%>t{aL)}axOb*5vQKh+`Q}<aY0pP<jsP1l`x)hWF0c9~!
z)0t^nqQI5G$w}LrJRGlP#{)>8syWe(2y|<EJODCwsh`qZP6-G6I7b0m!~^UQ0}Sm`
z;WrY*AtOK)13y3uE!fW|HaHfR#F^@SqhlTm058dYCs2Axo_IjKOKrbCu$@^3x$c5E
zi%6CmYL*de!U3i(vs`EluKCe~gGpc&(P2&{4Nk-3k(~}*u7HXxHqyW4i38y#-LRjJ
zbr*;Izh}tO-I1X*)-qz5s`^0MLE|;R1&H-h9gbhY@w?|e5^%eXB?0>b>{`Z{28F3g
zd9lW(WEa*W(4Jk#A=U<Y3{r0}h}4i^rLM$FjycJufHH(#;#l3|OG>R1Q7K$?9<gA1
zugDRi`5sT;YPK!I+c<BYl1>M&Wpk}{-%xHYE1AG{o~4#&3VMj>4S)xy%%_jDjBLb~
zt`$RxM?9RgeA37r6X!B)$1-6*!uM=5`^F?nRKu!Ia4XMP<<WODP*gMkjBkQ%uJNEu
zX@)CxNf+HQGEQG=Dp`G>8*zB&tv2nQW_#8mX-?^C)D2wxyibAry~Y#wrhT1+*086m
zH&TpCVv`6oPCAQ;EO+o5shg*X7kcbEU<B^G?g&KlBijTH=wV4pwtwv=y^z5H^rTUP
znrl`!kOL8pYRRYb7odXX&b<c&ur8qqo*|8s)$!s~Ap(d+ShB<^M+d{SpHqYnSju87
z$Y#2B9hxYm^1AbOtkKB0V-M0$XYRty)FN#dP%%}qdh3%WgWq=q>RuW(1L5wY*>%p?
z1-ryz3!<A_mK35@g?rs8iIsXIusEbZnMBZ>LnxJ=L7)bc>{i@n?%&Qns^v)M2Ap%>
z`8o%gPZ~;kFgGS&$B|iYv}6=}kfczX={C64>9#2ApsLVeUR<7Ut}Vb@BMty6O}=D@
z=9wB-iU5}9>FWTak)3|e7SSZi<a{JwzzLMNW6JaXaYcYej8`5bogKZ(VgcY|hv*=q
zbG6!I3RYTDV4M;Ad)Na6PY9zu4<f4Vt1L^E4hfKaf{ATBhQcmq1A77VGxVPsvM5RB
z>kywL7BcC>kTfHLjgOFQ?P=$ZC*O;+yn3l5W=hcAsZzD0*rWl8%T7v}ta3aeYHn$}
zmA#aluy?U7EU;i1(W33UCfh$WKLpmyyn=1a3?wHBbJ}jLuIyjEblbA|+H+%23pp4k
zt}kD;$hJ7Onl_K?3ru?EEiC(oO@`}Ra0YM~oK05nuhbQ=XLWFWxvzI1r*4^E=MJ7v
z*E>Cx+}++a!n|7BzEO{A8!C9u@`>Il5O!>O*FdV?4$wxMKV@hafJ9SE1DylAsw%l0
zc3c?PV~Jm_on-M*?G`}4EWPMidAwhNZ5$>}a>%WEtk0x(>ajk9-nGa2l;8@M0}dd8
z8~~dY^-d4gr@YA0!TNkeGEk^a2XUyk$!`Zh>j*%u%ZWA1Zs9e95=e~_@il4OfoiE#
z{`v0VfVC+g<O<YORDL}h%&<x|mJw4U2#dELrSJ-*)ilcv%o2wTt~o9vp(7lWXP=}X
zkCW#4JB{6)Jm^65(z9h?A?0LARtL_cDw_?QKIP*ST;S}NWss=UF`p;}RlH=gfH#Cw
z-{u`d;4rLacEjyzEx34fIFAJ6HYGDGc*c!zW*M_Ea8<Ppcr4YXj9IP`*I#-jKmf|}
ztxO$NBNy@F<nUb;2OdWcJgoE%<wFxHSvTNEcs}kW4e)$|-s!^gNqW}{&qs5mE8_V`
zh=o0MnvvzM8)^dpR>1SIid*kA1QEz_tG%{*H<?|pdRE|G&OpL9TGW!P5^x3%sS)G!
z50dI9E8LoQ-y;%O+ChK=>b9$Q8nHg#7zerIRJ;1Z`qUgS`*w?bjXF*scl53o)~7tX
zzWy*}?6Db+i0T~aUT=i@OT<R2COFWZA>fhR+-ws0?rkzxD-WN50JtAOogIO|=4GkY
zGOc|HIFxPs_l#l47V;=tO_pSvvF~ekO7@)$2E&*cGh+)`LY7GOeV1L9#*#HsArz7|
zOH#H7SySJr=Y8JidEWQ`9N+gpzB!H?*L`2-?>w*Hxm>3)?weQlEuZ}BwRD-9d+wH>
zB_apu6pT4#ocPNd2##3~Z7ES>^axJ=zMR*pEfwLk@#|5c!Iy0jN9^%<dd){~Kc2mn
z#HzU|u=S+BDW<4FQP)SlU*TSs41vEhcW|UTQZkmWw0rC+q?VT<nwX0CxRsrA>c>WX
z-%CSo^nPelJJ0UK(}SdB&sXLL4DWJ00|%aqmjx^q_Ixo3;ff0q_7i;#6Ym?U@f{Si
z3gwkp*?Qq5Nw07rDw<BjA(o!!x$Gs=+On&cJfb+oa)w^F4Eib=#Sefs%)whRb=6E?
z%l7*fcPhc{QRN@`@xCK~?ZJzS(lnW6J%ujGU$~O}peoxFI<sUuZQ!<%yI;#{8wNh}
z07vC&l!W{Hz)z>^-|-u~Po9w6d^>F?P?X1udB%3Z%cPdGq*A`h4I7-5#YEr;WVf?(
zld;)mzw`LzR%A_*oeS}$F#FYhW7-e5x5}@spXXoO3^ZHmT(o@89Io#uHKZ%t=f0S6
z$USEPz9eqH^oSnFvZL?mcIN@w%^=3ML@+sfIjJaFSMbhPym5t6&P4oW`d2S=^rDw@
zK+a>9p4PxFsk+kwG@Gbot=&Si*o)wm$}$S~y}?^B(@MFVN?whT5|nfAnX@;e+%Pd~
zYV6mXYUGA}{4f1RieNL9xz$pm32Y#!`#{1bXf<8J=Eir&nD9^4Zc4&YG4H&%DPGHa
z_$s;GP@o&qDl~}_Q?V0YeM5)5C6sk_JN820yX!;yjq}I4*xHcGWw*IRN_cbS?5$g8
z_Y-)0J5;$elcW1@UXt-!^h$R|G?w!MuOPO|h>*ePul&5W=F3xCll-+xRl0hta_VHf
zf^1_SN!l!OuWdYr2gV&f=cXXNORW5Td+*1Ot3b$o7l-+l-Z%Qjc@LK6*Bj<MTh61*
z+v+4Z8tz<w9C-UF6HEQ!u}%~yWl|5A4pcpF^jeUns84_~5QOv-21H*`+HPcwYvt4)
zlhxd9BdC8Ddm~^#76+lrK3xe*&OalbXh_D#T>J{fp)DVCg(c5oE!SH_gS@oJ?t^%Z
zz@&JRHPy#HvWskBRt^2u2w{y*Tza20z%u<leP8@6*v`QojFFuWXA6#kZt(wrx>=jj
zP%-lPPcW_Z25Z$BxVAOp??!q#EA)xisjb<lCR2r8uwKkH3qKrCP+CbATBeV%FMlT<
zka@`CrTSLl>5VaqYl`tBwOChRG+<bVKVG7&?-kRz+PeZo<=s;i7?z{hn_bjY!9~wI
zFY-1um^58#IJUq<=5kngm@pcu0JlZD`Qhx&(}j~>Vx}>pN73U_vW?XP359*rW%j`7
z<2rIY3#eFzhmx$;!)|3pf<H4(CGk`gI7Hy8X=UHI8aT~S<WgBsdyW5<;x^pwIi|~O
z=@guq&s9aTw#HgK;S@X}Dhw|#u{y_TAkSxf572v40e;#ada%dAV4tu?QEJIhynEL7
z>!tjMAHXBhvtK=_0KQXr`;Np^*H^lz`o@n-P?*z`381!KFi*9v9qPD3@qN>l8%91d
z{2}VGdt$zH9=!R9BIGsJd&++!r+YHR7P#DG`&;f^?Gn)0MJndK%X+;nDcYJGp2DDY
zX7wBm#cIzH>Y0US!t4M|alhQI2m!58O2cQ#-<x!8YF<9(eRJJ#50WR3Ma@k&wA=Lc
zDpyd)-5BG&FLI^1s@dt)J)T*GOV*1m+8Hxj0pefwjs1eY%GipMy%^)+fVuTN*-G-P
z0F7a%I?unMbSHKvWk^~`u%wz*7r!v}Odfm4S;x9~RJKSq1h-_HTSha(<||fJ)|0$w
z1s~-I8H!^UU<e<<b&m!{@1^|&XD82hW4;nv@ea9UAerFF5z@2Y#`a$zap8)`vu&im
zycCVe*vMB9?~!^yE|=H-=O0MjZmL}!UBLz(7{b?b(4qPZI()IbmT2;40vBGeeDXDw
zDCsUmL2@N3Ir(AW(~)_*9crS&@)p2leSh(Z5UUTGJDOg#6*#Mpv|6E>Ig^WTBIg~b
z3H|QqcUUKyIhCu2feqqb@Ko*BDQpdzny&qg*;X~B?FB5MEsUKAYR&*RRo&jXd8%tE
z<b^tOx7u~q`l-42{k?^hK`9VQL%WP{`ihwZB=kUbW;OhLW!LyO#vA@3c?(m{GDa;+
z@WJO}_&&V89>ajH8f8eYU-em8vJ!%psjSr1oz!WN=Z>An#ZFa?b-VFuDn_vfIWwN$
z4*iuVwRx<_%Igi+%8a>9M##STE2#*Wrmz(qn+$)?8EUrQ0^fX+Gp^+Fg~uf9TGRrE
zNUk8`6YNs2X>^VJLCKchuF+l8V-f6gOVf+Wm&x}ODfM~KUP1w!adm5@^%uj&{nO*<
z&=JzkPsxa3=TuN0e*Ecb{#FCzw>>=Fw*Bb|jVbLEGX~X957>H!t9f7Htb#2vR6CzY
z^Oy&z82LmQEjeRioj<d&M0{&E!qZ&7y5J4as6zk}09lE{3dcq2)wQ9>6!gaZ_B`Ec
zBaJ}aPSnxBGtKVA?==$W)v%cl8N5XXecSgaI<5oy%4N9c^!*M^r{fxV-lRWTHzA7$
zv16W<?0zXfoyWp4CM9;OM*9IO6l=I44A(xwZBoQI%0#KU3pG>D&1*au)8SA{V$t`2
z$!a3+o=J>6ureH@#G4B=u-Z*Ba|A_k=6p-(+>u91O$EGlQBJG8SW^--n!(7>m9%O1
zoY=UeRpXc5A=#Q5(SJ>RB35ox^N>E}$GIViOq@<#w3`IDCd^Im`3IT)A8=z84^jDG
z@HMs8h|yA=@pUzEGAgn{4{!5vQGwd@_W*j-lSl0>t#`q@uD-hIfQv_dN=?Luo1J1F
z3RxlZH1;uj&M)buPd8Nok8KkJ^f`QIu5KleInx?>6iqTCK*I56Vdp{msG`&51evg+
zvfz~MC-un`s<81h2}83IFyn`?LEb%PI{CP#PWBK`{HzCMbhn<jWdV2Ilx>866DyX$
zZ9q@S>ep~AY?g0s<|Mav%39&<OM+&Z^0VuMdNCYna-}^VZe}rV<)%|)sgZ%d)(C5@
zb7h;&7@=Zc>P{%WRi^_VK_ee3PCf~_PUboq45wQ!H&R=bsi8T7`e?<Q&1}n<gKnN}
zDdPZrbF^_g(0)T4X0hsG%0*=>=Dw~qq9cEY=lI_7c11;z(O;?OHv1It4*Rx63U!zJ
zfS|OOJrLmU-@!eMF{<YYe*e1TNd?;@R@slFTU-UPkD2vQe~BU6^FEH&co#&g@z6&T
zKsmm2|EAyp`b{u<y_QK#<81zga;r-+-tBkQXPe)<fhUz?nfU6TM2bwW=jF@3NZ^7M
z->L&&*>Eb?uYx$Gxt)3;%2|2w)VTobSJkZTt`4~ronJ%6l~@el(fe?OvcpX0SmeuC
zmpkS28}GHv-loW(h*nM4?X{m}lsTIha_N$Q3Gb=QiVgnv^a1_|X9o{A;X+-l#K`-k
zfBs3w)WfJ2`#$?!bPMDDYN@=P<mV`mTc3SAnEk~<3|L!U$wd<r7KuYBF9@uTG~BYN
zy=RUX6D{wnY&1NwEie-lKkc+34V=`?kh={$HaQ={t#7E=7BZrIrHw}FE=u!php7YU
z!QZ75ky1Gj2vJ>KE_0a{Ks$J;bSTl-RLd^lk;!6+(~m(v?dixfkq52Or{3M2EQQ{o
zxfLu8Wfc+)b-niiLNu}8ET&!_?=;IuB(nw{F{#Fhd+P2UO|gUe<7XvZ9zz=4YC#88
z`k^ZOCYF~MSr0D{4GHi8Zqc2#)AgA;9%2cMcf)v1T<1n)y#;uUypm{7c@bKOh2NKU
z+$ouP3pRGB(yRm=rl}I$Q!H9ri^RwT2Lr5?DYdUUTq%6zyKu^Y+}<8U`<Zq+yV7ve
zXjLL1txV}CVxOKX@V8}p6?>)&Y$mb>6eG1du5JvzzF`ll`n+y9o|AD>-SV4WKKIBU
zJu>e;;iD>4rdYvs_e_^{7mqY`GMj3iLpNi53v`W}sMm1iNT|?Dq;6h#!ppYefXE^A
zEjlq<j~gLrkLTor-t~=B4;+OOot0CZuTBf(DT&okFrBy7eViFfBj)z3f1qER_m1L|
zmi2=*TJNM$w{wRHk*{CeSWINvrhix$5Qs3<S1XKr_F}hEF1W{Ca#|+5L4k;ivMbPf
z3WG53R&FZBG24l|*1xs?dQAfEw>}cd(yf956W)oICwl_a`rf`aT>0c`Aql65*?&Yd
zHWhOLKC>nA2rEx#8L>gXmY)fBD>o1JXll2K2jW0in(KbEO1@IM8!*lJ;ao38+QT*u
z;0skjp%&+N^KOGZU#}(__;<($TOuRk+$J!axooY*&P$_8beiL~B@Fd1qvi8U8RZUn
zH@Nh;ZY*4XPDW<)isK9)yd+G9!vdS2@r)u;NB1h-#`t@Op_Sp^bP7BnWS!-wzukc{
z=7oGRQ%{+3BGmI-{Pfgo1$&N>#<AC`{Fbd=!z}@=!UE<p#xR6l0&F}hb@R;{O1*Bc
zpT|RNGiV}$ug9|0z@V+rU$bajmzkZJ=$>Pn^Pwj%da9a<Ssn6bjc=iG>R~vllCx;b
zU+)Szk!Ogi7RB2}*`VE<64uHw_!<?%9*&?T@`T*dQ}`HKS}W!e<X`)UXAr+aHeR<U
zADrYlckC(n8qoKpA^rs+B=znLr0FJIW(_Q7AnseENMv%AYID7Lx(vZv#iF?++$t&R
zE0E(sA7El3x7KQs!nwuynrN+i&JVC=CS-3V-%7l1!g}bP(pi^fBk&r%zUBnzG|$-#
z#O0kZS#O5DWa*ZOjtx_#dT|dGCEO9`Q?NSl$a-#CDT(#`lX_d-KG~hXx{hMb(Il=p
zhg_o(5pMPl=9d%BILS8sH*zInydG`$>U2U3eOc3*QCV%^2)@e`ielbi_!9@CB@RYA
z0ntn=<w+_Pi1Ip@=f~kBNeB4=&RuyExq0l|9w+xyXUR?OGn-Y%^xlFs6UJOw?+;q5
zTGDP2hX%fYYcbI{3~YBL)jA)k323r28fi2}4&QRAGv|(MzAa%|h7Ff9!|yhF_&2Co
zuoNr=j44EJl+d%<;L9)4WO2U;798KmvP>MAGgTkmWb=K9T7qV%0j-J`pYB;wy-)=i
zjN9zoCkm+w+;6)*D`}bZhL+;<RvqrpR$OLH_=r<M`3^gA7;b^85Rp7j-oP^?eJ3qx
zBPrBM_x-pe-*@&36;N~DdpYJVDrI3H#mD^AI%A5BFJz?>=aq*7vkN+xsb~#`ji25*
z1Gl86-PzFY8>Y+}&6sf&t|Q$Kk>10g@%_=XcL?R0PcXtWj^-RJjMq}LX{0uG&4+2q
z>oypy1-w9<orsI(Rizf;gb#&|tMc%w?YH*}E$*Zc9lN;MU6G7F@!6wlFbcsU6e!D%
z0<{m^s_V{=&z=50y;|}z`iRq*T7$~mm&^MaHiyi>EnT|94{FJ~u=Kh0IIcfm!PNd0
zE`?y)Qy5gvt2jyf+K2m^Z{O;R#jN2AI=b?C$5bFW3wI~WSt|#r4{sJSS<{OMvmfj5
z9y%+Tk00)p7g$ZKyNhdW&&@T==GPCm59RcLUiSraUcBh0UDMLpz+pW3zKg-IC*?t0
z9Fd!h2V?5bXNRU^`v$WR-D;wVy=k>8&->C$A~htI7FsY7Yru`o$fj9+mSjqFatSNH
zMVU9G7ZC)Qzd*FGx0C^}n}X#zHHxUnojPb4SPBX}!q8hz=2HTt+PmdB3_`D1_Kxhr
znXGmj^EebS{F1k3w#6`*afqX0k7~n}iRPM1!qb)1W@e@3Oh&f?X-ptl*?AWaHR#yr
zET#L1v?VJZ=T&bHZ-dP=h1^#t&&D#Nc0X=@pJAtStv=Sj$HABw+nw{0NcuR^{3!V-
zWqp#`yQnveLzB&b0O`>|llO=lg-PDjvWcU(R-Y<lM1{Zdx(}d0<?~LnQ_ii9kmCar
z|3=D%s0_a+mV07t;cd)tUDe`-e6#Kr<TCWe^GUZYJ8I$k!mMK}mS^q(<j-~*Mkj>H
zG&q_^uwFRz!lF1L$J3~+N&?eBw4g2dkx&^X7TR<nBORAGJtGix$HPBG1R3?6QPbCb
z;^mM|ICIh}zZ>X<@tyf2A&wM_OQc`i-<Wyes^l41=+gY(-aB5m3s0LFRH9#svN;=V
z$U%C0yBsCB9DTO6xQMWcZWOWv-#L>6s4U?+v~UPn_$J6IYE$gO5y<2rQ|NLu_0st>
z7d&K_DB<qxvcJrmHC&pD?l_~XB&#HtHg~6$^(eiwVOL(hHrBY8j^T63Gdlb8tzkl3
zT~k#?YJDnROwaSuV^S@ErAXyENdSFM?QAi5hd83EeZweSq;?kA`hd2j=b&%5s?_a0
zT(6{jTPUUc%3H<I2exN67@iuOx*7yZ$u)f@o3!wFl#O!=v5xmtG0s0enx3wi66T+u
z;Ga+z=ulN3I88Px#gAVoeQE?Va{emxhz<M>HEU#Ayzt3xcZ2?sbi)$elRHa8l@1Ts
z<KY-`*T<#-v;FnN;qML8P17lp7rVaMez@mC{V4}zRz`V+kDD$aTZ59U*D$xG0+EO{
zt0h_t2jzWo??AC1q(?+@uRlbI+MfyYK*iXyi|VqJVQG8B9s{oQ+Y+xs8fNlY3SX{0
z4^#=gZQnNu<ajLfCbcaAaM}#!S|a+uH?3RBtcjY-ns{|ND(QUk0^RfCv8fl2=myxR
z2cPCQY^IqTO$cgw#|nQ{^Hy;=D45Hyop?^hA6_R+6H?P&7kmw$TlSFCJBiyf#j^OE
zSL$P`sx08#Z%H;q7hdf(Cy5yR1~>x2^&mkmq((vkC`MnqHufpfp0%jfn4;f^{WL;5
zwkBX3yK?rcL|pr`&#LP{O9Iw~+7YQT4!15<_u`~T5%zDczo*)5j7MKO=K%zH!RQuQ
zg75IDJ^$c~@CoMBN^g3L6G>+|sGewFa<pEY8}hMUiZ!0+V+k<=yyr3q{Nz^*ko5FR
zhdy4bDbDT$@#=ig&lNDMv6}m~qNBeRH^XK0o4urO>7%wXz2(X)A>+X{D@8oP@d_Uv
zd}qC08V+V`vgsZ3s&w}20-Q;{#PFFcExf}>jcs4AUuc~st2$(Qx$Kj}o9e+{Bf6La
zb#@=Rn@65#gWWXKyNHPzIe@EwqQg0dDDAOMPxd<S!p*73Rkq1kgie9T@a~>2e}PY!
zMgL)FGk2?*Dfzfmo-TQb&FI<5&EU_*A2&H7YIO&?{5KP}Dc{cSZwVyJ(HBNRDno9M
zQIT%AZRAsCVLxbU`cPlXrsinvf^q{W(DU3i%2}@bv5?S0Mqh(yJLYexWs<8Nc4p@b
z0b|;BTj)bgJ?d<`1hLF(RL?a)-;sEww<<(fdw<%o*mZ&1eToW$-2LBb!sN5dWr^7?
zj0QDZTN2nz7L9sI@vhkIfaseK%sPO=99YXYy)lU~<ohj4*kV@^7OfuVw;y~49_Aan
z3Gbu`WsD&C&eB!KWvlW@JbwbdMtqvZB=;hX6T6e?nh=#U!pC`4mYYmt;)YC?n1-3K
z%(oH+T5G6KHv3!&V=#azkbkySQ>gZ=3#;%2PwZtHN*Vvj3ailgy5jDIZl9vkY_POq
z&h$c$cWpWO=ANZkiVOJdDFEnfN{eax&>E&G;o}A0sTAQ>dP*HH-J4B7S9?$^e%`{w
zeYI>VhAOEGTvyP2XrTIbiJw7c;Zbz6BX?JAIRS9qX9ejq{$R+V_|?2@uXi3tTxvS%
zlC)PnwQX)LsFI2z&E=86sR5+<eFKn=Pa7G4n;eld@@>C*@uiR5O!+ux8gmfZQ-~|6
z+!TXpC8Y1YW4WVDhIus5R=$Q25u#gr@5)>CsL3!Rs5^&BFu&B6QXRzDBj5vAY1Yuo
zkTf5EhFR^qKW7al-V(65o=ov7z>j$A8bd8_)ZFKf#&@HD+Q*j9vl4jyPv_D1@mYG2
zrwG@1Z(4;~Ia&AQvsZw3w-=)u_6;&y%qXf;3uH0`cj7YA-1^h^Q<>6`JSCPn;fm@m
z;1~>hV-*meWoVZoBpKkxE&m)jmN)-u{C!tYj)bc%mwWat))hOzY=*59yng1g?tNNp
zWw~5%abRvNC@wTf^OXqhK>df15~|g{g52}+M#;4v^SH25arh;2v4OhzC=R+F@nF3I
z){hEZIcI<`We5nNdp$RbJ2hEnCi*gio<=8L6yZGme*5M+vbFgX{au@Mc6<sRH6Sm9
zS}o)8&IXXn&Gri=NC}T_3_YBTERo@r69soxPl_>qbq+L*dXZwQ$GpQ{Z&kIV8!PtP
ztpEI7uNbyn%rcr7`F1pJF_oWfF^1O#tUp_&9|c~Zl|rvRHJ*N3&d%eZ_Zu*Gn(Un<
z$Ev4`B|aln>Y7;0`Ti=$u!>s7A5o1a>V5X6=hilMm{mjSt2dN7(nEg$4fH_d%m6X~
z72s}@se1p)I@uK<0FXll0I&i$01jSAloJdMCm_8MFf|<MsflV(EDnRkLki9TF6S`=
z{@W|r=!q^!l%b90dp8sF<n7GKn+!8EMvbM4mwT#nSe!Didhqmy@mTLnDeUWf4_$6B
zWwvI(Wk_!?wWS{T`d>eU>1xu{=;!J8dQM+tbd9k2RFX7$%bTEkIPu+1tYM$_r4~g2
z;dJKrL`0DND=061V}P|dZa~!(Y8Glqkl7Yh(~uQXDFEsvXO3OLO|BDe@`z{|if!dZ
zh@7$7@4Shqm7-(Fvso&=8(#wr8y*j>ebFiVXx13ozp-T}9hAj<+aW3ULPNt2@yz4c
zdH0^+?FS~k_nqsOM3|-0v;;d5lvSC%J;PT-&wduuo(g`rE(7gObg)|Ki=jwzkUT%S
zRzREJjka-74T`w`%A;8_<U6P1qX*Y}gHSU4y3Upl`yHHV55Am5X}o-xzhGZ)y|V}9
zxSqHLL#5t}o&I2hM^5maIEDHrwI@!Iio0rR4FUj84nvYtuy99rxC;V?N8r4XjtD%=
z13`d0!3l7fBL;^MKJgC%M?jJ;I3b*zWyGZ=9GykPBoJ^}Suwb*3|!J#L=+(*g>ZmF
zv3L(BN9;d2bEBn0LD|;>1@T7U@JI|=kxLXR!UaK)KEUIIM7t<*c@dn2Ww?};6i$>I
z{Gl5{l0oC;oE#OoTnPlM91Mo_!l9rToD0m!5r#k^JP>FC9wrJEg>n5cmw>=|;Qy<@
z&nth-^u;6pnC0W+1N9OA2`nZeA_}v(cGcL?72yFFMxyZqINA~MJN_RM_@9^YP!dgO
zl9kRFoClmh8j?)=7quiLssE8yE+qvgM>$6v0#3l-l#DPAB(@=D@Sb)!T7k5<Kdzk2
zazfx8aY!tI#GH~g9OvW%CwU0&=tv>}2PYt$AV?4FFD^(qhCxFx&JZ;tHDOYoK`yJo
zN%p&-F(@QI#0N=mh2XtNj)gdrPDAh*XTk{<X@o*KkOBfiS_VW-P!K|LzZ=4lv>u2$
z2F*u+IAYMwUU<YW1PqSkG&s)hcO}rD_Ws$%6PuAvB-bFFkqDg9uay5e>rZDDevbtu
zQYb(r6kz`vD!3#3d`K$rN{%>3AqeS<xY*Bcr1kth{B@c%KKbE~^$9_Kl^6xs9|$Lg
z5Re2ELg~Nq@%w6jTJ~$20*VB8jTDq5!=0}9Dd~G@AqYYcv){v33@QVa6cH7Zf=Y;p
z2tm}mPy{a=LJ^JdBH-XCA&7yO0}AP=hwwAOxFgVtXfG5>{u<H|hdE&yVva;RVSMlq
zeG`ZjR1_*LB_awj{*`_ZgA?{e<)Qi-CJ;>=+yg<Pz#T%O<!=Tl{7lb(XNb~Yv%L6A
z_kt9u?4BHFNLg;JhCvfZj<{jshehCRp(i=`4@LL?K2Lw*{Ytt2=ae7?(}_*OgcF-c
zd7zGPhLf0tX!w#&|0)kS1Padu`Q7*vU5Z?AESALW&j5#cqn-Yic*4IY9h4;ba}M4W
ziNy<&*2@Kf{Z|!eFFY3E_zy}jjsyhZf0B0n-wHZnvHx4qlbZZbto)<Fzl!ufsQw2|
z|F$Fi!7A)$6p%s?NG1&U_g14p+3B=O+W$`un*Z3_Z=CoRcH$@eFTsB|4hZwuxkZxD
zYtkM?_ZLACQau0OIsEe5-$hfRe$#zI5=|tDvj0WYnj8Q?AsznJe<0D0C@&`j>}OqZ
zgu4D6=t3XWOg$|Ca43D!y!`p)3H}QZ9_RQk5Ry;-4r8LKa-ZrB08n`m2)OiT6oAi}
z|A28ppnnx|VNz<GY&WFB`(H5s+E@J<bT$L<KX+NbO#8Qc{@Mxr8HSJr`2XJ*{9XND
jOVpp$Tji13lm9GO26_}E<^iPUk_vEx6bCZ}C!_xZ!<ncS

literal 0
HcmV?d00001

diff --git a/packages/Crc32C.1.0.4/Crc32C.1.0.4.nuspec b/packages/Crc32C.1.0.4/Crc32C.1.0.4.nuspec
new file mode 100644
index 0000000..c432219
--- /dev/null
+++ b/packages/Crc32C.1.0.4/Crc32C.1.0.4.nuspec
@@ -0,0 +1,18 @@
+<?xml version="1.0"?>
+<package xmlns="http://schemas.microsoft.com/packaging/2011/08/nuspec.xsd">
+  <metadata>
+    <id>Crc32C</id>
+    <version>1.0.4</version>
+    <title>CRC-32C (Castagnoli) for C++</title>
+    <authors>Robert Važan</authors>
+    <owners>Robert Važan</owners>
+    <licenseUrl>http://crc32c.angeloflogic.com/license/</licenseUrl>
+    <projectUrl>http://crc32c.angeloflogic.com/</projectUrl>
+    <iconUrl>http://crc32c.angeloflogic.com/images/nuget-icon.png</iconUrl>
+    <requireLicenseAcceptance>false</requireLicenseAcceptance>
+    <description>Hardware-accelerated implementation of CRC-32C (Castagnoli) with super fast software fallback for C++ projects. Don't confuse with ordinary CRC-32.</description>
+    <releaseNotes>Fixed missing constants.</releaseNotes>
+    <copyright>Copyright (c) 2013-2014 Mark Adler, Robert Važan</copyright>
+    <tags>crc crc32 crc-32 crc32c crc-32c castagnoli native</tags>
+  </metadata>
+</package>
\ No newline at end of file
diff --git a/packages/Crc32C.1.0.4/build/native/Crc32C.props b/packages/Crc32C.1.0.4/build/native/Crc32C.props
new file mode 100644
index 0000000..511959d
--- /dev/null
+++ b/packages/Crc32C.1.0.4/build/native/Crc32C.props
@@ -0,0 +1,14 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <PreprocessorDefinitions>CRC32C_STATIC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(MSBuildThisFileDirectory)..\..\lib\native\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\lib\native\src\crc32c.cpp">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/packages/Crc32C.1.0.4/lib/native/include/crc32c.h b/packages/Crc32C.1.0.4/lib/native/include/crc32c.h
new file mode 100644
index 0000000..c74bb46
--- /dev/null
+++ b/packages/Crc32C.1.0.4/lib/native/include/crc32c.h
@@ -0,0 +1,29 @@
+#ifndef CRC32C_H
+#define CRC32C_H
+
+#ifndef CRC32C_STATIC
+#ifdef CRC32C_EXPORTS
+#define CRC32C_API __declspec(dllexport)
+#else
+#define CRC32C_API __declspec(dllimport)
+#endif
+#else
+#define CRC32C_API
+#endif
+
+#include <stdint.h>
+
+/*
+    Computes CRC-32C (Castagnoli) checksum. Uses Intel's CRC32 instruction if it is available.
+    Otherwise it uses a very fast software fallback.
+*/
+extern "C" CRC32C_API uint32_t crc32c_append(
+    uint32_t crc,               // Initial CRC value. Typically it's 0.
+                                // You can supply non-trivial initial value here.
+                                // Initial value can be used to chain CRC from multiple buffers.
+    const uint8_t *input,       // Data to be put through the CRC algorithm.
+    size_t length);             // Length of the data in the input buffer.
+
+extern "C" CRC32C_API void crc32c_unittest();
+
+#endif
diff --git a/packages/Crc32C.1.0.4/lib/native/src/crc32c.cpp b/packages/Crc32C.1.0.4/lib/native/src/crc32c.cpp
new file mode 100644
index 0000000..d7401a1
--- /dev/null
+++ b/packages/Crc32C.1.0.4/lib/native/src/crc32c.cpp
@@ -0,0 +1,413 @@
+/*
+  Copyright (c) 2013 - 2014 Mark Adler, Robert Vazan
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the author be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+  claim that you wrote the original software. If you use this software
+  in a product, an acknowledgment in the product documentation would be
+  appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+  misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+#ifndef _CRT_SECURE_NO_WARNINGS
+#define _CRT_SECURE_NO_WARNINGS
+#endif
+
+#include "crc32c.h"
+
+#define NOMINMAX
+#include <windows.h>
+
+#include <nmmintrin.h>
+#include <stdio.h>
+
+#include <random>
+#include <algorithm>
+
+
+typedef const uint8_t *buffer;
+
+
+#include "generated-constants.cpp"
+
+
+static uint32_t append_trivial(uint32_t crc, buffer input, size_t length)
+{
+    for (size_t i = 0; i < length; ++i)
+    {
+        crc = crc ^ input[i];
+        for (int j = 0; j < 8; j++)
+            crc = (crc >> 1) ^ 0x80000000 ^ ((~crc & 1) * POLY);
+    }
+    return crc;
+}
+
+/* Table-driven software version as a fall-back.  This is about 15 times slower
+   than using the hardware instructions.  This assumes little-endian integers,
+   as is the case on Intel processors that the assembler code here is for. */
+static uint32_t append_adler_table(uint32_t crci, buffer input, size_t length)
+{
+    buffer next = input;
+    uint64_t crc;
+
+    crc = crci ^ 0xffffffff;
+    while (length && ((uintptr_t)next & 7) != 0)
+    {
+        crc = table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
+        --length;
+    }
+    while (length >= 8)
+    {
+        crc ^= *(uint64_t *)next;
+        crc = table[7][crc & 0xff]
+            ^ table[6][(crc >> 8) & 0xff]
+            ^ table[5][(crc >> 16) & 0xff]
+            ^ table[4][(crc >> 24) & 0xff]
+            ^ table[3][(crc >> 32) & 0xff]
+            ^ table[2][(crc >> 40) & 0xff]
+            ^ table[1][(crc >> 48) & 0xff]
+            ^ table[0][crc >> 56];
+        next += 8;
+        length -= 8;
+    }
+    while (length)
+    {
+        crc = table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
+        --length;
+    }
+    return (uint32_t)crc ^ 0xffffffff;
+}
+
+/* Table-driven software version as a fall-back.  This is about 15 times slower
+   than using the hardware instructions.  This assumes little-endian integers,
+   as is the case on Intel processors that the assembler code here is for. */
+static uint32_t append_table(uint32_t crci, buffer input, size_t length)
+{
+    buffer next = input;
+#ifdef _M_X64
+    uint64_t crc;
+#else
+    uint32_t crc;
+#endif
+
+    crc = crci ^ 0xffffffff;
+#ifdef _M_X64
+    while (length && ((uintptr_t)next & 7) != 0)
+    {
+        crc = table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
+        --length;
+    }
+    while (length >= 16)
+    {
+        crc ^= *(uint64_t *)next;
+        uint64_t high = *(uint64_t *)(next + 8);
+        crc = table[15][crc & 0xff]
+            ^ table[14][(crc >> 8) & 0xff]
+            ^ table[13][(crc >> 16) & 0xff]
+            ^ table[12][(crc >> 24) & 0xff]
+            ^ table[11][(crc >> 32) & 0xff]
+            ^ table[10][(crc >> 40) & 0xff]
+            ^ table[9][(crc >> 48) & 0xff]
+            ^ table[8][crc >> 56]
+            ^ table[7][high & 0xff]
+            ^ table[6][(high >> 8) & 0xff]
+            ^ table[5][(high >> 16) & 0xff]
+            ^ table[4][(high >> 24) & 0xff]
+            ^ table[3][(high >> 32) & 0xff]
+            ^ table[2][(high >> 40) & 0xff]
+            ^ table[1][(high >> 48) & 0xff]
+            ^ table[0][high >> 56];
+        next += 16;
+        length -= 16;
+    }
+#else
+    while (length && ((uintptr_t)next & 3) != 0)
+    {
+        crc = table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
+        --length;
+    }
+    while (length >= 12)
+    {
+        crc ^= *(uint32_t *)next;
+        uint32_t high = *(uint32_t *)(next + 4);
+        uint32_t high2 = *(uint32_t *)(next + 8);
+        crc = table[11][crc & 0xff]
+            ^ table[10][(crc >> 8) & 0xff]
+            ^ table[9][(crc >> 16) & 0xff]
+            ^ table[8][crc >> 24]
+            ^ table[7][high & 0xff]
+            ^ table[6][(high >> 8) & 0xff]
+            ^ table[5][(high >> 16) & 0xff]
+            ^ table[4][high >> 24]
+            ^ table[3][high2 & 0xff]
+            ^ table[2][(high2 >> 8) & 0xff]
+            ^ table[1][(high2 >> 16) & 0xff]
+            ^ table[0][high2 >> 24];
+        next += 12;
+        length -= 12;
+    }
+#endif
+    while (length)
+    {
+        crc = table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
+        --length;
+    }
+    return (uint32_t)crc ^ 0xffffffff;
+}
+
+/* Apply the zeros operator table to crc. */
+static inline uint32_t shift_crc(uint32_t shift_table[][256], uint32_t crc)
+{
+    return shift_table[0][crc & 0xff]
+        ^ shift_table[1][(crc >> 8) & 0xff]
+        ^ shift_table[2][(crc >> 16) & 0xff]
+        ^ shift_table[3][crc >> 24];
+}
+
+/* Compute CRC-32C using the Intel hardware instruction. */
+static uint32_t append_hw(uint32_t crc, buffer buf, size_t len)
+{
+    buffer next = buf;
+    buffer end;
+#ifdef _M_X64
+    uint64_t crc0, crc1, crc2;      /* need to be 64 bits for crc32q */
+#else
+    uint32_t crc0, crc1, crc2;
+#endif
+
+    /* pre-process the crc */
+    crc0 = crc ^ 0xffffffff;
+
+    /* compute the crc for up to seven leading bytes to bring the data pointer
+       to an eight-byte boundary */
+    while (len && ((uintptr_t)next & 7) != 0)
+    {
+        crc0 = _mm_crc32_u8(static_cast<uint32_t>(crc0), *next);
+        ++next;
+        --len;
+    }
+
+#ifdef _M_X64
+    /* compute the crc on sets of LONG_SHIFT*3 bytes, executing three independent crc
+       instructions, each on LONG_SHIFT bytes -- this is optimized for the Nehalem,
+       Westmere, Sandy Bridge, and Ivy Bridge architectures, which have a
+       throughput of one crc per cycle, but a latency of three cycles */
+    while (len >= 3 * LONG_SHIFT)
+    {
+        crc1 = 0;
+        crc2 = 0;
+        end = next + LONG_SHIFT;
+        do
+        {
+            crc0 = _mm_crc32_u64(crc0, *reinterpret_cast<const uint64_t *>(next));
+            crc1 = _mm_crc32_u64(crc1, *reinterpret_cast<const uint64_t *>(next + LONG_SHIFT));
+            crc2 = _mm_crc32_u64(crc2, *reinterpret_cast<const uint64_t *>(next + 2 * LONG_SHIFT));
+            next += 8;
+        } while (next < end);
+        crc0 = shift_crc(long_shifts, static_cast<uint32_t>(crc0)) ^ crc1;
+        crc0 = shift_crc(long_shifts, static_cast<uint32_t>(crc0)) ^ crc2;
+        next += 2 * LONG_SHIFT;
+        len -= 3 * LONG_SHIFT;
+    }
+
+    /* do the same thing, but now on SHORT_SHIFT*3 blocks for the remaining data less
+       than a LONG_SHIFT*3 block */
+    while (len >= 3 * SHORT_SHIFT)
+    {
+        crc1 = 0;
+        crc2 = 0;
+        end = next + SHORT_SHIFT;
+        do
+        {
+            crc0 = _mm_crc32_u64(crc0, *reinterpret_cast<const uint64_t *>(next));
+            crc1 = _mm_crc32_u64(crc1, *reinterpret_cast<const uint64_t *>(next + SHORT_SHIFT));
+            crc2 = _mm_crc32_u64(crc2, *reinterpret_cast<const uint64_t *>(next + 2 * SHORT_SHIFT));
+            next += 8;
+        } while (next < end);
+        crc0 = shift_crc(short_shifts, static_cast<uint32_t>(crc0)) ^ crc1;
+        crc0 = shift_crc(short_shifts, static_cast<uint32_t>(crc0)) ^ crc2;
+        next += 2 * SHORT_SHIFT;
+        len -= 3 * SHORT_SHIFT;
+    }
+
+    /* compute the crc on the remaining eight-byte units less than a SHORT_SHIFT*3
+    block */
+    end = next + (len - (len & 7));
+    while (next < end)
+    {
+        crc0 = _mm_crc32_u64(crc0, *reinterpret_cast<const uint64_t *>(next));
+        next += 8;
+    }
+#else
+    /* compute the crc on sets of LONG_SHIFT*3 bytes, executing three independent crc
+    instructions, each on LONG_SHIFT bytes -- this is optimized for the Nehalem,
+    Westmere, Sandy Bridge, and Ivy Bridge architectures, which have a
+    throughput of one crc per cycle, but a latency of three cycles */
+    while (len >= 3 * LONG_SHIFT)
+    {
+        crc1 = 0;
+        crc2 = 0;
+        end = next + LONG_SHIFT;
+        do
+        {
+            crc0 = _mm_crc32_u32(crc0, *reinterpret_cast<const uint32_t *>(next));
+            crc1 = _mm_crc32_u32(crc1, *reinterpret_cast<const uint32_t *>(next + LONG_SHIFT));
+            crc2 = _mm_crc32_u32(crc2, *reinterpret_cast<const uint32_t *>(next + 2 * LONG_SHIFT));
+            next += 4;
+        } while (next < end);
+        crc0 = shift_crc(long_shifts, static_cast<uint32_t>(crc0)) ^ crc1;
+        crc0 = shift_crc(long_shifts, static_cast<uint32_t>(crc0)) ^ crc2;
+        next += 2 * LONG_SHIFT;
+        len -= 3 * LONG_SHIFT;
+    }
+
+    /* do the same thing, but now on SHORT_SHIFT*3 blocks for the remaining data less
+    than a LONG_SHIFT*3 block */
+    while (len >= 3 * SHORT_SHIFT)
+    {
+        crc1 = 0;
+        crc2 = 0;
+        end = next + SHORT_SHIFT;
+        do
+        {
+            crc0 = _mm_crc32_u32(crc0, *reinterpret_cast<const uint32_t *>(next));
+            crc1 = _mm_crc32_u32(crc1, *reinterpret_cast<const uint32_t *>(next + SHORT_SHIFT));
+            crc2 = _mm_crc32_u32(crc2, *reinterpret_cast<const uint32_t *>(next + 2 * SHORT_SHIFT));
+            next += 4;
+        } while (next < end);
+        crc0 = shift_crc(short_shifts, static_cast<uint32_t>(crc0)) ^ crc1;
+        crc0 = shift_crc(short_shifts, static_cast<uint32_t>(crc0)) ^ crc2;
+        next += 2 * SHORT_SHIFT;
+        len -= 3 * SHORT_SHIFT;
+    }
+
+    /* compute the crc on the remaining eight-byte units less than a SHORT_SHIFT*3
+    block */
+    end = next + (len - (len & 7));
+    while (next < end)
+    {
+        crc0 = _mm_crc32_u32(crc0, *reinterpret_cast<const uint32_t *>(next));
+        next += 4;
+    }
+#endif
+    len &= 7;
+
+    /* compute the crc for up to seven trailing bytes */
+    while (len)
+    {
+        crc0 = _mm_crc32_u8(static_cast<uint32_t>(crc0), *next);
+        ++next;
+        --len;
+    }
+
+    /* return a post-processed crc */
+    return static_cast<uint32_t>(crc0) ^ 0xffffffff;
+}
+
+static bool detect_hw()
+{
+    int info[4];
+    __cpuid(info, 1);
+    return (info[2] & (1 << 20)) != 0;
+}
+
+static bool hw_available = detect_hw();
+
+extern "C" CRC32C_API uint32_t crc32c_append(uint32_t crc, buffer input, size_t length)
+{
+    if (hw_available)
+        return append_hw(crc, input, length);
+    else
+        return append_table(crc, input, length);
+}
+
+#define TEST_BUFFER 65536
+#define TEST_SLICES 1000000
+
+static int benchmark(const char *name, uint32_t(*function)(uint32_t, buffer, size_t), buffer input, int *offsets, int *lengths, uint32_t *crcs)
+{
+    uint64_t startTime = GetTickCount64();
+    int slice = 0;
+    uint64_t totalBytes = 0;
+    bool first = true;
+    int iterations = 0;
+    uint32_t crc = 0;
+    while (GetTickCount64() - startTime < 1000)
+    {
+        crc = function(crc, input + offsets[slice], lengths[slice]);
+        totalBytes += lengths[slice];
+        if (first)
+            crcs[slice] = crc;
+        ++slice;
+        ++iterations;
+        if (slice == TEST_SLICES)
+        {
+            slice = 0;
+            first = false;
+        }
+    }
+    int time = static_cast<int>(GetTickCount64() - startTime);
+    double throughput = totalBytes * 1000.0 / time;
+    printf("%s: ", name);
+    if (throughput > 1024.0 * 1024.0 * 1024.0)
+        printf("%.1f GB/s\n", throughput / 1024 / 1024 / 1024);
+    else
+        printf("%.0f MB/s\n", throughput / 1024 / 1024);
+    return std::min(TEST_SLICES, iterations);
+}
+
+static void compare_crcs(const char *leftName, uint32_t *left, const char *rightName, uint32_t *right, int count)
+{
+    for (int i = 0; i < count; ++i)
+        if (left[i] != right[i])
+        {
+            printf("CRC mismatch between algorithms %s and %s at offset %d: %x vs %x\n", leftName, rightName, i, left[i], right[i]);
+            exit(1);
+        }
+}
+
+extern "C" CRC32C_API void crc32c_unittest()
+{
+	/*
+    std::random_device rd;
+    std::uniform_int_distribution<int> byteDist(0, 255);
+    uint8_t *input = new uint8_t[TEST_BUFFER];
+    for (int i = 0; i < TEST_BUFFER; ++i)
+        input[i] = byteDist(rd);
+    int *offsets = new int[TEST_SLICES];
+    int *lengths = new int[TEST_SLICES];
+    std::uniform_int_distribution<int> lengthDist(0, TEST_BUFFER);
+    for (int i = 0; i < TEST_SLICES; ++i)
+    {
+        lengths[i] = lengthDist(rd);
+        std::uniform_int_distribution<int> offsetDist(0, TEST_BUFFER - lengths[i]);
+        offsets[i] = offsetDist(rd);
+    }
+    uint32_t *crcsTrivial = new uint32_t[TEST_SLICES];
+    uint32_t *crcsAdlerTable = new uint32_t[TEST_SLICES];
+    uint32_t *crcsTable = new uint32_t[TEST_SLICES];
+    uint32_t *crcsHw = new uint32_t[TEST_SLICES];
+    int iterationsTrivial = benchmark("trivial", append_trivial, input, offsets, lengths, crcsTrivial);
+    int iterationsAdlerTable = benchmark("adler_table", append_adler_table, input, offsets, lengths, crcsAdlerTable);
+    compare_crcs("trivial", crcsTrivial, "adler_table", crcsAdlerTable, std::min(iterationsTrivial, iterationsAdlerTable));
+    int iterationsTable = benchmark("table", append_table, input, offsets, lengths, crcsTable);
+    compare_crcs("adler_table", crcsAdlerTable, "table", crcsTable, std::min(iterationsAdlerTable, iterationsTable));
+    if (hw_available)
+    {
+        int iterationsHw = benchmark("hw", append_hw, input, offsets, lengths, crcsHw);
+        compare_crcs("table", crcsTable, "hw", crcsHw, std::min(iterationsTable, iterationsHw));
+    }
+    else
+        printf("HW doesn't have crc instruction\n");
+    benchmark("auto", crc32c_append, input, offsets, lengths, crcsHw);
+	*/
+}
diff --git a/packages/Crc32C.1.0.4/lib/native/src/generated-constants.cpp b/packages/Crc32C.1.0.4/lib/native/src/generated-constants.cpp
new file mode 100644
index 0000000..048a144
--- /dev/null
+++ b/packages/Crc32C.1.0.4/lib/native/src/generated-constants.cpp
@@ -0,0 +1,39 @@
+#define POLY 0x82f63b78
+#define LONG_SHIFT 8192
+#define SHORT_SHIFT 256
+
+static uint32_t table[16][256] =
+{
+    { 0x00000000, 0xf26b8303, 0xe13b70f7, 0x1350f3f4, 0xc79a971f, 0x35f1141c, 0x26a1e7e8, 0xd4ca64eb, 0x8ad958cf, 0x78b2dbcc, 0x6be22838, 0x9989ab3b, 0x4d43cfd0, 0xbf284cd3, 0xac78bf27, 0x5e133c24, 0x105ec76f, 0xe235446c, 0xf165b798, 0x030e349b, 0xd7c45070, 0x25afd373, 0x36ff2087, 0xc494a384, 0x9a879fa0, 0x68ec1ca3, 0x7bbcef57, 0x89d76c54, 0x5d1d08bf, 0xaf768bbc, 0xbc267848, 0x4e4dfb4b, 0x20bd8ede, 0xd2d60ddd, 0xc186fe29, 0x33ed7d2a, 0xe72719c1, 0x154c9ac2, 0x061c6936, 0xf477ea35, 0xaa64d611, 0x580f5512, 0x4b5fa6e6, 0xb93425e5, 0x6dfe410e, 0x9f95c20d, 0x8cc531f9, 0x7eaeb2fa, 0x30e349b1, 0xc288cab2, 0xd1d83946, 0x23b3ba45, 0xf779deae, 0x05125dad, 0x1642ae59, 0xe4292d5a, 0xba3a117e, 0x4851927d, 0x5b016189, 0xa96ae28a, 0x7da08661, 0x8fcb0562, 0x9c9bf696, 0x6ef07595, 0x417b1dbc, 0xb3109ebf, 0xa0406d4b, 0x522bee48, 0x86e18aa3, 0x748a09a0, 0x67dafa54, 0x95b17957, 0xcba24573, 0x39c9c670, 0x2a993584, 0xd8f2b687, 0x0c38d26c, 0xfe53516f, 0xed03a29b, 0x1f682198, 0x5125dad3, 0xa34e59d0, 0xb01eaa24, 0x42752927, 0x96bf4dcc, 0x64d4cecf, 0x77843d3b, 0x85efbe38, 0xdbfc821c, 0x2997011f, 0x3ac7f2eb, 0xc8ac71e8, 0x1c661503, 0xee0d9600, 0xfd5d65f4, 0x0f36e6f7, 0x61c69362, 0x93ad1061, 0x80fde395, 0x72966096, 0xa65c047d, 0x5437877e, 0x4767748a, 0xb50cf789, 0xeb1fcbad, 0x197448ae, 0x0a24bb5a, 0xf84f3859, 0x2c855cb2, 0xdeeedfb1, 0xcdbe2c45, 0x3fd5af46, 0x7198540d, 0x83f3d70e, 0x90a324fa, 0x62c8a7f9, 0xb602c312, 0x44694011, 0x5739b3e5, 0xa55230e6, 0xfb410cc2, 0x092a8fc1, 0x1a7a7c35, 0xe811ff36, 0x3cdb9bdd, 0xceb018de, 0xdde0eb2a, 0x2f8b6829, 0x82f63b78, 0x709db87b, 0x63cd4b8f, 0x91a6c88c, 0x456cac67, 0xb7072f64, 0xa457dc90, 0x563c5f93, 0x082f63b7, 0xfa44e0b4, 0xe9141340, 0x1b7f9043, 0xcfb5f4a8, 0x3dde77ab, 0x2e8e845f, 0xdce5075c, 0x92a8fc17, 0x60c37f14, 0x73938ce0, 0x81f80fe3, 0x55326b08, 0xa759e80b, 0xb4091bff, 0x466298fc, 0x1871a4d8, 0xea1a27db, 0xf94ad42f, 0x0b21572c, 0xdfeb33c7, 0x2d80b0c4, 0x3ed04330, 0xccbbc033, 0xa24bb5a6, 0x502036a5, 0x4370c551, 0xb11b4652, 0x65d122b9, 0x97baa1ba, 0x84ea524e, 0x7681d14d, 0x2892ed69, 0xdaf96e6a, 0xc9a99d9e, 0x3bc21e9d, 0xef087a76, 0x1d63f975, 0x0e330a81, 0xfc588982, 0xb21572c9, 0x407ef1ca, 0x532e023e, 0xa145813d, 0x758fe5d6, 0x87e466d5, 0x94b49521, 0x66df1622, 0x38cc2a06, 0xcaa7a905, 0xd9f75af1, 0x2b9cd9f2, 0xff56bd19, 0x0d3d3e1a, 0x1e6dcdee, 0xec064eed, 0xc38d26c4, 0x31e6a5c7, 0x22b65633, 0xd0ddd530, 0x0417b1db, 0xf67c32d8, 0xe52cc12c, 0x1747422f, 0x49547e0b, 0xbb3ffd08, 0xa86f0efc, 0x5a048dff, 0x8ecee914, 0x7ca56a17, 0x6ff599e3, 0x9d9e1ae0, 0xd3d3e1ab, 0x21b862a8, 0x32e8915c, 0xc083125f, 0x144976b4, 0xe622f5b7, 0xf5720643, 0x07198540, 0x590ab964, 0xab613a67, 0xb831c993, 0x4a5a4a90, 0x9e902e7b, 0x6cfbad78, 0x7fab5e8c, 0x8dc0dd8f, 0xe330a81a, 0x115b2b19, 0x020bd8ed, 0xf0605bee, 0x24aa3f05, 0xd6c1bc06, 0xc5914ff2, 0x37faccf1, 0x69e9f0d5, 0x9b8273d6, 0x88d28022, 0x7ab90321, 0xae7367ca, 0x5c18e4c9, 0x4f48173d, 0xbd23943e, 0xf36e6f75, 0x0105ec76, 0x12551f82, 0xe03e9c81, 0x34f4f86a, 0xc69f7b69, 0xd5cf889d, 0x27a40b9e, 0x79b737ba, 0x8bdcb4b9, 0x988c474d, 0x6ae7c44e, 0xbe2da0a5, 0x4c4623a6, 0x5f16d052, 0xad7d5351 },
+    { 0x00000000, 0x13a29877, 0x274530ee, 0x34e7a899, 0x4e8a61dc, 0x5d28f9ab, 0x69cf5132, 0x7a6dc945, 0x9d14c3b8, 0x8eb65bcf, 0xba51f356, 0xa9f36b21, 0xd39ea264, 0xc03c3a13, 0xf4db928a, 0xe7790afd, 0x3fc5f181, 0x2c6769f6, 0x1880c16f, 0x0b225918, 0x714f905d, 0x62ed082a, 0x560aa0b3, 0x45a838c4, 0xa2d13239, 0xb173aa4e, 0x859402d7, 0x96369aa0, 0xec5b53e5, 0xfff9cb92, 0xcb1e630b, 0xd8bcfb7c, 0x7f8be302, 0x6c297b75, 0x58ced3ec, 0x4b6c4b9b, 0x310182de, 0x22a31aa9, 0x1644b230, 0x05e62a47, 0xe29f20ba, 0xf13db8cd, 0xc5da1054, 0xd6788823, 0xac154166, 0xbfb7d911, 0x8b507188, 0x98f2e9ff, 0x404e1283, 0x53ec8af4, 0x670b226d, 0x74a9ba1a, 0x0ec4735f, 0x1d66eb28, 0x298143b1, 0x3a23dbc6, 0xdd5ad13b, 0xcef8494c, 0xfa1fe1d5, 0xe9bd79a2, 0x93d0b0e7, 0x80722890, 0xb4958009, 0xa737187e, 0xff17c604, 0xecb55e73, 0xd852f6ea, 0xcbf06e9d, 0xb19da7d8, 0xa23f3faf, 0x96d89736, 0x857a0f41, 0x620305bc, 0x71a19dcb, 0x45463552, 0x56e4ad25, 0x2c896460, 0x3f2bfc17, 0x0bcc548e, 0x186eccf9, 0xc0d23785, 0xd370aff2, 0xe797076b, 0xf4359f1c, 0x8e585659, 0x9dface2e, 0xa91d66b7, 0xbabffec0, 0x5dc6f43d, 0x4e646c4a, 0x7a83c4d3, 0x69215ca4, 0x134c95e1, 0x00ee0d96, 0x3409a50f, 0x27ab3d78, 0x809c2506, 0x933ebd71, 0xa7d915e8, 0xb47b8d9f, 0xce1644da, 0xddb4dcad, 0xe9537434, 0xfaf1ec43, 0x1d88e6be, 0x0e2a7ec9, 0x3acdd650, 0x296f4e27, 0x53028762, 0x40a01f15, 0x7447b78c, 0x67e52ffb, 0xbf59d487, 0xacfb4cf0, 0x981ce469, 0x8bbe7c1e, 0xf1d3b55b, 0xe2712d2c, 0xd69685b5, 0xc5341dc2, 0x224d173f, 0x31ef8f48, 0x050827d1, 0x16aabfa6, 0x6cc776e3, 0x7f65ee94, 0x4b82460d, 0x5820de7a, 0xfbc3faf9, 0xe861628e, 0xdc86ca17, 0xcf245260, 0xb5499b25, 0xa6eb0352, 0x920cabcb, 0x81ae33bc, 0x66d73941, 0x7575a136, 0x419209af, 0x523091d8, 0x285d589d, 0x3bffc0ea, 0x0f186873, 0x1cbaf004, 0xc4060b78, 0xd7a4930f, 0xe3433b96, 0xf0e1a3e1, 0x8a8c6aa4, 0x992ef2d3, 0xadc95a4a, 0xbe6bc23d, 0x5912c8c0, 0x4ab050b7, 0x7e57f82e, 0x6df56059, 0x1798a91c, 0x043a316b, 0x30dd99f2, 0x237f0185, 0x844819fb, 0x97ea818c, 0xa30d2915, 0xb0afb162, 0xcac27827, 0xd960e050, 0xed8748c9, 0xfe25d0be, 0x195cda43, 0x0afe4234, 0x3e19eaad, 0x2dbb72da, 0x57d6bb9f, 0x447423e8, 0x70938b71, 0x63311306, 0xbb8de87a, 0xa82f700d, 0x9cc8d894, 0x8f6a40e3, 0xf50789a6, 0xe6a511d1, 0xd242b948, 0xc1e0213f, 0x26992bc2, 0x353bb3b5, 0x01dc1b2c, 0x127e835b, 0x68134a1e, 0x7bb1d269, 0x4f567af0, 0x5cf4e287, 0x04d43cfd, 0x1776a48a, 0x23910c13, 0x30339464, 0x4a5e5d21, 0x59fcc556, 0x6d1b6dcf, 0x7eb9f5b8, 0x99c0ff45, 0x8a626732, 0xbe85cfab, 0xad2757dc, 0xd74a9e99, 0xc4e806ee, 0xf00fae77, 0xe3ad3600, 0x3b11cd7c, 0x28b3550b, 0x1c54fd92, 0x0ff665e5, 0x759baca0, 0x663934d7, 0x52de9c4e, 0x417c0439, 0xa6050ec4, 0xb5a796b3, 0x81403e2a, 0x92e2a65d, 0xe88f6f18, 0xfb2df76f, 0xcfca5ff6, 0xdc68c781, 0x7b5fdfff, 0x68fd4788, 0x5c1aef11, 0x4fb87766, 0x35d5be23, 0x26772654, 0x12908ecd, 0x013216ba, 0xe64b1c47, 0xf5e98430, 0xc10e2ca9, 0xd2acb4de, 0xa8c17d9b, 0xbb63e5ec, 0x8f844d75, 0x9c26d502, 0x449a2e7e, 0x5738b609, 0x63df1e90, 0x707d86e7, 0x0a104fa2, 0x19b2d7d5, 0x2d557f4c, 0x3ef7e73b, 0xd98eedc6, 0xca2c75b1, 0xfecbdd28, 0xed69455f, 0x97048c1a, 0x84a6146d, 0xb041bcf4, 0xa3e32483 },
+    { 0x00000000, 0xa541927e, 0x4f6f520d, 0xea2ec073, 0x9edea41a, 0x3b9f3664, 0xd1b1f617, 0x74f06469, 0x38513ec5, 0x9d10acbb, 0x773e6cc8, 0xd27ffeb6, 0xa68f9adf, 0x03ce08a1, 0xe9e0c8d2, 0x4ca15aac, 0x70a27d8a, 0xd5e3eff4, 0x3fcd2f87, 0x9a8cbdf9, 0xee7cd990, 0x4b3d4bee, 0xa1138b9d, 0x045219e3, 0x48f3434f, 0xedb2d131, 0x079c1142, 0xa2dd833c, 0xd62de755, 0x736c752b, 0x9942b558, 0x3c032726, 0xe144fb14, 0x4405696a, 0xae2ba919, 0x0b6a3b67, 0x7f9a5f0e, 0xdadbcd70, 0x30f50d03, 0x95b49f7d, 0xd915c5d1, 0x7c5457af, 0x967a97dc, 0x333b05a2, 0x47cb61cb, 0xe28af3b5, 0x08a433c6, 0xade5a1b8, 0x91e6869e, 0x34a714e0, 0xde89d493, 0x7bc846ed, 0x0f382284, 0xaa79b0fa, 0x40577089, 0xe516e2f7, 0xa9b7b85b, 0x0cf62a25, 0xe6d8ea56, 0x43997828, 0x37691c41, 0x92288e3f, 0x78064e4c, 0xdd47dc32, 0xc76580d9, 0x622412a7, 0x880ad2d4, 0x2d4b40aa, 0x59bb24c3, 0xfcfab6bd, 0x16d476ce, 0xb395e4b0, 0xff34be1c, 0x5a752c62, 0xb05bec11, 0x151a7e6f, 0x61ea1a06, 0xc4ab8878, 0x2e85480b, 0x8bc4da75, 0xb7c7fd53, 0x12866f2d, 0xf8a8af5e, 0x5de93d20, 0x29195949, 0x8c58cb37, 0x66760b44, 0xc337993a, 0x8f96c396, 0x2ad751e8, 0xc0f9919b, 0x65b803e5, 0x1148678c, 0xb409f5f2, 0x5e273581, 0xfb66a7ff, 0x26217bcd, 0x8360e9b3, 0x694e29c0, 0xcc0fbbbe, 0xb8ffdfd7, 0x1dbe4da9, 0xf7908dda, 0x52d11fa4, 0x1e704508, 0xbb31d776, 0x511f1705, 0xf45e857b, 0x80aee112, 0x25ef736c, 0xcfc1b31f, 0x6a802161, 0x56830647, 0xf3c29439, 0x19ec544a, 0xbcadc634, 0xc85da25d, 0x6d1c3023, 0x8732f050, 0x2273622e, 0x6ed23882, 0xcb93aafc, 0x21bd6a8f, 0x84fcf8f1, 0xf00c9c98, 0x554d0ee6, 0xbf63ce95, 0x1a225ceb, 0x8b277743, 0x2e66e53d, 0xc448254e, 0x6109b730, 0x15f9d359, 0xb0b84127, 0x5a968154, 0xffd7132a, 0xb3764986, 0x1637dbf8, 0xfc191b8b, 0x595889f5, 0x2da8ed9c, 0x88e97fe2, 0x62c7bf91, 0xc7862def, 0xfb850ac9, 0x5ec498b7, 0xb4ea58c4, 0x11abcaba, 0x655baed3, 0xc01a3cad, 0x2a34fcde, 0x8f756ea0, 0xc3d4340c, 0x6695a672, 0x8cbb6601, 0x29faf47f, 0x5d0a9016, 0xf84b0268, 0x1265c21b, 0xb7245065, 0x6a638c57, 0xcf221e29, 0x250cde5a, 0x804d4c24, 0xf4bd284d, 0x51fcba33, 0xbbd27a40, 0x1e93e83e, 0x5232b292, 0xf77320ec, 0x1d5de09f, 0xb81c72e1, 0xccec1688, 0x69ad84f6, 0x83834485, 0x26c2d6fb, 0x1ac1f1dd, 0xbf8063a3, 0x55aea3d0, 0xf0ef31ae, 0x841f55c7, 0x215ec7b9, 0xcb7007ca, 0x6e3195b4, 0x2290cf18, 0x87d15d66, 0x6dff9d15, 0xc8be0f6b, 0xbc4e6b02, 0x190ff97c, 0xf321390f, 0x5660ab71, 0x4c42f79a, 0xe90365e4, 0x032da597, 0xa66c37e9, 0xd29c5380, 0x77ddc1fe, 0x9df3018d, 0x38b293f3, 0x7413c95f, 0xd1525b21, 0x3b7c9b52, 0x9e3d092c, 0xeacd6d45, 0x4f8cff3b, 0xa5a23f48, 0x00e3ad36, 0x3ce08a10, 0x99a1186e, 0x738fd81d, 0xd6ce4a63, 0xa23e2e0a, 0x077fbc74, 0xed517c07, 0x4810ee79, 0x04b1b4d5, 0xa1f026ab, 0x4bdee6d8, 0xee9f74a6, 0x9a6f10cf, 0x3f2e82b1, 0xd50042c2, 0x7041d0bc, 0xad060c8e, 0x08479ef0, 0xe2695e83, 0x4728ccfd, 0x33d8a894, 0x96993aea, 0x7cb7fa99, 0xd9f668e7, 0x9557324b, 0x3016a035, 0xda386046, 0x7f79f238, 0x0b899651, 0xaec8042f, 0x44e6c45c, 0xe1a75622, 0xdda47104, 0x78e5e37a, 0x92cb2309, 0x378ab177, 0x437ad51e, 0xe63b4760, 0x0c158713, 0xa954156d, 0xe5f54fc1, 0x40b4ddbf, 0xaa9a1dcc, 0x0fdb8fb2, 0x7b2bebdb, 0xde6a79a5, 0x3444b9d6, 0x91052ba8 },
+    { 0x00000000, 0xdd45aab8, 0xbf672381, 0x62228939, 0x7b2231f3, 0xa6679b4b, 0xc4451272, 0x1900b8ca, 0xf64463e6, 0x2b01c95e, 0x49234067, 0x9466eadf, 0x8d665215, 0x5023f8ad, 0x32017194, 0xef44db2c, 0xe964b13d, 0x34211b85, 0x560392bc, 0x8b463804, 0x924680ce, 0x4f032a76, 0x2d21a34f, 0xf06409f7, 0x1f20d2db, 0xc2657863, 0xa047f15a, 0x7d025be2, 0x6402e328, 0xb9474990, 0xdb65c0a9, 0x06206a11, 0xd725148b, 0x0a60be33, 0x6842370a, 0xb5079db2, 0xac072578, 0x71428fc0, 0x136006f9, 0xce25ac41, 0x2161776d, 0xfc24ddd5, 0x9e0654ec, 0x4343fe54, 0x5a43469e, 0x8706ec26, 0xe524651f, 0x3861cfa7, 0x3e41a5b6, 0xe3040f0e, 0x81268637, 0x5c632c8f, 0x45639445, 0x98263efd, 0xfa04b7c4, 0x27411d7c, 0xc805c650, 0x15406ce8, 0x7762e5d1, 0xaa274f69, 0xb327f7a3, 0x6e625d1b, 0x0c40d422, 0xd1057e9a, 0xaba65fe7, 0x76e3f55f, 0x14c17c66, 0xc984d6de, 0xd0846e14, 0x0dc1c4ac, 0x6fe34d95, 0xb2a6e72d, 0x5de23c01, 0x80a796b9, 0xe2851f80, 0x3fc0b538, 0x26c00df2, 0xfb85a74a, 0x99a72e73, 0x44e284cb, 0x42c2eeda, 0x9f874462, 0xfda5cd5b, 0x20e067e3, 0x39e0df29, 0xe4a57591, 0x8687fca8, 0x5bc25610, 0xb4868d3c, 0x69c32784, 0x0be1aebd, 0xd6a40405, 0xcfa4bccf, 0x12e11677, 0x70c39f4e, 0xad8635f6, 0x7c834b6c, 0xa1c6e1d4, 0xc3e468ed, 0x1ea1c255, 0x07a17a9f, 0xdae4d027, 0xb8c6591e, 0x6583f3a6, 0x8ac7288a, 0x57828232, 0x35a00b0b, 0xe8e5a1b3, 0xf1e51979, 0x2ca0b3c1, 0x4e823af8, 0x93c79040, 0x95e7fa51, 0x48a250e9, 0x2a80d9d0, 0xf7c57368, 0xeec5cba2, 0x3380611a, 0x51a2e823, 0x8ce7429b, 0x63a399b7, 0xbee6330f, 0xdcc4ba36, 0x0181108e, 0x1881a844, 0xc5c402fc, 0xa7e68bc5, 0x7aa3217d, 0x52a0c93f, 0x8fe56387, 0xedc7eabe, 0x30824006, 0x2982f8cc, 0xf4c75274, 0x96e5db4d, 0x4ba071f5, 0xa4e4aad9, 0x79a10061, 0x1b838958, 0xc6c623e0, 0xdfc69b2a, 0x02833192, 0x60a1b8ab, 0xbde41213, 0xbbc47802, 0x6681d2ba, 0x04a35b83, 0xd9e6f13b, 0xc0e649f1, 0x1da3e349, 0x7f816a70, 0xa2c4c0c8, 0x4d801be4, 0x90c5b15c, 0xf2e73865, 0x2fa292dd, 0x36a22a17, 0xebe780af, 0x89c50996, 0x5480a32e, 0x8585ddb4, 0x58c0770c, 0x3ae2fe35, 0xe7a7548d, 0xfea7ec47, 0x23e246ff, 0x41c0cfc6, 0x9c85657e, 0x73c1be52, 0xae8414ea, 0xcca69dd3, 0x11e3376b, 0x08e38fa1, 0xd5a62519, 0xb784ac20, 0x6ac10698, 0x6ce16c89, 0xb1a4c631, 0xd3864f08, 0x0ec3e5b0, 0x17c35d7a, 0xca86f7c2, 0xa8a47efb, 0x75e1d443, 0x9aa50f6f, 0x47e0a5d7, 0x25c22cee, 0xf8878656, 0xe1873e9c, 0x3cc29424, 0x5ee01d1d, 0x83a5b7a5, 0xf90696d8, 0x24433c60, 0x4661b559, 0x9b241fe1, 0x8224a72b, 0x5f610d93, 0x3d4384aa, 0xe0062e12, 0x0f42f53e, 0xd2075f86, 0xb025d6bf, 0x6d607c07, 0x7460c4cd, 0xa9256e75, 0xcb07e74c, 0x16424df4, 0x106227e5, 0xcd278d5d, 0xaf050464, 0x7240aedc, 0x6b401616, 0xb605bcae, 0xd4273597, 0x09629f2f, 0xe6264403, 0x3b63eebb, 0x59416782, 0x8404cd3a, 0x9d0475f0, 0x4041df48, 0x22635671, 0xff26fcc9, 0x2e238253, 0xf36628eb, 0x9144a1d2, 0x4c010b6a, 0x5501b3a0, 0x88441918, 0xea669021, 0x37233a99, 0xd867e1b5, 0x05224b0d, 0x6700c234, 0xba45688c, 0xa345d046, 0x7e007afe, 0x1c22f3c7, 0xc167597f, 0xc747336e, 0x1a0299d6, 0x782010ef, 0xa565ba57, 0xbc65029d, 0x6120a825, 0x0302211c, 0xde478ba4, 0x31035088, 0xec46fa30, 0x8e647309, 0x5321d9b1, 0x4a21617b, 0x9764cbc3, 0xf54642fa, 0x2803e842 },
+    { 0x00000000, 0x38116fac, 0x7022df58, 0x4833b0f4, 0xe045beb0, 0xd854d11c, 0x906761e8, 0xa8760e44, 0xc5670b91, 0xfd76643d, 0xb545d4c9, 0x8d54bb65, 0x2522b521, 0x1d33da8d, 0x55006a79, 0x6d1105d5, 0x8f2261d3, 0xb7330e7f, 0xff00be8b, 0xc711d127, 0x6f67df63, 0x5776b0cf, 0x1f45003b, 0x27546f97, 0x4a456a42, 0x725405ee, 0x3a67b51a, 0x0276dab6, 0xaa00d4f2, 0x9211bb5e, 0xda220baa, 0xe2336406, 0x1ba8b557, 0x23b9dafb, 0x6b8a6a0f, 0x539b05a3, 0xfbed0be7, 0xc3fc644b, 0x8bcfd4bf, 0xb3debb13, 0xdecfbec6, 0xe6ded16a, 0xaeed619e, 0x96fc0e32, 0x3e8a0076, 0x069b6fda, 0x4ea8df2e, 0x76b9b082, 0x948ad484, 0xac9bbb28, 0xe4a80bdc, 0xdcb96470, 0x74cf6a34, 0x4cde0598, 0x04edb56c, 0x3cfcdac0, 0x51eddf15, 0x69fcb0b9, 0x21cf004d, 0x19de6fe1, 0xb1a861a5, 0x89b90e09, 0xc18abefd, 0xf99bd151, 0x37516aae, 0x0f400502, 0x4773b5f6, 0x7f62da5a, 0xd714d41e, 0xef05bbb2, 0xa7360b46, 0x9f2764ea, 0xf236613f, 0xca270e93, 0x8214be67, 0xba05d1cb, 0x1273df8f, 0x2a62b023, 0x625100d7, 0x5a406f7b, 0xb8730b7d, 0x806264d1, 0xc851d425, 0xf040bb89, 0x5836b5cd, 0x6027da61, 0x28146a95, 0x10050539, 0x7d1400ec, 0x45056f40, 0x0d36dfb4, 0x3527b018, 0x9d51be5c, 0xa540d1f0, 0xed736104, 0xd5620ea8, 0x2cf9dff9, 0x14e8b055, 0x5cdb00a1, 0x64ca6f0d, 0xccbc6149, 0xf4ad0ee5, 0xbc9ebe11, 0x848fd1bd, 0xe99ed468, 0xd18fbbc4, 0x99bc0b30, 0xa1ad649c, 0x09db6ad8, 0x31ca0574, 0x79f9b580, 0x41e8da2c, 0xa3dbbe2a, 0x9bcad186, 0xd3f96172, 0xebe80ede, 0x439e009a, 0x7b8f6f36, 0x33bcdfc2, 0x0badb06e, 0x66bcb5bb, 0x5eadda17, 0x169e6ae3, 0x2e8f054f, 0x86f90b0b, 0xbee864a7, 0xf6dbd453, 0xcecabbff, 0x6ea2d55c, 0x56b3baf0, 0x1e800a04, 0x269165a8, 0x8ee76bec, 0xb6f60440, 0xfec5b4b4, 0xc6d4db18, 0xabc5decd, 0x93d4b161, 0xdbe70195, 0xe3f66e39, 0x4b80607d, 0x73910fd1, 0x3ba2bf25, 0x03b3d089, 0xe180b48f, 0xd991db23, 0x91a26bd7, 0xa9b3047b, 0x01c50a3f, 0x39d46593, 0x71e7d567, 0x49f6bacb, 0x24e7bf1e, 0x1cf6d0b2, 0x54c56046, 0x6cd40fea, 0xc4a201ae, 0xfcb36e02, 0xb480def6, 0x8c91b15a, 0x750a600b, 0x4d1b0fa7, 0x0528bf53, 0x3d39d0ff, 0x954fdebb, 0xad5eb117, 0xe56d01e3, 0xdd7c6e4f, 0xb06d6b9a, 0x887c0436, 0xc04fb4c2, 0xf85edb6e, 0x5028d52a, 0x6839ba86, 0x200a0a72, 0x181b65de, 0xfa2801d8, 0xc2396e74, 0x8a0ade80, 0xb21bb12c, 0x1a6dbf68, 0x227cd0c4, 0x6a4f6030, 0x525e0f9c, 0x3f4f0a49, 0x075e65e5, 0x4f6dd511, 0x777cbabd, 0xdf0ab4f9, 0xe71bdb55, 0xaf286ba1, 0x9739040d, 0x59f3bff2, 0x61e2d05e, 0x29d160aa, 0x11c00f06, 0xb9b60142, 0x81a76eee, 0xc994de1a, 0xf185b1b6, 0x9c94b463, 0xa485dbcf, 0xecb66b3b, 0xd4a70497, 0x7cd10ad3, 0x44c0657f, 0x0cf3d58b, 0x34e2ba27, 0xd6d1de21, 0xeec0b18d, 0xa6f30179, 0x9ee26ed5, 0x36946091, 0x0e850f3d, 0x46b6bfc9, 0x7ea7d065, 0x13b6d5b0, 0x2ba7ba1c, 0x63940ae8, 0x5b856544, 0xf3f36b00, 0xcbe204ac, 0x83d1b458, 0xbbc0dbf4, 0x425b0aa5, 0x7a4a6509, 0x3279d5fd, 0x0a68ba51, 0xa21eb415, 0x9a0fdbb9, 0xd23c6b4d, 0xea2d04e1, 0x873c0134, 0xbf2d6e98, 0xf71ede6c, 0xcf0fb1c0, 0x6779bf84, 0x5f68d028, 0x175b60dc, 0x2f4a0f70, 0xcd796b76, 0xf56804da, 0xbd5bb42e, 0x854adb82, 0x2d3cd5c6, 0x152dba6a, 0x5d1e0a9e, 0x650f6532, 0x081e60e7, 0x300f0f4b, 0x783cbfbf, 0x402dd013, 0xe85bde57, 0xd04ab1fb, 0x9879010f, 0xa0686ea3 },
+    { 0x00000000, 0xef306b19, 0xdb8ca0c3, 0x34bccbda, 0xb2f53777, 0x5dc55c6e, 0x697997b4, 0x8649fcad, 0x6006181f, 0x8f367306, 0xbb8ab8dc, 0x54bad3c5, 0xd2f32f68, 0x3dc34471, 0x097f8fab, 0xe64fe4b2, 0xc00c303e, 0x2f3c5b27, 0x1b8090fd, 0xf4b0fbe4, 0x72f90749, 0x9dc96c50, 0xa975a78a, 0x4645cc93, 0xa00a2821, 0x4f3a4338, 0x7b8688e2, 0x94b6e3fb, 0x12ff1f56, 0xfdcf744f, 0xc973bf95, 0x2643d48c, 0x85f4168d, 0x6ac47d94, 0x5e78b64e, 0xb148dd57, 0x370121fa, 0xd8314ae3, 0xec8d8139, 0x03bdea20, 0xe5f20e92, 0x0ac2658b, 0x3e7eae51, 0xd14ec548, 0x570739e5, 0xb83752fc, 0x8c8b9926, 0x63bbf23f, 0x45f826b3, 0xaac84daa, 0x9e748670, 0x7144ed69, 0xf70d11c4, 0x183d7add, 0x2c81b107, 0xc3b1da1e, 0x25fe3eac, 0xcace55b5, 0xfe729e6f, 0x1142f576, 0x970b09db, 0x783b62c2, 0x4c87a918, 0xa3b7c201, 0x0e045beb, 0xe13430f2, 0xd588fb28, 0x3ab89031, 0xbcf16c9c, 0x53c10785, 0x677dcc5f, 0x884da746, 0x6e0243f4, 0x813228ed, 0xb58ee337, 0x5abe882e, 0xdcf77483, 0x33c71f9a, 0x077bd440, 0xe84bbf59, 0xce086bd5, 0x213800cc, 0x1584cb16, 0xfab4a00f, 0x7cfd5ca2, 0x93cd37bb, 0xa771fc61, 0x48419778, 0xae0e73ca, 0x413e18d3, 0x7582d309, 0x9ab2b810, 0x1cfb44bd, 0xf3cb2fa4, 0xc777e47e, 0x28478f67, 0x8bf04d66, 0x64c0267f, 0x507ceda5, 0xbf4c86bc, 0x39057a11, 0xd6351108, 0xe289dad2, 0x0db9b1cb, 0xebf65579, 0x04c63e60, 0x307af5ba, 0xdf4a9ea3, 0x5903620e, 0xb6330917, 0x828fc2cd, 0x6dbfa9d4, 0x4bfc7d58, 0xa4cc1641, 0x9070dd9b, 0x7f40b682, 0xf9094a2f, 0x16392136, 0x2285eaec, 0xcdb581f5, 0x2bfa6547, 0xc4ca0e5e, 0xf076c584, 0x1f46ae9d, 0x990f5230, 0x763f3929, 0x4283f2f3, 0xadb399ea, 0x1c08b7d6, 0xf338dccf, 0xc7841715, 0x28b47c0c, 0xaefd80a1, 0x41cdebb8, 0x75712062, 0x9a414b7b, 0x7c0eafc9, 0x933ec4d0, 0xa7820f0a, 0x48b26413, 0xcefb98be, 0x21cbf3a7, 0x1577387d, 0xfa475364, 0xdc0487e8, 0x3334ecf1, 0x0788272b, 0xe8b84c32, 0x6ef1b09f, 0x81c1db86, 0xb57d105c, 0x5a4d7b45, 0xbc029ff7, 0x5332f4ee, 0x678e3f34, 0x88be542d, 0x0ef7a880, 0xe1c7c399, 0xd57b0843, 0x3a4b635a, 0x99fca15b, 0x76ccca42, 0x42700198, 0xad406a81, 0x2b09962c, 0xc439fd35, 0xf08536ef, 0x1fb55df6, 0xf9fab944, 0x16cad25d, 0x22761987, 0xcd46729e, 0x4b0f8e33, 0xa43fe52a, 0x90832ef0, 0x7fb345e9, 0x59f09165, 0xb6c0fa7c, 0x827c31a6, 0x6d4c5abf, 0xeb05a612, 0x0435cd0b, 0x308906d1, 0xdfb96dc8, 0x39f6897a, 0xd6c6e263, 0xe27a29b9, 0x0d4a42a0, 0x8b03be0d, 0x6433d514, 0x508f1ece, 0xbfbf75d7, 0x120cec3d, 0xfd3c8724, 0xc9804cfe, 0x26b027e7, 0xa0f9db4a, 0x4fc9b053, 0x7b757b89, 0x94451090, 0x720af422, 0x9d3a9f3b, 0xa98654e1, 0x46b63ff8, 0xc0ffc355, 0x2fcfa84c, 0x1b736396, 0xf443088f, 0xd200dc03, 0x3d30b71a, 0x098c7cc0, 0xe6bc17d9, 0x60f5eb74, 0x8fc5806d, 0xbb794bb7, 0x544920ae, 0xb206c41c, 0x5d36af05, 0x698a64df, 0x86ba0fc6, 0x00f3f36b, 0xefc39872, 0xdb7f53a8, 0x344f38b1, 0x97f8fab0, 0x78c891a9, 0x4c745a73, 0xa344316a, 0x250dcdc7, 0xca3da6de, 0xfe816d04, 0x11b1061d, 0xf7fee2af, 0x18ce89b6, 0x2c72426c, 0xc3422975, 0x450bd5d8, 0xaa3bbec1, 0x9e87751b, 0x71b71e02, 0x57f4ca8e, 0xb8c4a197, 0x8c786a4d, 0x63480154, 0xe501fdf9, 0x0a3196e0, 0x3e8d5d3a, 0xd1bd3623, 0x37f2d291, 0xd8c2b988, 0xec7e7252, 0x034e194b, 0x8507e5e6, 0x6a378eff, 0x5e8b4525, 0xb1bb2e3c },
+    { 0x00000000, 0x68032cc8, 0xd0065990, 0xb8057558, 0xa5e0c5d1, 0xcde3e919, 0x75e69c41, 0x1de5b089, 0x4e2dfd53, 0x262ed19b, 0x9e2ba4c3, 0xf628880b, 0xebcd3882, 0x83ce144a, 0x3bcb6112, 0x53c84dda, 0x9c5bfaa6, 0xf458d66e, 0x4c5da336, 0x245e8ffe, 0x39bb3f77, 0x51b813bf, 0xe9bd66e7, 0x81be4a2f, 0xd27607f5, 0xba752b3d, 0x02705e65, 0x6a7372ad, 0x7796c224, 0x1f95eeec, 0xa7909bb4, 0xcf93b77c, 0x3d5b83bd, 0x5558af75, 0xed5dda2d, 0x855ef6e5, 0x98bb466c, 0xf0b86aa4, 0x48bd1ffc, 0x20be3334, 0x73767eee, 0x1b755226, 0xa370277e, 0xcb730bb6, 0xd696bb3f, 0xbe9597f7, 0x0690e2af, 0x6e93ce67, 0xa100791b, 0xc90355d3, 0x7106208b, 0x19050c43, 0x04e0bcca, 0x6ce39002, 0xd4e6e55a, 0xbce5c992, 0xef2d8448, 0x872ea880, 0x3f2bddd8, 0x5728f110, 0x4acd4199, 0x22ce6d51, 0x9acb1809, 0xf2c834c1, 0x7ab7077a, 0x12b42bb2, 0xaab15eea, 0xc2b27222, 0xdf57c2ab, 0xb754ee63, 0x0f519b3b, 0x6752b7f3, 0x349afa29, 0x5c99d6e1, 0xe49ca3b9, 0x8c9f8f71, 0x917a3ff8, 0xf9791330, 0x417c6668, 0x297f4aa0, 0xe6ecfddc, 0x8eefd114, 0x36eaa44c, 0x5ee98884, 0x430c380d, 0x2b0f14c5, 0x930a619d, 0xfb094d55, 0xa8c1008f, 0xc0c22c47, 0x78c7591f, 0x10c475d7, 0x0d21c55e, 0x6522e996, 0xdd279cce, 0xb524b006, 0x47ec84c7, 0x2fefa80f, 0x97eadd57, 0xffe9f19f, 0xe20c4116, 0x8a0f6dde, 0x320a1886, 0x5a09344e, 0x09c17994, 0x61c2555c, 0xd9c72004, 0xb1c40ccc, 0xac21bc45, 0xc422908d, 0x7c27e5d5, 0x1424c91d, 0xdbb77e61, 0xb3b452a9, 0x0bb127f1, 0x63b20b39, 0x7e57bbb0, 0x16549778, 0xae51e220, 0xc652cee8, 0x959a8332, 0xfd99affa, 0x459cdaa2, 0x2d9ff66a, 0x307a46e3, 0x58796a2b, 0xe07c1f73, 0x887f33bb, 0xf56e0ef4, 0x9d6d223c, 0x25685764, 0x4d6b7bac, 0x508ecb25, 0x388de7ed, 0x808892b5, 0xe88bbe7d, 0xbb43f3a7, 0xd340df6f, 0x6b45aa37, 0x034686ff, 0x1ea33676, 0x76a01abe, 0xcea56fe6, 0xa6a6432e, 0x6935f452, 0x0136d89a, 0xb933adc2, 0xd130810a, 0xccd53183, 0xa4d61d4b, 0x1cd36813, 0x74d044db, 0x27180901, 0x4f1b25c9, 0xf71e5091, 0x9f1d7c59, 0x82f8ccd0, 0xeafbe018, 0x52fe9540, 0x3afdb988, 0xc8358d49, 0xa036a181, 0x1833d4d9, 0x7030f811, 0x6dd54898, 0x05d66450, 0xbdd31108, 0xd5d03dc0, 0x8618701a, 0xee1b5cd2, 0x561e298a, 0x3e1d0542, 0x23f8b5cb, 0x4bfb9903, 0xf3feec5b, 0x9bfdc093, 0x546e77ef, 0x3c6d5b27, 0x84682e7f, 0xec6b02b7, 0xf18eb23e, 0x998d9ef6, 0x2188ebae, 0x498bc766, 0x1a438abc, 0x7240a674, 0xca45d32c, 0xa246ffe4, 0xbfa34f6d, 0xd7a063a5, 0x6fa516fd, 0x07a63a35, 0x8fd9098e, 0xe7da2546, 0x5fdf501e, 0x37dc7cd6, 0x2a39cc5f, 0x423ae097, 0xfa3f95cf, 0x923cb907, 0xc1f4f4dd, 0xa9f7d815, 0x11f2ad4d, 0x79f18185, 0x6414310c, 0x0c171dc4, 0xb412689c, 0xdc114454, 0x1382f328, 0x7b81dfe0, 0xc384aab8, 0xab878670, 0xb66236f9, 0xde611a31, 0x66646f69, 0x0e6743a1, 0x5daf0e7b, 0x35ac22b3, 0x8da957eb, 0xe5aa7b23, 0xf84fcbaa, 0x904ce762, 0x2849923a, 0x404abef2, 0xb2828a33, 0xda81a6fb, 0x6284d3a3, 0x0a87ff6b, 0x17624fe2, 0x7f61632a, 0xc7641672, 0xaf673aba, 0xfcaf7760, 0x94ac5ba8, 0x2ca92ef0, 0x44aa0238, 0x594fb2b1, 0x314c9e79, 0x8949eb21, 0xe14ac7e9, 0x2ed97095, 0x46da5c5d, 0xfedf2905, 0x96dc05cd, 0x8b39b544, 0xe33a998c, 0x5b3fecd4, 0x333cc01c, 0x60f48dc6, 0x08f7a10e, 0xb0f2d456, 0xd8f1f89e, 0xc5144817, 0xad1764df, 0x15121187, 0x7d113d4f },
+    { 0x00000000, 0x493c7d27, 0x9278fa4e, 0xdb448769, 0x211d826d, 0x6821ff4a, 0xb3657823, 0xfa590504, 0x423b04da, 0x0b0779fd, 0xd043fe94, 0x997f83b3, 0x632686b7, 0x2a1afb90, 0xf15e7cf9, 0xb86201de, 0x847609b4, 0xcd4a7493, 0x160ef3fa, 0x5f328edd, 0xa56b8bd9, 0xec57f6fe, 0x37137197, 0x7e2f0cb0, 0xc64d0d6e, 0x8f717049, 0x5435f720, 0x1d098a07, 0xe7508f03, 0xae6cf224, 0x7528754d, 0x3c14086a, 0x0d006599, 0x443c18be, 0x9f789fd7, 0xd644e2f0, 0x2c1de7f4, 0x65219ad3, 0xbe651dba, 0xf759609d, 0x4f3b6143, 0x06071c64, 0xdd439b0d, 0x947fe62a, 0x6e26e32e, 0x271a9e09, 0xfc5e1960, 0xb5626447, 0x89766c2d, 0xc04a110a, 0x1b0e9663, 0x5232eb44, 0xa86bee40, 0xe1579367, 0x3a13140e, 0x732f6929, 0xcb4d68f7, 0x827115d0, 0x593592b9, 0x1009ef9e, 0xea50ea9a, 0xa36c97bd, 0x782810d4, 0x31146df3, 0x1a00cb32, 0x533cb615, 0x8878317c, 0xc1444c5b, 0x3b1d495f, 0x72213478, 0xa965b311, 0xe059ce36, 0x583bcfe8, 0x1107b2cf, 0xca4335a6, 0x837f4881, 0x79264d85, 0x301a30a2, 0xeb5eb7cb, 0xa262caec, 0x9e76c286, 0xd74abfa1, 0x0c0e38c8, 0x453245ef, 0xbf6b40eb, 0xf6573dcc, 0x2d13baa5, 0x642fc782, 0xdc4dc65c, 0x9571bb7b, 0x4e353c12, 0x07094135, 0xfd504431, 0xb46c3916, 0x6f28be7f, 0x2614c358, 0x1700aeab, 0x5e3cd38c, 0x857854e5, 0xcc4429c2, 0x361d2cc6, 0x7f2151e1, 0xa465d688, 0xed59abaf, 0x553baa71, 0x1c07d756, 0xc743503f, 0x8e7f2d18, 0x7426281c, 0x3d1a553b, 0xe65ed252, 0xaf62af75, 0x9376a71f, 0xda4ada38, 0x010e5d51, 0x48322076, 0xb26b2572, 0xfb575855, 0x2013df3c, 0x692fa21b, 0xd14da3c5, 0x9871dee2, 0x4335598b, 0x0a0924ac, 0xf05021a8, 0xb96c5c8f, 0x6228dbe6, 0x2b14a6c1, 0x34019664, 0x7d3deb43, 0xa6796c2a, 0xef45110d, 0x151c1409, 0x5c20692e, 0x8764ee47, 0xce589360, 0x763a92be, 0x3f06ef99, 0xe44268f0, 0xad7e15d7, 0x572710d3, 0x1e1b6df4, 0xc55fea9d, 0x8c6397ba, 0xb0779fd0, 0xf94be2f7, 0x220f659e, 0x6b3318b9, 0x916a1dbd, 0xd856609a, 0x0312e7f3, 0x4a2e9ad4, 0xf24c9b0a, 0xbb70e62d, 0x60346144, 0x29081c63, 0xd3511967, 0x9a6d6440, 0x4129e329, 0x08159e0e, 0x3901f3fd, 0x703d8eda, 0xab7909b3, 0xe2457494, 0x181c7190, 0x51200cb7, 0x8a648bde, 0xc358f6f9, 0x7b3af727, 0x32068a00, 0xe9420d69, 0xa07e704e, 0x5a27754a, 0x131b086d, 0xc85f8f04, 0x8163f223, 0xbd77fa49, 0xf44b876e, 0x2f0f0007, 0x66337d20, 0x9c6a7824, 0xd5560503, 0x0e12826a, 0x472eff4d, 0xff4cfe93, 0xb67083b4, 0x6d3404dd, 0x240879fa, 0xde517cfe, 0x976d01d9, 0x4c2986b0, 0x0515fb97, 0x2e015d56, 0x673d2071, 0xbc79a718, 0xf545da3f, 0x0f1cdf3b, 0x4620a21c, 0x9d642575, 0xd4585852, 0x6c3a598c, 0x250624ab, 0xfe42a3c2, 0xb77edee5, 0x4d27dbe1, 0x041ba6c6, 0xdf5f21af, 0x96635c88, 0xaa7754e2, 0xe34b29c5, 0x380faeac, 0x7133d38b, 0x8b6ad68f, 0xc256aba8, 0x19122cc1, 0x502e51e6, 0xe84c5038, 0xa1702d1f, 0x7a34aa76, 0x3308d751, 0xc951d255, 0x806daf72, 0x5b29281b, 0x1215553c, 0x230138cf, 0x6a3d45e8, 0xb179c281, 0xf845bfa6, 0x021cbaa2, 0x4b20c785, 0x906440ec, 0xd9583dcb, 0x613a3c15, 0x28064132, 0xf342c65b, 0xba7ebb7c, 0x4027be78, 0x091bc35f, 0xd25f4436, 0x9b633911, 0xa777317b, 0xee4b4c5c, 0x350fcb35, 0x7c33b612, 0x866ab316, 0xcf56ce31, 0x14124958, 0x5d2e347f, 0xe54c35a1, 0xac704886, 0x7734cfef, 0x3e08b2c8, 0xc451b7cc, 0x8d6dcaeb, 0x56294d82, 0x1f1530a5 },
+    { 0x00000000, 0xf43ed648, 0xed91da61, 0x19af0c29, 0xdecfc233, 0x2af1147b, 0x335e1852, 0xc760ce1a, 0xb873f297, 0x4c4d24df, 0x55e228f6, 0xa1dcfebe, 0x66bc30a4, 0x9282e6ec, 0x8b2deac5, 0x7f133c8d, 0x750b93df, 0x81354597, 0x989a49be, 0x6ca49ff6, 0xabc451ec, 0x5ffa87a4, 0x46558b8d, 0xb26b5dc5, 0xcd786148, 0x3946b700, 0x20e9bb29, 0xd4d76d61, 0x13b7a37b, 0xe7897533, 0xfe26791a, 0x0a18af52, 0xea1727be, 0x1e29f1f6, 0x0786fddf, 0xf3b82b97, 0x34d8e58d, 0xc0e633c5, 0xd9493fec, 0x2d77e9a4, 0x5264d529, 0xa65a0361, 0xbff50f48, 0x4bcbd900, 0x8cab171a, 0x7895c152, 0x613acd7b, 0x95041b33, 0x9f1cb461, 0x6b226229, 0x728d6e00, 0x86b3b848, 0x41d37652, 0xb5eda01a, 0xac42ac33, 0x587c7a7b, 0x276f46f6, 0xd35190be, 0xcafe9c97, 0x3ec04adf, 0xf9a084c5, 0x0d9e528d, 0x14315ea4, 0xe00f88ec, 0xd1c2398d, 0x25fcefc5, 0x3c53e3ec, 0xc86d35a4, 0x0f0dfbbe, 0xfb332df6, 0xe29c21df, 0x16a2f797, 0x69b1cb1a, 0x9d8f1d52, 0x8420117b, 0x701ec733, 0xb77e0929, 0x4340df61, 0x5aefd348, 0xaed10500, 0xa4c9aa52, 0x50f77c1a, 0x49587033, 0xbd66a67b, 0x7a066861, 0x8e38be29, 0x9797b200, 0x63a96448, 0x1cba58c5, 0xe8848e8d, 0xf12b82a4, 0x051554ec, 0xc2759af6, 0x364b4cbe, 0x2fe44097, 0xdbda96df, 0x3bd51e33, 0xcfebc87b, 0xd644c452, 0x227a121a, 0xe51adc00, 0x11240a48, 0x088b0661, 0xfcb5d029, 0x83a6eca4, 0x77983aec, 0x6e3736c5, 0x9a09e08d, 0x5d692e97, 0xa957f8df, 0xb0f8f4f6, 0x44c622be, 0x4ede8dec, 0xbae05ba4, 0xa34f578d, 0x577181c5, 0x90114fdf, 0x642f9997, 0x7d8095be, 0x89be43f6, 0xf6ad7f7b, 0x0293a933, 0x1b3ca51a, 0xef027352, 0x2862bd48, 0xdc5c6b00, 0xc5f36729, 0x31cdb161, 0xa66805eb, 0x5256d3a3, 0x4bf9df8a, 0xbfc709c2, 0x78a7c7d8, 0x8c991190, 0x95361db9, 0x6108cbf1, 0x1e1bf77c, 0xea252134, 0xf38a2d1d, 0x07b4fb55, 0xc0d4354f, 0x34eae307, 0x2d45ef2e, 0xd97b3966, 0xd3639634, 0x275d407c, 0x3ef24c55, 0xcacc9a1d, 0x0dac5407, 0xf992824f, 0xe03d8e66, 0x1403582e, 0x6b1064a3, 0x9f2eb2eb, 0x8681bec2, 0x72bf688a, 0xb5dfa690, 0x41e170d8, 0x584e7cf1, 0xac70aab9, 0x4c7f2255, 0xb841f41d, 0xa1eef834, 0x55d02e7c, 0x92b0e066, 0x668e362e, 0x7f213a07, 0x8b1fec4f, 0xf40cd0c2, 0x0032068a, 0x199d0aa3, 0xeda3dceb, 0x2ac312f1, 0xdefdc4b9, 0xc752c890, 0x336c1ed8, 0x3974b18a, 0xcd4a67c2, 0xd4e56beb, 0x20dbbda3, 0xe7bb73b9, 0x1385a5f1, 0x0a2aa9d8, 0xfe147f90, 0x8107431d, 0x75399555, 0x6c96997c, 0x98a84f34, 0x5fc8812e, 0xabf65766, 0xb2595b4f, 0x46678d07, 0x77aa3c66, 0x8394ea2e, 0x9a3be607, 0x6e05304f, 0xa965fe55, 0x5d5b281d, 0x44f42434, 0xb0caf27c, 0xcfd9cef1, 0x3be718b9, 0x22481490, 0xd676c2d8, 0x11160cc2, 0xe528da8a, 0xfc87d6a3, 0x08b900eb, 0x02a1afb9, 0xf69f79f1, 0xef3075d8, 0x1b0ea390, 0xdc6e6d8a, 0x2850bbc2, 0x31ffb7eb, 0xc5c161a3, 0xbad25d2e, 0x4eec8b66, 0x5743874f, 0xa37d5107, 0x641d9f1d, 0x90234955, 0x898c457c, 0x7db29334, 0x9dbd1bd8, 0x6983cd90, 0x702cc1b9, 0x841217f1, 0x4372d9eb, 0xb74c0fa3, 0xaee3038a, 0x5addd5c2, 0x25cee94f, 0xd1f03f07, 0xc85f332e, 0x3c61e566, 0xfb012b7c, 0x0f3ffd34, 0x1690f11d, 0xe2ae2755, 0xe8b68807, 0x1c885e4f, 0x05275266, 0xf119842e, 0x36794a34, 0xc2479c7c, 0xdbe89055, 0x2fd6461d, 0x50c57a90, 0xa4fbacd8, 0xbd54a0f1, 0x496a76b9, 0x8e0ab8a3, 0x7a346eeb, 0x639b62c2, 0x97a5b48a },
+    { 0x00000000, 0xcb567ba5, 0x934081bb, 0x5816fa1e, 0x236d7587, 0xe83b0e22, 0xb02df43c, 0x7b7b8f99, 0x46daeb0e, 0x8d8c90ab, 0xd59a6ab5, 0x1ecc1110, 0x65b79e89, 0xaee1e52c, 0xf6f71f32, 0x3da16497, 0x8db5d61c, 0x46e3adb9, 0x1ef557a7, 0xd5a32c02, 0xaed8a39b, 0x658ed83e, 0x3d982220, 0xf6ce5985, 0xcb6f3d12, 0x003946b7, 0x582fbca9, 0x9379c70c, 0xe8024895, 0x23543330, 0x7b42c92e, 0xb014b28b, 0x1e87dac9, 0xd5d1a16c, 0x8dc75b72, 0x469120d7, 0x3deaaf4e, 0xf6bcd4eb, 0xaeaa2ef5, 0x65fc5550, 0x585d31c7, 0x930b4a62, 0xcb1db07c, 0x004bcbd9, 0x7b304440, 0xb0663fe5, 0xe870c5fb, 0x2326be5e, 0x93320cd5, 0x58647770, 0x00728d6e, 0xcb24f6cb, 0xb05f7952, 0x7b0902f7, 0x231ff8e9, 0xe849834c, 0xd5e8e7db, 0x1ebe9c7e, 0x46a86660, 0x8dfe1dc5, 0xf685925c, 0x3dd3e9f9, 0x65c513e7, 0xae936842, 0x3d0fb592, 0xf659ce37, 0xae4f3429, 0x65194f8c, 0x1e62c015, 0xd534bbb0, 0x8d2241ae, 0x46743a0b, 0x7bd55e9c, 0xb0832539, 0xe895df27, 0x23c3a482, 0x58b82b1b, 0x93ee50be, 0xcbf8aaa0, 0x00aed105, 0xb0ba638e, 0x7bec182b, 0x23fae235, 0xe8ac9990, 0x93d71609, 0x58816dac, 0x009797b2, 0xcbc1ec17, 0xf6608880, 0x3d36f325, 0x6520093b, 0xae76729e, 0xd50dfd07, 0x1e5b86a2, 0x464d7cbc, 0x8d1b0719, 0x23886f5b, 0xe8de14fe, 0xb0c8eee0, 0x7b9e9545, 0x00e51adc, 0xcbb36179, 0x93a59b67, 0x58f3e0c2, 0x65528455, 0xae04fff0, 0xf61205ee, 0x3d447e4b, 0x463ff1d2, 0x8d698a77, 0xd57f7069, 0x1e290bcc, 0xae3db947, 0x656bc2e2, 0x3d7d38fc, 0xf62b4359, 0x8d50ccc0, 0x4606b765, 0x1e104d7b, 0xd54636de, 0xe8e75249, 0x23b129ec, 0x7ba7d3f2, 0xb0f1a857, 0xcb8a27ce, 0x00dc5c6b, 0x58caa675, 0x939cddd0, 0x7a1f6b24, 0xb1491081, 0xe95fea9f, 0x2209913a, 0x59721ea3, 0x92246506, 0xca329f18, 0x0164e4bd, 0x3cc5802a, 0xf793fb8f, 0xaf850191, 0x64d37a34, 0x1fa8f5ad, 0xd4fe8e08, 0x8ce87416, 0x47be0fb3, 0xf7aabd38, 0x3cfcc69d, 0x64ea3c83, 0xafbc4726, 0xd4c7c8bf, 0x1f91b31a, 0x47874904, 0x8cd132a1, 0xb1705636, 0x7a262d93, 0x2230d78d, 0xe966ac28, 0x921d23b1, 0x594b5814, 0x015da20a, 0xca0bd9af, 0x6498b1ed, 0xafceca48, 0xf7d83056, 0x3c8e4bf3, 0x47f5c46a, 0x8ca3bfcf, 0xd4b545d1, 0x1fe33e74, 0x22425ae3, 0xe9142146, 0xb102db58, 0x7a54a0fd, 0x012f2f64, 0xca7954c1, 0x926faedf, 0x5939d57a, 0xe92d67f1, 0x227b1c54, 0x7a6de64a, 0xb13b9def, 0xca401276, 0x011669d3, 0x590093cd, 0x9256e868, 0xaff78cff, 0x64a1f75a, 0x3cb70d44, 0xf7e176e1, 0x8c9af978, 0x47cc82dd, 0x1fda78c3, 0xd48c0366, 0x4710deb6, 0x8c46a513, 0xd4505f0d, 0x1f0624a8, 0x647dab31, 0xaf2bd094, 0xf73d2a8a, 0x3c6b512f, 0x01ca35b8, 0xca9c4e1d, 0x928ab403, 0x59dccfa6, 0x22a7403f, 0xe9f13b9a, 0xb1e7c184, 0x7ab1ba21, 0xcaa508aa, 0x01f3730f, 0x59e58911, 0x92b3f2b4, 0xe9c87d2d, 0x229e0688, 0x7a88fc96, 0xb1de8733, 0x8c7fe3a4, 0x47299801, 0x1f3f621f, 0xd46919ba, 0xaf129623, 0x6444ed86, 0x3c521798, 0xf7046c3d, 0x5997047f, 0x92c17fda, 0xcad785c4, 0x0181fe61, 0x7afa71f8, 0xb1ac0a5d, 0xe9baf043, 0x22ec8be6, 0x1f4def71, 0xd41b94d4, 0x8c0d6eca, 0x475b156f, 0x3c209af6, 0xf776e153, 0xaf601b4d, 0x643660e8, 0xd422d263, 0x1f74a9c6, 0x476253d8, 0x8c34287d, 0xf74fa7e4, 0x3c19dc41, 0x640f265f, 0xaf595dfa, 0x92f8396d, 0x59ae42c8, 0x01b8b8d6, 0xcaeec373, 0xb1954cea, 0x7ac3374f, 0x22d5cd51, 0xe983b6f4 },
+    { 0x00000000, 0x9771f7c1, 0x2b0f9973, 0xbc7e6eb2, 0x561f32e6, 0xc16ec527, 0x7d10ab95, 0xea615c54, 0xac3e65cc, 0x3b4f920d, 0x8731fcbf, 0x10400b7e, 0xfa21572a, 0x6d50a0eb, 0xd12ece59, 0x465f3998, 0x5d90bd69, 0xcae14aa8, 0x769f241a, 0xe1eed3db, 0x0b8f8f8f, 0x9cfe784e, 0x208016fc, 0xb7f1e13d, 0xf1aed8a5, 0x66df2f64, 0xdaa141d6, 0x4dd0b617, 0xa7b1ea43, 0x30c01d82, 0x8cbe7330, 0x1bcf84f1, 0xbb217ad2, 0x2c508d13, 0x902ee3a1, 0x075f1460, 0xed3e4834, 0x7a4fbff5, 0xc631d147, 0x51402686, 0x171f1f1e, 0x806ee8df, 0x3c10866d, 0xab6171ac, 0x41002df8, 0xd671da39, 0x6a0fb48b, 0xfd7e434a, 0xe6b1c7bb, 0x71c0307a, 0xcdbe5ec8, 0x5acfa909, 0xb0aef55d, 0x27df029c, 0x9ba16c2e, 0x0cd09bef, 0x4a8fa277, 0xddfe55b6, 0x61803b04, 0xf6f1ccc5, 0x1c909091, 0x8be16750, 0x379f09e2, 0xa0eefe23, 0x73ae8355, 0xe4df7494, 0x58a11a26, 0xcfd0ede7, 0x25b1b1b3, 0xb2c04672, 0x0ebe28c0, 0x99cfdf01, 0xdf90e699, 0x48e11158, 0xf49f7fea, 0x63ee882b, 0x898fd47f, 0x1efe23be, 0xa2804d0c, 0x35f1bacd, 0x2e3e3e3c, 0xb94fc9fd, 0x0531a74f, 0x9240508e, 0x78210cda, 0xef50fb1b, 0x532e95a9, 0xc45f6268, 0x82005bf0, 0x1571ac31, 0xa90fc283, 0x3e7e3542, 0xd41f6916, 0x436e9ed7, 0xff10f065, 0x686107a4, 0xc88ff987, 0x5ffe0e46, 0xe38060f4, 0x74f19735, 0x9e90cb61, 0x09e13ca0, 0xb59f5212, 0x22eea5d3, 0x64b19c4b, 0xf3c06b8a, 0x4fbe0538, 0xd8cff2f9, 0x32aeaead, 0xa5df596c, 0x19a137de, 0x8ed0c01f, 0x951f44ee, 0x026eb32f, 0xbe10dd9d, 0x29612a5c, 0xc3007608, 0x547181c9, 0xe80fef7b, 0x7f7e18ba, 0x39212122, 0xae50d6e3, 0x122eb851, 0x855f4f90, 0x6f3e13c4, 0xf84fe405, 0x44318ab7, 0xd3407d76, 0xe75d06aa, 0x702cf16b, 0xcc529fd9, 0x5b236818, 0xb142344c, 0x2633c38d, 0x9a4dad3f, 0x0d3c5afe, 0x4b636366, 0xdc1294a7, 0x606cfa15, 0xf71d0dd4, 0x1d7c5180, 0x8a0da641, 0x3673c8f3, 0xa1023f32, 0xbacdbbc3, 0x2dbc4c02, 0x91c222b0, 0x06b3d571, 0xecd28925, 0x7ba37ee4, 0xc7dd1056, 0x50ace797, 0x16f3de0f, 0x818229ce, 0x3dfc477c, 0xaa8db0bd, 0x40ecece9, 0xd79d1b28, 0x6be3759a, 0xfc92825b, 0x5c7c7c78, 0xcb0d8bb9, 0x7773e50b, 0xe00212ca, 0x0a634e9e, 0x9d12b95f, 0x216cd7ed, 0xb61d202c, 0xf04219b4, 0x6733ee75, 0xdb4d80c7, 0x4c3c7706, 0xa65d2b52, 0x312cdc93, 0x8d52b221, 0x1a2345e0, 0x01ecc111, 0x969d36d0, 0x2ae35862, 0xbd92afa3, 0x57f3f3f7, 0xc0820436, 0x7cfc6a84, 0xeb8d9d45, 0xadd2a4dd, 0x3aa3531c, 0x86dd3dae, 0x11acca6f, 0xfbcd963b, 0x6cbc61fa, 0xd0c20f48, 0x47b3f889, 0x94f385ff, 0x0382723e, 0xbffc1c8c, 0x288deb4d, 0xc2ecb719, 0x559d40d8, 0xe9e32e6a, 0x7e92d9ab, 0x38cde033, 0xafbc17f2, 0x13c27940, 0x84b38e81, 0x6ed2d2d5, 0xf9a32514, 0x45dd4ba6, 0xd2acbc67, 0xc9633896, 0x5e12cf57, 0xe26ca1e5, 0x751d5624, 0x9f7c0a70, 0x080dfdb1, 0xb4739303, 0x230264c2, 0x655d5d5a, 0xf22caa9b, 0x4e52c429, 0xd92333e8, 0x33426fbc, 0xa433987d, 0x184df6cf, 0x8f3c010e, 0x2fd2ff2d, 0xb8a308ec, 0x04dd665e, 0x93ac919f, 0x79cdcdcb, 0xeebc3a0a, 0x52c254b8, 0xc5b3a379, 0x83ec9ae1, 0x149d6d20, 0xa8e30392, 0x3f92f453, 0xd5f3a807, 0x42825fc6, 0xfefc3174, 0x698dc6b5, 0x72424244, 0xe533b585, 0x594ddb37, 0xce3c2cf6, 0x245d70a2, 0xb32c8763, 0x0f52e9d1, 0x98231e10, 0xde7c2788, 0x490dd049, 0xf573befb, 0x6202493a, 0x8863156e, 0x1f12e2af, 0xa36c8c1d, 0x341d7bdc },
+    { 0x00000000, 0x3171d430, 0x62e3a860, 0x53927c50, 0xc5c750c0, 0xf4b684f0, 0xa724f8a0, 0x96552c90, 0x8e62d771, 0xbf130341, 0xec817f11, 0xddf0ab21, 0x4ba587b1, 0x7ad45381, 0x29462fd1, 0x1837fbe1, 0x1929d813, 0x28580c23, 0x7bca7073, 0x4abba443, 0xdcee88d3, 0xed9f5ce3, 0xbe0d20b3, 0x8f7cf483, 0x974b0f62, 0xa63adb52, 0xf5a8a702, 0xc4d97332, 0x528c5fa2, 0x63fd8b92, 0x306ff7c2, 0x011e23f2, 0x3253b026, 0x03226416, 0x50b01846, 0x61c1cc76, 0xf794e0e6, 0xc6e534d6, 0x95774886, 0xa4069cb6, 0xbc316757, 0x8d40b367, 0xded2cf37, 0xefa31b07, 0x79f63797, 0x4887e3a7, 0x1b159ff7, 0x2a644bc7, 0x2b7a6835, 0x1a0bbc05, 0x4999c055, 0x78e81465, 0xeebd38f5, 0xdfccecc5, 0x8c5e9095, 0xbd2f44a5, 0xa518bf44, 0x94696b74, 0xc7fb1724, 0xf68ac314, 0x60dfef84, 0x51ae3bb4, 0x023c47e4, 0x334d93d4, 0x64a7604c, 0x55d6b47c, 0x0644c82c, 0x37351c1c, 0xa160308c, 0x9011e4bc, 0xc38398ec, 0xf2f24cdc, 0xeac5b73d, 0xdbb4630d, 0x88261f5d, 0xb957cb6d, 0x2f02e7fd, 0x1e7333cd, 0x4de14f9d, 0x7c909bad, 0x7d8eb85f, 0x4cff6c6f, 0x1f6d103f, 0x2e1cc40f, 0xb849e89f, 0x89383caf, 0xdaaa40ff, 0xebdb94cf, 0xf3ec6f2e, 0xc29dbb1e, 0x910fc74e, 0xa07e137e, 0x362b3fee, 0x075aebde, 0x54c8978e, 0x65b943be, 0x56f4d06a, 0x6785045a, 0x3417780a, 0x0566ac3a, 0x933380aa, 0xa242549a, 0xf1d028ca, 0xc0a1fcfa, 0xd896071b, 0xe9e7d32b, 0xba75af7b, 0x8b047b4b, 0x1d5157db, 0x2c2083eb, 0x7fb2ffbb, 0x4ec32b8b, 0x4fdd0879, 0x7eacdc49, 0x2d3ea019, 0x1c4f7429, 0x8a1a58b9, 0xbb6b8c89, 0xe8f9f0d9, 0xd98824e9, 0xc1bfdf08, 0xf0ce0b38, 0xa35c7768, 0x922da358, 0x04788fc8, 0x35095bf8, 0x669b27a8, 0x57eaf398, 0xc94ec098, 0xf83f14a8, 0xabad68f8, 0x9adcbcc8, 0x0c899058, 0x3df84468, 0x6e6a3838, 0x5f1bec08, 0x472c17e9, 0x765dc3d9, 0x25cfbf89, 0x14be6bb9, 0x82eb4729, 0xb39a9319, 0xe008ef49, 0xd1793b79, 0xd067188b, 0xe116ccbb, 0xb284b0eb, 0x83f564db, 0x15a0484b, 0x24d19c7b, 0x7743e02b, 0x4632341b, 0x5e05cffa, 0x6f741bca, 0x3ce6679a, 0x0d97b3aa, 0x9bc29f3a, 0xaab34b0a, 0xf921375a, 0xc850e36a, 0xfb1d70be, 0xca6ca48e, 0x99fed8de, 0xa88f0cee, 0x3eda207e, 0x0fabf44e, 0x5c39881e, 0x6d485c2e, 0x757fa7cf, 0x440e73ff, 0x179c0faf, 0x26eddb9f, 0xb0b8f70f, 0x81c9233f, 0xd25b5f6f, 0xe32a8b5f, 0xe234a8ad, 0xd3457c9d, 0x80d700cd, 0xb1a6d4fd, 0x27f3f86d, 0x16822c5d, 0x4510500d, 0x7461843d, 0x6c567fdc, 0x5d27abec, 0x0eb5d7bc, 0x3fc4038c, 0xa9912f1c, 0x98e0fb2c, 0xcb72877c, 0xfa03534c, 0xade9a0d4, 0x9c9874e4, 0xcf0a08b4, 0xfe7bdc84, 0x682ef014, 0x595f2424, 0x0acd5874, 0x3bbc8c44, 0x238b77a5, 0x12faa395, 0x4168dfc5, 0x70190bf5, 0xe64c2765, 0xd73df355, 0x84af8f05, 0xb5de5b35, 0xb4c078c7, 0x85b1acf7, 0xd623d0a7, 0xe7520497, 0x71072807, 0x4076fc37, 0x13e48067, 0x22955457, 0x3aa2afb6, 0x0bd37b86, 0x584107d6, 0x6930d3e6, 0xff65ff76, 0xce142b46, 0x9d865716, 0xacf78326, 0x9fba10f2, 0xaecbc4c2, 0xfd59b892, 0xcc286ca2, 0x5a7d4032, 0x6b0c9402, 0x389ee852, 0x09ef3c62, 0x11d8c783, 0x20a913b3, 0x733b6fe3, 0x424abbd3, 0xd41f9743, 0xe56e4373, 0xb6fc3f23, 0x878deb13, 0x8693c8e1, 0xb7e21cd1, 0xe4706081, 0xd501b4b1, 0x43549821, 0x72254c11, 0x21b73041, 0x10c6e471, 0x08f11f90, 0x3980cba0, 0x6a12b7f0, 0x5b6363c0, 0xcd364f50, 0xfc479b60, 0xafd5e730, 0x9ea43300 },
+    { 0x00000000, 0x30d23865, 0x61a470ca, 0x517648af, 0xc348e194, 0xf39ad9f1, 0xa2ec915e, 0x923ea93b, 0x837db5d9, 0xb3af8dbc, 0xe2d9c513, 0xd20bfd76, 0x4035544d, 0x70e76c28, 0x21912487, 0x11431ce2, 0x03171d43, 0x33c52526, 0x62b36d89, 0x526155ec, 0xc05ffcd7, 0xf08dc4b2, 0xa1fb8c1d, 0x9129b478, 0x806aa89a, 0xb0b890ff, 0xe1ced850, 0xd11ce035, 0x4322490e, 0x73f0716b, 0x228639c4, 0x125401a1, 0x062e3a86, 0x36fc02e3, 0x678a4a4c, 0x57587229, 0xc566db12, 0xf5b4e377, 0xa4c2abd8, 0x941093bd, 0x85538f5f, 0xb581b73a, 0xe4f7ff95, 0xd425c7f0, 0x461b6ecb, 0x76c956ae, 0x27bf1e01, 0x176d2664, 0x053927c5, 0x35eb1fa0, 0x649d570f, 0x544f6f6a, 0xc671c651, 0xf6a3fe34, 0xa7d5b69b, 0x97078efe, 0x8644921c, 0xb696aa79, 0xe7e0e2d6, 0xd732dab3, 0x450c7388, 0x75de4bed, 0x24a80342, 0x147a3b27, 0x0c5c750c, 0x3c8e4d69, 0x6df805c6, 0x5d2a3da3, 0xcf149498, 0xffc6acfd, 0xaeb0e452, 0x9e62dc37, 0x8f21c0d5, 0xbff3f8b0, 0xee85b01f, 0xde57887a, 0x4c692141, 0x7cbb1924, 0x2dcd518b, 0x1d1f69ee, 0x0f4b684f, 0x3f99502a, 0x6eef1885, 0x5e3d20e0, 0xcc0389db, 0xfcd1b1be, 0xada7f911, 0x9d75c174, 0x8c36dd96, 0xbce4e5f3, 0xed92ad5c, 0xdd409539, 0x4f7e3c02, 0x7fac0467, 0x2eda4cc8, 0x1e0874ad, 0x0a724f8a, 0x3aa077ef, 0x6bd63f40, 0x5b040725, 0xc93aae1e, 0xf9e8967b, 0xa89eded4, 0x984ce6b1, 0x890ffa53, 0xb9ddc236, 0xe8ab8a99, 0xd879b2fc, 0x4a471bc7, 0x7a9523a2, 0x2be36b0d, 0x1b315368, 0x096552c9, 0x39b76aac, 0x68c12203, 0x58131a66, 0xca2db35d, 0xfaff8b38, 0xab89c397, 0x9b5bfbf2, 0x8a18e710, 0xbacadf75, 0xebbc97da, 0xdb6eafbf, 0x49500684, 0x79823ee1, 0x28f4764e, 0x18264e2b, 0x18b8ea18, 0x286ad27d, 0x791c9ad2, 0x49cea2b7, 0xdbf00b8c, 0xeb2233e9, 0xba547b46, 0x8a864323, 0x9bc55fc1, 0xab1767a4, 0xfa612f0b, 0xcab3176e, 0x588dbe55, 0x685f8630, 0x3929ce9f, 0x09fbf6fa, 0x1baff75b, 0x2b7dcf3e, 0x7a0b8791, 0x4ad9bff4, 0xd8e716cf, 0xe8352eaa, 0xb9436605, 0x89915e60, 0x98d24282, 0xa8007ae7, 0xf9763248, 0xc9a40a2d, 0x5b9aa316, 0x6b489b73, 0x3a3ed3dc, 0x0aecebb9, 0x1e96d09e, 0x2e44e8fb, 0x7f32a054, 0x4fe09831, 0xddde310a, 0xed0c096f, 0xbc7a41c0, 0x8ca879a5, 0x9deb6547, 0xad395d22, 0xfc4f158d, 0xcc9d2de8, 0x5ea384d3, 0x6e71bcb6, 0x3f07f419, 0x0fd5cc7c, 0x1d81cddd, 0x2d53f5b8, 0x7c25bd17, 0x4cf78572, 0xdec92c49, 0xee1b142c, 0xbf6d5c83, 0x8fbf64e6, 0x9efc7804, 0xae2e4061, 0xff5808ce, 0xcf8a30ab, 0x5db49990, 0x6d66a1f5, 0x3c10e95a, 0x0cc2d13f, 0x14e49f14, 0x2436a771, 0x7540efde, 0x4592d7bb, 0xd7ac7e80, 0xe77e46e5, 0xb6080e4a, 0x86da362f, 0x97992acd, 0xa74b12a8, 0xf63d5a07, 0xc6ef6262, 0x54d1cb59, 0x6403f33c, 0x3575bb93, 0x05a783f6, 0x17f38257, 0x2721ba32, 0x7657f29d, 0x4685caf8, 0xd4bb63c3, 0xe4695ba6, 0xb51f1309, 0x85cd2b6c, 0x948e378e, 0xa45c0feb, 0xf52a4744, 0xc5f87f21, 0x57c6d61a, 0x6714ee7f, 0x3662a6d0, 0x06b09eb5, 0x12caa592, 0x22189df7, 0x736ed558, 0x43bced3d, 0xd1824406, 0xe1507c63, 0xb02634cc, 0x80f40ca9, 0x91b7104b, 0xa165282e, 0xf0136081, 0xc0c158e4, 0x52fff1df, 0x622dc9ba, 0x335b8115, 0x0389b970, 0x11ddb8d1, 0x210f80b4, 0x7079c81b, 0x40abf07e, 0xd2955945, 0xe2476120, 0xb331298f, 0x83e311ea, 0x92a00d08, 0xa272356d, 0xf3047dc2, 0xc3d645a7, 0x51e8ec9c, 0x613ad4f9, 0x304c9c56, 0x009ea433 },
+    { 0x00000000, 0x54075546, 0xa80eaa8c, 0xfc09ffca, 0x55f123e9, 0x01f676af, 0xfdff8965, 0xa9f8dc23, 0xabe247d2, 0xffe51294, 0x03eced5e, 0x57ebb818, 0xfe13643b, 0xaa14317d, 0x561dceb7, 0x021a9bf1, 0x5228f955, 0x062fac13, 0xfa2653d9, 0xae21069f, 0x07d9dabc, 0x53de8ffa, 0xafd77030, 0xfbd02576, 0xf9cabe87, 0xadcdebc1, 0x51c4140b, 0x05c3414d, 0xac3b9d6e, 0xf83cc828, 0x043537e2, 0x503262a4, 0xa451f2aa, 0xf056a7ec, 0x0c5f5826, 0x58580d60, 0xf1a0d143, 0xa5a78405, 0x59ae7bcf, 0x0da92e89, 0x0fb3b578, 0x5bb4e03e, 0xa7bd1ff4, 0xf3ba4ab2, 0x5a429691, 0x0e45c3d7, 0xf24c3c1d, 0xa64b695b, 0xf6790bff, 0xa27e5eb9, 0x5e77a173, 0x0a70f435, 0xa3882816, 0xf78f7d50, 0x0b86829a, 0x5f81d7dc, 0x5d9b4c2d, 0x099c196b, 0xf595e6a1, 0xa192b3e7, 0x086a6fc4, 0x5c6d3a82, 0xa064c548, 0xf463900e, 0x4d4f93a5, 0x1948c6e3, 0xe5413929, 0xb1466c6f, 0x18beb04c, 0x4cb9e50a, 0xb0b01ac0, 0xe4b74f86, 0xe6add477, 0xb2aa8131, 0x4ea37efb, 0x1aa42bbd, 0xb35cf79e, 0xe75ba2d8, 0x1b525d12, 0x4f550854, 0x1f676af0, 0x4b603fb6, 0xb769c07c, 0xe36e953a, 0x4a964919, 0x1e911c5f, 0xe298e395, 0xb69fb6d3, 0xb4852d22, 0xe0827864, 0x1c8b87ae, 0x488cd2e8, 0xe1740ecb, 0xb5735b8d, 0x497aa447, 0x1d7df101, 0xe91e610f, 0xbd193449, 0x4110cb83, 0x15179ec5, 0xbcef42e6, 0xe8e817a0, 0x14e1e86a, 0x40e6bd2c, 0x42fc26dd, 0x16fb739b, 0xeaf28c51, 0xbef5d917, 0x170d0534, 0x430a5072, 0xbf03afb8, 0xeb04fafe, 0xbb36985a, 0xef31cd1c, 0x133832d6, 0x473f6790, 0xeec7bbb3, 0xbac0eef5, 0x46c9113f, 0x12ce4479, 0x10d4df88, 0x44d38ace, 0xb8da7504, 0xecdd2042, 0x4525fc61, 0x1122a927, 0xed2b56ed, 0xb92c03ab, 0x9a9f274a, 0xce98720c, 0x32918dc6, 0x6696d880, 0xcf6e04a3, 0x9b6951e5, 0x6760ae2f, 0x3367fb69, 0x317d6098, 0x657a35de, 0x9973ca14, 0xcd749f52, 0x648c4371, 0x308b1637, 0xcc82e9fd, 0x9885bcbb, 0xc8b7de1f, 0x9cb08b59, 0x60b97493, 0x34be21d5, 0x9d46fdf6, 0xc941a8b0, 0x3548577a, 0x614f023c, 0x635599cd, 0x3752cc8b, 0xcb5b3341, 0x9f5c6607, 0x36a4ba24, 0x62a3ef62, 0x9eaa10a8, 0xcaad45ee, 0x3eced5e0, 0x6ac980a6, 0x96c07f6c, 0xc2c72a2a, 0x6b3ff609, 0x3f38a34f, 0xc3315c85, 0x973609c3, 0x952c9232, 0xc12bc774, 0x3d2238be, 0x69256df8, 0xc0ddb1db, 0x94dae49d, 0x68d31b57, 0x3cd44e11, 0x6ce62cb5, 0x38e179f3, 0xc4e88639, 0x90efd37f, 0x39170f5c, 0x6d105a1a, 0x9119a5d0, 0xc51ef096, 0xc7046b67, 0x93033e21, 0x6f0ac1eb, 0x3b0d94ad, 0x92f5488e, 0xc6f21dc8, 0x3afbe202, 0x6efcb744, 0xd7d0b4ef, 0x83d7e1a9, 0x7fde1e63, 0x2bd94b25, 0x82219706, 0xd626c240, 0x2a2f3d8a, 0x7e2868cc, 0x7c32f33d, 0x2835a67b, 0xd43c59b1, 0x803b0cf7, 0x29c3d0d4, 0x7dc48592, 0x81cd7a58, 0xd5ca2f1e, 0x85f84dba, 0xd1ff18fc, 0x2df6e736, 0x79f1b270, 0xd0096e53, 0x840e3b15, 0x7807c4df, 0x2c009199, 0x2e1a0a68, 0x7a1d5f2e, 0x8614a0e4, 0xd213f5a2, 0x7beb2981, 0x2fec7cc7, 0xd3e5830d, 0x87e2d64b, 0x73814645, 0x27861303, 0xdb8fecc9, 0x8f88b98f, 0x267065ac, 0x727730ea, 0x8e7ecf20, 0xda799a66, 0xd8630197, 0x8c6454d1, 0x706dab1b, 0x246afe5d, 0x8d92227e, 0xd9957738, 0x259c88f2, 0x719bddb4, 0x21a9bf10, 0x75aeea56, 0x89a7159c, 0xdda040da, 0x74589cf9, 0x205fc9bf, 0xdc563675, 0x88516333, 0x8a4bf8c2, 0xde4cad84, 0x2245524e, 0x76420708, 0xdfbadb2b, 0x8bbd8e6d, 0x77b471a7, 0x23b324e1 },
+    { 0x00000000, 0x678efd01, 0xcf1dfa02, 0xa8930703, 0x9bd782f5, 0xfc597ff4, 0x54ca78f7, 0x334485f6, 0x3243731b, 0x55cd8e1a, 0xfd5e8919, 0x9ad07418, 0xa994f1ee, 0xce1a0cef, 0x66890bec, 0x0107f6ed, 0x6486e636, 0x03081b37, 0xab9b1c34, 0xcc15e135, 0xff5164c3, 0x98df99c2, 0x304c9ec1, 0x57c263c0, 0x56c5952d, 0x314b682c, 0x99d86f2f, 0xfe56922e, 0xcd1217d8, 0xaa9cead9, 0x020fedda, 0x658110db, 0xc90dcc6c, 0xae83316d, 0x0610366e, 0x619ecb6f, 0x52da4e99, 0x3554b398, 0x9dc7b49b, 0xfa49499a, 0xfb4ebf77, 0x9cc04276, 0x34534575, 0x53ddb874, 0x60993d82, 0x0717c083, 0xaf84c780, 0xc80a3a81, 0xad8b2a5a, 0xca05d75b, 0x6296d058, 0x05182d59, 0x365ca8af, 0x51d255ae, 0xf94152ad, 0x9ecfafac, 0x9fc85941, 0xf846a440, 0x50d5a343, 0x375b5e42, 0x041fdbb4, 0x639126b5, 0xcb0221b6, 0xac8cdcb7, 0x97f7ee29, 0xf0791328, 0x58ea142b, 0x3f64e92a, 0x0c206cdc, 0x6bae91dd, 0xc33d96de, 0xa4b36bdf, 0xa5b49d32, 0xc23a6033, 0x6aa96730, 0x0d279a31, 0x3e631fc7, 0x59ede2c6, 0xf17ee5c5, 0x96f018c4, 0xf371081f, 0x94fff51e, 0x3c6cf21d, 0x5be20f1c, 0x68a68aea, 0x0f2877eb, 0xa7bb70e8, 0xc0358de9, 0xc1327b04, 0xa6bc8605, 0x0e2f8106, 0x69a17c07, 0x5ae5f9f1, 0x3d6b04f0, 0x95f803f3, 0xf276fef2, 0x5efa2245, 0x3974df44, 0x91e7d847, 0xf6692546, 0xc52da0b0, 0xa2a35db1, 0x0a305ab2, 0x6dbea7b3, 0x6cb9515e, 0x0b37ac5f, 0xa3a4ab5c, 0xc42a565d, 0xf76ed3ab, 0x90e02eaa, 0x387329a9, 0x5ffdd4a8, 0x3a7cc473, 0x5df23972, 0xf5613e71, 0x92efc370, 0xa1ab4686, 0xc625bb87, 0x6eb6bc84, 0x09384185, 0x083fb768, 0x6fb14a69, 0xc7224d6a, 0xa0acb06b, 0x93e8359d, 0xf466c89c, 0x5cf5cf9f, 0x3b7b329e, 0x2a03aaa3, 0x4d8d57a2, 0xe51e50a1, 0x8290ada0, 0xb1d42856, 0xd65ad557, 0x7ec9d254, 0x19472f55, 0x1840d9b8, 0x7fce24b9, 0xd75d23ba, 0xb0d3debb, 0x83975b4d, 0xe419a64c, 0x4c8aa14f, 0x2b045c4e, 0x4e854c95, 0x290bb194, 0x8198b697, 0xe6164b96, 0xd552ce60, 0xb2dc3361, 0x1a4f3462, 0x7dc1c963, 0x7cc63f8e, 0x1b48c28f, 0xb3dbc58c, 0xd455388d, 0xe711bd7b, 0x809f407a, 0x280c4779, 0x4f82ba78, 0xe30e66cf, 0x84809bce, 0x2c139ccd, 0x4b9d61cc, 0x78d9e43a, 0x1f57193b, 0xb7c41e38, 0xd04ae339, 0xd14d15d4, 0xb6c3e8d5, 0x1e50efd6, 0x79de12d7, 0x4a9a9721, 0x2d146a20, 0x85876d23, 0xe2099022, 0x878880f9, 0xe0067df8, 0x48957afb, 0x2f1b87fa, 0x1c5f020c, 0x7bd1ff0d, 0xd342f80e, 0xb4cc050f, 0xb5cbf3e2, 0xd2450ee3, 0x7ad609e0, 0x1d58f4e1, 0x2e1c7117, 0x49928c16, 0xe1018b15, 0x868f7614, 0xbdf4448a, 0xda7ab98b, 0x72e9be88, 0x15674389, 0x2623c67f, 0x41ad3b7e, 0xe93e3c7d, 0x8eb0c17c, 0x8fb73791, 0xe839ca90, 0x40aacd93, 0x27243092, 0x1460b564, 0x73ee4865, 0xdb7d4f66, 0xbcf3b267, 0xd972a2bc, 0xbefc5fbd, 0x166f58be, 0x71e1a5bf, 0x42a52049, 0x252bdd48, 0x8db8da4b, 0xea36274a, 0xeb31d1a7, 0x8cbf2ca6, 0x242c2ba5, 0x43a2d6a4, 0x70e65352, 0x1768ae53, 0xbffba950, 0xd8755451, 0x74f988e6, 0x137775e7, 0xbbe472e4, 0xdc6a8fe5, 0xef2e0a13, 0x88a0f712, 0x2033f011, 0x47bd0d10, 0x46bafbfd, 0x213406fc, 0x89a701ff, 0xee29fcfe, 0xdd6d7908, 0xbae38409, 0x1270830a, 0x75fe7e0b, 0x107f6ed0, 0x77f193d1, 0xdf6294d2, 0xb8ec69d3, 0x8ba8ec25, 0xec261124, 0x44b51627, 0x233beb26, 0x223c1dcb, 0x45b2e0ca, 0xed21e7c9, 0x8aaf1ac8, 0xb9eb9f3e, 0xde65623f, 0x76f6653c, 0x1178983d },
+    { 0x00000000, 0xf20c0dfe, 0xe1f46d0d, 0x13f860f3, 0xc604aceb, 0x3408a115, 0x27f0c1e6, 0xd5fccc18, 0x89e52f27, 0x7be922d9, 0x6811422a, 0x9a1d4fd4, 0x4fe183cc, 0xbded8e32, 0xae15eec1, 0x5c19e33f, 0x162628bf, 0xe42a2541, 0xf7d245b2, 0x05de484c, 0xd0228454, 0x222e89aa, 0x31d6e959, 0xc3dae4a7, 0x9fc30798, 0x6dcf0a66, 0x7e376a95, 0x8c3b676b, 0x59c7ab73, 0xabcba68d, 0xb833c67e, 0x4a3fcb80, 0x2c4c517e, 0xde405c80, 0xcdb83c73, 0x3fb4318d, 0xea48fd95, 0x1844f06b, 0x0bbc9098, 0xf9b09d66, 0xa5a97e59, 0x57a573a7, 0x445d1354, 0xb6511eaa, 0x63add2b2, 0x91a1df4c, 0x8259bfbf, 0x7055b241, 0x3a6a79c1, 0xc866743f, 0xdb9e14cc, 0x29921932, 0xfc6ed52a, 0x0e62d8d4, 0x1d9ab827, 0xef96b5d9, 0xb38f56e6, 0x41835b18, 0x527b3beb, 0xa0773615, 0x758bfa0d, 0x8787f7f3, 0x947f9700, 0x66739afe, 0x5898a2fc, 0xaa94af02, 0xb96ccff1, 0x4b60c20f, 0x9e9c0e17, 0x6c9003e9, 0x7f68631a, 0x8d646ee4, 0xd17d8ddb, 0x23718025, 0x3089e0d6, 0xc285ed28, 0x17792130, 0xe5752cce, 0xf68d4c3d, 0x048141c3, 0x4ebe8a43, 0xbcb287bd, 0xaf4ae74e, 0x5d46eab0, 0x88ba26a8, 0x7ab62b56, 0x694e4ba5, 0x9b42465b, 0xc75ba564, 0x3557a89a, 0x26afc869, 0xd4a3c597, 0x015f098f, 0xf3530471, 0xe0ab6482, 0x12a7697c, 0x74d4f382, 0x86d8fe7c, 0x95209e8f, 0x672c9371, 0xb2d05f69, 0x40dc5297, 0x53243264, 0xa1283f9a, 0xfd31dca5, 0x0f3dd15b, 0x1cc5b1a8, 0xeec9bc56, 0x3b35704e, 0xc9397db0, 0xdac11d43, 0x28cd10bd, 0x62f2db3d, 0x90fed6c3, 0x8306b630, 0x710abbce, 0xa4f677d6, 0x56fa7a28, 0x45021adb, 0xb70e1725, 0xeb17f41a, 0x191bf9e4, 0x0ae39917, 0xf8ef94e9, 0x2d1358f1, 0xdf1f550f, 0xcce735fc, 0x3eeb3802, 0xb13145f8, 0x433d4806, 0x50c528f5, 0xa2c9250b, 0x7735e913, 0x8539e4ed, 0x96c1841e, 0x64cd89e0, 0x38d46adf, 0xcad86721, 0xd92007d2, 0x2b2c0a2c, 0xfed0c634, 0x0cdccbca, 0x1f24ab39, 0xed28a6c7, 0xa7176d47, 0x551b60b9, 0x46e3004a, 0xb4ef0db4, 0x6113c1ac, 0x931fcc52, 0x80e7aca1, 0x72eba15f, 0x2ef24260, 0xdcfe4f9e, 0xcf062f6d, 0x3d0a2293, 0xe8f6ee8b, 0x1afae375, 0x09028386, 0xfb0e8e78, 0x9d7d1486, 0x6f711978, 0x7c89798b, 0x8e857475, 0x5b79b86d, 0xa975b593, 0xba8dd560, 0x4881d89e, 0x14983ba1, 0xe694365f, 0xf56c56ac, 0x07605b52, 0xd29c974a, 0x20909ab4, 0x3368fa47, 0xc164f7b9, 0x8b5b3c39, 0x795731c7, 0x6aaf5134, 0x98a35cca, 0x4d5f90d2, 0xbf539d2c, 0xacabfddf, 0x5ea7f021, 0x02be131e, 0xf0b21ee0, 0xe34a7e13, 0x114673ed, 0xc4babff5, 0x36b6b20b, 0x254ed2f8, 0xd742df06, 0xe9a9e704, 0x1ba5eafa, 0x085d8a09, 0xfa5187f7, 0x2fad4bef, 0xdda14611, 0xce5926e2, 0x3c552b1c, 0x604cc823, 0x9240c5dd, 0x81b8a52e, 0x73b4a8d0, 0xa64864c8, 0x54446936, 0x47bc09c5, 0xb5b0043b, 0xff8fcfbb, 0x0d83c245, 0x1e7ba2b6, 0xec77af48, 0x398b6350, 0xcb876eae, 0xd87f0e5d, 0x2a7303a3, 0x766ae09c, 0x8466ed62, 0x979e8d91, 0x6592806f, 0xb06e4c77, 0x42624189, 0x519a217a, 0xa3962c84, 0xc5e5b67a, 0x37e9bb84, 0x2411db77, 0xd61dd689, 0x03e11a91, 0xf1ed176f, 0xe215779c, 0x10197a62, 0x4c00995d, 0xbe0c94a3, 0xadf4f450, 0x5ff8f9ae, 0x8a0435b6, 0x78083848, 0x6bf058bb, 0x99fc5545, 0xd3c39ec5, 0x21cf933b, 0x3237f3c8, 0xc03bfe36, 0x15c7322e, 0xe7cb3fd0, 0xf4335f23, 0x063f52dd, 0x5a26b1e2, 0xa82abc1c, 0xbbd2dcef, 0x49ded111, 0x9c221d09, 0x6e2e10f7, 0x7dd67004, 0x8fda7dfa }
+};
+
+static uint32_t long_shifts[4][256] =
+{
+    { 0x00000000, 0xe040e0ac, 0xc56db7a9, 0x252d5705, 0x8f3719a3, 0x6f77f90f, 0x4a5aae0a, 0xaa1a4ea6, 0x1b8245b7, 0xfbc2a51b, 0xdeeff21e, 0x3eaf12b2, 0x94b55c14, 0x74f5bcb8, 0x51d8ebbd, 0xb1980b11, 0x37048b6e, 0xd7446bc2, 0xf2693cc7, 0x1229dc6b, 0xb83392cd, 0x58737261, 0x7d5e2564, 0x9d1ec5c8, 0x2c86ced9, 0xccc62e75, 0xe9eb7970, 0x09ab99dc, 0xa3b1d77a, 0x43f137d6, 0x66dc60d3, 0x869c807f, 0x6e0916dc, 0x8e49f670, 0xab64a175, 0x4b2441d9, 0xe13e0f7f, 0x017eefd3, 0x2453b8d6, 0xc413587a, 0x758b536b, 0x95cbb3c7, 0xb0e6e4c2, 0x50a6046e, 0xfabc4ac8, 0x1afcaa64, 0x3fd1fd61, 0xdf911dcd, 0x590d9db2, 0xb94d7d1e, 0x9c602a1b, 0x7c20cab7, 0xd63a8411, 0x367a64bd, 0x135733b8, 0xf317d314, 0x428fd805, 0xa2cf38a9, 0x87e26fac, 0x67a28f00, 0xcdb8c1a6, 0x2df8210a, 0x08d5760f, 0xe89596a3, 0xdc122db8, 0x3c52cd14, 0x197f9a11, 0xf93f7abd, 0x5325341b, 0xb365d4b7, 0x964883b2, 0x7608631e, 0xc790680f, 0x27d088a3, 0x02fddfa6, 0xe2bd3f0a, 0x48a771ac, 0xa8e79100, 0x8dcac605, 0x6d8a26a9, 0xeb16a6d6, 0x0b56467a, 0x2e7b117f, 0xce3bf1d3, 0x6421bf75, 0x84615fd9, 0xa14c08dc, 0x410ce870, 0xf094e361, 0x10d403cd, 0x35f954c8, 0xd5b9b464, 0x7fa3fac2, 0x9fe31a6e, 0xbace4d6b, 0x5a8eadc7, 0xb21b3b64, 0x525bdbc8, 0x77768ccd, 0x97366c61, 0x3d2c22c7, 0xdd6cc26b, 0xf841956e, 0x180175c2, 0xa9997ed3, 0x49d99e7f, 0x6cf4c97a, 0x8cb429d6, 0x26ae6770, 0xc6ee87dc, 0xe3c3d0d9, 0x03833075, 0x851fb00a, 0x655f50a6, 0x407207a3, 0xa032e70f, 0x0a28a9a9, 0xea684905, 0xcf451e00, 0x2f05feac, 0x9e9df5bd, 0x7edd1511, 0x5bf04214, 0xbbb0a2b8, 0x11aaec1e, 0xf1ea0cb2, 0xd4c75bb7, 0x3487bb1b, 0xbdc82d81, 0x5d88cd2d, 0x78a59a28, 0x98e57a84, 0x32ff3422, 0xd2bfd48e, 0xf792838b, 0x17d26327, 0xa64a6836, 0x460a889a, 0x6327df9f, 0x83673f33, 0x297d7195, 0xc93d9139, 0xec10c63c, 0x0c502690, 0x8acca6ef, 0x6a8c4643, 0x4fa11146, 0xafe1f1ea, 0x05fbbf4c, 0xe5bb5fe0, 0xc09608e5, 0x20d6e849, 0x914ee358, 0x710e03f4, 0x542354f1, 0xb463b45d, 0x1e79fafb, 0xfe391a57, 0xdb144d52, 0x3b54adfe, 0xd3c13b5d, 0x3381dbf1, 0x16ac8cf4, 0xf6ec6c58, 0x5cf622fe, 0xbcb6c252, 0x999b9557, 0x79db75fb, 0xc8437eea, 0x28039e46, 0x0d2ec943, 0xed6e29ef, 0x47746749, 0xa73487e5, 0x8219d0e0, 0x6259304c, 0xe4c5b033, 0x0485509f, 0x21a8079a, 0xc1e8e736, 0x6bf2a990, 0x8bb2493c, 0xae9f1e39, 0x4edffe95, 0xff47f584, 0x1f071528, 0x3a2a422d, 0xda6aa281, 0x7070ec27, 0x90300c8b, 0xb51d5b8e, 0x555dbb22, 0x61da0039, 0x819ae095, 0xa4b7b790, 0x44f7573c, 0xeeed199a, 0x0eadf936, 0x2b80ae33, 0xcbc04e9f, 0x7a58458e, 0x9a18a522, 0xbf35f227, 0x5f75128b, 0xf56f5c2d, 0x152fbc81, 0x3002eb84, 0xd0420b28, 0x56de8b57, 0xb69e6bfb, 0x93b33cfe, 0x73f3dc52, 0xd9e992f4, 0x39a97258, 0x1c84255d, 0xfcc4c5f1, 0x4d5ccee0, 0xad1c2e4c, 0x88317949, 0x687199e5, 0xc26bd743, 0x222b37ef, 0x070660ea, 0xe7468046, 0x0fd316e5, 0xef93f649, 0xcabea14c, 0x2afe41e0, 0x80e40f46, 0x60a4efea, 0x4589b8ef, 0xa5c95843, 0x14515352, 0xf411b3fe, 0xd13ce4fb, 0x317c0457, 0x9b664af1, 0x7b26aa5d, 0x5e0bfd58, 0xbe4b1df4, 0x38d79d8b, 0xd8977d27, 0xfdba2a22, 0x1dfaca8e, 0xb7e08428, 0x57a06484, 0x728d3381, 0x92cdd32d, 0x2355d83c, 0xc3153890, 0xe6386f95, 0x06788f39, 0xac62c19f, 0x4c222133, 0x690f7636, 0x894f969a },
+    { 0x00000000, 0x7e7c2df3, 0xfcf85be6, 0x82847615, 0xfc1cc13d, 0x8260ecce, 0x00e49adb, 0x7e98b728, 0xfdd5f48b, 0x83a9d978, 0x012daf6d, 0x7f51829e, 0x01c935b6, 0x7fb51845, 0xfd316e50, 0x834d43a3, 0xfe479fe7, 0x803bb214, 0x02bfc401, 0x7cc3e9f2, 0x025b5eda, 0x7c277329, 0xfea3053c, 0x80df28cf, 0x03926b6c, 0x7dee469f, 0xff6a308a, 0x81161d79, 0xff8eaa51, 0x81f287a2, 0x0376f1b7, 0x7d0adc44, 0xf963493f, 0x871f64cc, 0x059b12d9, 0x7be73f2a, 0x057f8802, 0x7b03a5f1, 0xf987d3e4, 0x87fbfe17, 0x04b6bdb4, 0x7aca9047, 0xf84ee652, 0x8632cba1, 0xf8aa7c89, 0x86d6517a, 0x0452276f, 0x7a2e0a9c, 0x0724d6d8, 0x7958fb2b, 0xfbdc8d3e, 0x85a0a0cd, 0xfb3817e5, 0x85443a16, 0x07c04c03, 0x79bc61f0, 0xfaf12253, 0x848d0fa0, 0x060979b5, 0x78755446, 0x06ede36e, 0x7891ce9d, 0xfa15b888, 0x8469957b, 0xf72ae48f, 0x8956c97c, 0x0bd2bf69, 0x75ae929a, 0x0b3625b2, 0x754a0841, 0xf7ce7e54, 0x89b253a7, 0x0aff1004, 0x74833df7, 0xf6074be2, 0x887b6611, 0xf6e3d139, 0x889ffcca, 0x0a1b8adf, 0x7467a72c, 0x096d7b68, 0x7711569b, 0xf595208e, 0x8be90d7d, 0xf571ba55, 0x8b0d97a6, 0x0989e1b3, 0x77f5cc40, 0xf4b88fe3, 0x8ac4a210, 0x0840d405, 0x763cf9f6, 0x08a44ede, 0x76d8632d, 0xf45c1538, 0x8a2038cb, 0x0e49adb0, 0x70358043, 0xf2b1f656, 0x8ccddba5, 0xf2556c8d, 0x8c29417e, 0x0ead376b, 0x70d11a98, 0xf39c593b, 0x8de074c8, 0x0f6402dd, 0x71182f2e, 0x0f809806, 0x71fcb5f5, 0xf378c3e0, 0x8d04ee13, 0xf00e3257, 0x8e721fa4, 0x0cf669b1, 0x728a4442, 0x0c12f36a, 0x726ede99, 0xf0eaa88c, 0x8e96857f, 0x0ddbc6dc, 0x73a7eb2f, 0xf1239d3a, 0x8f5fb0c9, 0xf1c707e1, 0x8fbb2a12, 0x0d3f5c07, 0x734371f4, 0xebb9bfef, 0x95c5921c, 0x1741e409, 0x693dc9fa, 0x17a57ed2, 0x69d95321, 0xeb5d2534, 0x952108c7, 0x166c4b64, 0x68106697, 0xea941082, 0x94e83d71, 0xea708a59, 0x940ca7aa, 0x1688d1bf, 0x68f4fc4c, 0x15fe2008, 0x6b820dfb, 0xe9067bee, 0x977a561d, 0xe9e2e135, 0x979eccc6, 0x151abad3, 0x6b669720, 0xe82bd483, 0x9657f970, 0x14d38f65, 0x6aafa296, 0x143715be, 0x6a4b384d, 0xe8cf4e58, 0x96b363ab, 0x12daf6d0, 0x6ca6db23, 0xee22ad36, 0x905e80c5, 0xeec637ed, 0x90ba1a1e, 0x123e6c0b, 0x6c4241f8, 0xef0f025b, 0x91732fa8, 0x13f759bd, 0x6d8b744e, 0x1313c366, 0x6d6fee95, 0xefeb9880, 0x9197b573, 0xec9d6937, 0x92e144c4, 0x106532d1, 0x6e191f22, 0x1081a80a, 0x6efd85f9, 0xec79f3ec, 0x9205de1f, 0x11489dbc, 0x6f34b04f, 0xedb0c65a, 0x93cceba9, 0xed545c81, 0x93287172, 0x11ac0767, 0x6fd02a94, 0x1c935b60, 0x62ef7693, 0xe06b0086, 0x9e172d75, 0xe08f9a5d, 0x9ef3b7ae, 0x1c77c1bb, 0x620bec48, 0xe146afeb, 0x9f3a8218, 0x1dbef40d, 0x63c2d9fe, 0x1d5a6ed6, 0x63264325, 0xe1a23530, 0x9fde18c3, 0xe2d4c487, 0x9ca8e974, 0x1e2c9f61, 0x6050b292, 0x1ec805ba, 0x60b42849, 0xe2305e5c, 0x9c4c73af, 0x1f01300c, 0x617d1dff, 0xe3f96bea, 0x9d854619, 0xe31df131, 0x9d61dcc2, 0x1fe5aad7, 0x61998724, 0xe5f0125f, 0x9b8c3fac, 0x190849b9, 0x6774644a, 0x19ecd362, 0x6790fe91, 0xe5148884, 0x9b68a577, 0x1825e6d4, 0x6659cb27, 0xe4ddbd32, 0x9aa190c1, 0xe43927e9, 0x9a450a1a, 0x18c17c0f, 0x66bd51fc, 0x1bb78db8, 0x65cba04b, 0xe74fd65e, 0x9933fbad, 0xe7ab4c85, 0x99d76176, 0x1b531763, 0x652f3a90, 0xe6627933, 0x981e54c0, 0x1a9a22d5, 0x64e60f26, 0x1a7eb80e, 0x640295fd, 0xe686e3e8, 0x98face1b },
+    { 0x00000000, 0xd29f092f, 0xa0d264af, 0x724d6d80, 0x4448bfaf, 0x96d7b680, 0xe49adb00, 0x3605d22f, 0x88917f5e, 0x5a0e7671, 0x28431bf1, 0xfadc12de, 0xccd9c0f1, 0x1e46c9de, 0x6c0ba45e, 0xbe94ad71, 0x14ce884d, 0xc6518162, 0xb41cece2, 0x6683e5cd, 0x508637e2, 0x82193ecd, 0xf054534d, 0x22cb5a62, 0x9c5ff713, 0x4ec0fe3c, 0x3c8d93bc, 0xee129a93, 0xd81748bc, 0x0a884193, 0x78c52c13, 0xaa5a253c, 0x299d109a, 0xfb0219b5, 0x894f7435, 0x5bd07d1a, 0x6dd5af35, 0xbf4aa61a, 0xcd07cb9a, 0x1f98c2b5, 0xa10c6fc4, 0x739366eb, 0x01de0b6b, 0xd3410244, 0xe544d06b, 0x37dbd944, 0x4596b4c4, 0x9709bdeb, 0x3d5398d7, 0xefcc91f8, 0x9d81fc78, 0x4f1ef557, 0x791b2778, 0xab842e57, 0xd9c943d7, 0x0b564af8, 0xb5c2e789, 0x675deea6, 0x15108326, 0xc78f8a09, 0xf18a5826, 0x23155109, 0x51583c89, 0x83c735a6, 0x533a2134, 0x81a5281b, 0xf3e8459b, 0x21774cb4, 0x17729e9b, 0xc5ed97b4, 0xb7a0fa34, 0x653ff31b, 0xdbab5e6a, 0x09345745, 0x7b793ac5, 0xa9e633ea, 0x9fe3e1c5, 0x4d7ce8ea, 0x3f31856a, 0xedae8c45, 0x47f4a979, 0x956ba056, 0xe726cdd6, 0x35b9c4f9, 0x03bc16d6, 0xd1231ff9, 0xa36e7279, 0x71f17b56, 0xcf65d627, 0x1dfadf08, 0x6fb7b288, 0xbd28bba7, 0x8b2d6988, 0x59b260a7, 0x2bff0d27, 0xf9600408, 0x7aa731ae, 0xa8383881, 0xda755501, 0x08ea5c2e, 0x3eef8e01, 0xec70872e, 0x9e3deaae, 0x4ca2e381, 0xf2364ef0, 0x20a947df, 0x52e42a5f, 0x807b2370, 0xb67ef15f, 0x64e1f870, 0x16ac95f0, 0xc4339cdf, 0x6e69b9e3, 0xbcf6b0cc, 0xcebbdd4c, 0x1c24d463, 0x2a21064c, 0xf8be0f63, 0x8af362e3, 0x586c6bcc, 0xe6f8c6bd, 0x3467cf92, 0x462aa212, 0x94b5ab3d, 0xa2b07912, 0x702f703d, 0x02621dbd, 0xd0fd1492, 0xa6744268, 0x74eb4b47, 0x06a626c7, 0xd4392fe8, 0xe23cfdc7, 0x30a3f4e8, 0x42ee9968, 0x90719047, 0x2ee53d36, 0xfc7a3419, 0x8e375999, 0x5ca850b6, 0x6aad8299, 0xb8328bb6, 0xca7fe636, 0x18e0ef19, 0xb2baca25, 0x6025c30a, 0x1268ae8a, 0xc0f7a7a5, 0xf6f2758a, 0x246d7ca5, 0x56201125, 0x84bf180a, 0x3a2bb57b, 0xe8b4bc54, 0x9af9d1d4, 0x4866d8fb, 0x7e630ad4, 0xacfc03fb, 0xdeb16e7b, 0x0c2e6754, 0x8fe952f2, 0x5d765bdd, 0x2f3b365d, 0xfda43f72, 0xcba1ed5d, 0x193ee472, 0x6b7389f2, 0xb9ec80dd, 0x07782dac, 0xd5e72483, 0xa7aa4903, 0x7535402c, 0x43309203, 0x91af9b2c, 0xe3e2f6ac, 0x317dff83, 0x9b27dabf, 0x49b8d390, 0x3bf5be10, 0xe96ab73f, 0xdf6f6510, 0x0df06c3f, 0x7fbd01bf, 0xad220890, 0x13b6a5e1, 0xc129acce, 0xb364c14e, 0x61fbc861, 0x57fe1a4e, 0x85611361, 0xf72c7ee1, 0x25b377ce, 0xf54e635c, 0x27d16a73, 0x559c07f3, 0x87030edc, 0xb106dcf3, 0x6399d5dc, 0x11d4b85c, 0xc34bb173, 0x7ddf1c02, 0xaf40152d, 0xdd0d78ad, 0x0f927182, 0x3997a3ad, 0xeb08aa82, 0x9945c702, 0x4bdace2d, 0xe180eb11, 0x331fe23e, 0x41528fbe, 0x93cd8691, 0xa5c854be, 0x77575d91, 0x051a3011, 0xd785393e, 0x6911944f, 0xbb8e9d60, 0xc9c3f0e0, 0x1b5cf9cf, 0x2d592be0, 0xffc622cf, 0x8d8b4f4f, 0x5f144660, 0xdcd373c6, 0x0e4c7ae9, 0x7c011769, 0xae9e1e46, 0x989bcc69, 0x4a04c546, 0x3849a8c6, 0xead6a1e9, 0x54420c98, 0x86dd05b7, 0xf4906837, 0x260f6118, 0x100ab337, 0xc295ba18, 0xb0d8d798, 0x6247deb7, 0xc81dfb8b, 0x1a82f2a4, 0x68cf9f24, 0xba50960b, 0x8c554424, 0x5eca4d0b, 0x2c87208b, 0xfe1829a4, 0x408c84d5, 0x92138dfa, 0xe05ee07a, 0x32c1e955, 0x04c43b7a, 0xd65b3255, 0xa4165fd5, 0x768956fa },
+    { 0x00000000, 0x4904f221, 0x9209e442, 0xdb0d1663, 0x21ffbe75, 0x68fb4c54, 0xb3f65a37, 0xfaf2a816, 0x43ff7cea, 0x0afb8ecb, 0xd1f698a8, 0x98f26a89, 0x6200c29f, 0x2b0430be, 0xf00926dd, 0xb90dd4fc, 0x87fef9d4, 0xcefa0bf5, 0x15f71d96, 0x5cf3efb7, 0xa60147a1, 0xef05b580, 0x3408a3e3, 0x7d0c51c2, 0xc401853e, 0x8d05771f, 0x5608617c, 0x1f0c935d, 0xe5fe3b4b, 0xacfac96a, 0x77f7df09, 0x3ef32d28, 0x0a118559, 0x43157778, 0x9818611b, 0xd11c933a, 0x2bee3b2c, 0x62eac90d, 0xb9e7df6e, 0xf0e32d4f, 0x49eef9b3, 0x00ea0b92, 0xdbe71df1, 0x92e3efd0, 0x681147c6, 0x2115b5e7, 0xfa18a384, 0xb31c51a5, 0x8def7c8d, 0xc4eb8eac, 0x1fe698cf, 0x56e26aee, 0xac10c2f8, 0xe51430d9, 0x3e1926ba, 0x771dd49b, 0xce100067, 0x8714f246, 0x5c19e425, 0x151d1604, 0xefefbe12, 0xa6eb4c33, 0x7de65a50, 0x34e2a871, 0x14230ab2, 0x5d27f893, 0x862aeef0, 0xcf2e1cd1, 0x35dcb4c7, 0x7cd846e6, 0xa7d55085, 0xeed1a2a4, 0x57dc7658, 0x1ed88479, 0xc5d5921a, 0x8cd1603b, 0x7623c82d, 0x3f273a0c, 0xe42a2c6f, 0xad2ede4e, 0x93ddf366, 0xdad90147, 0x01d41724, 0x48d0e505, 0xb2224d13, 0xfb26bf32, 0x202ba951, 0x692f5b70, 0xd0228f8c, 0x99267dad, 0x422b6bce, 0x0b2f99ef, 0xf1dd31f9, 0xb8d9c3d8, 0x63d4d5bb, 0x2ad0279a, 0x1e328feb, 0x57367dca, 0x8c3b6ba9, 0xc53f9988, 0x3fcd319e, 0x76c9c3bf, 0xadc4d5dc, 0xe4c027fd, 0x5dcdf301, 0x14c90120, 0xcfc41743, 0x86c0e562, 0x7c324d74, 0x3536bf55, 0xee3ba936, 0xa73f5b17, 0x99cc763f, 0xd0c8841e, 0x0bc5927d, 0x42c1605c, 0xb833c84a, 0xf1373a6b, 0x2a3a2c08, 0x633ede29, 0xda330ad5, 0x9337f8f4, 0x483aee97, 0x013e1cb6, 0xfbccb4a0, 0xb2c84681, 0x69c550e2, 0x20c1a2c3, 0x28461564, 0x6142e745, 0xba4ff126, 0xf34b0307, 0x09b9ab11, 0x40bd5930, 0x9bb04f53, 0xd2b4bd72, 0x6bb9698e, 0x22bd9baf, 0xf9b08dcc, 0xb0b47fed, 0x4a46d7fb, 0x034225da, 0xd84f33b9, 0x914bc198, 0xafb8ecb0, 0xe6bc1e91, 0x3db108f2, 0x74b5fad3, 0x8e4752c5, 0xc743a0e4, 0x1c4eb687, 0x554a44a6, 0xec47905a, 0xa543627b, 0x7e4e7418, 0x374a8639, 0xcdb82e2f, 0x84bcdc0e, 0x5fb1ca6d, 0x16b5384c, 0x2257903d, 0x6b53621c, 0xb05e747f, 0xf95a865e, 0x03a82e48, 0x4aacdc69, 0x91a1ca0a, 0xd8a5382b, 0x61a8ecd7, 0x28ac1ef6, 0xf3a10895, 0xbaa5fab4, 0x405752a2, 0x0953a083, 0xd25eb6e0, 0x9b5a44c1, 0xa5a969e9, 0xecad9bc8, 0x37a08dab, 0x7ea47f8a, 0x8456d79c, 0xcd5225bd, 0x165f33de, 0x5f5bc1ff, 0xe6561503, 0xaf52e722, 0x745ff141, 0x3d5b0360, 0xc7a9ab76, 0x8ead5957, 0x55a04f34, 0x1ca4bd15, 0x3c651fd6, 0x7561edf7, 0xae6cfb94, 0xe76809b5, 0x1d9aa1a3, 0x549e5382, 0x8f9345e1, 0xc697b7c0, 0x7f9a633c, 0x369e911d, 0xed93877e, 0xa497755f, 0x5e65dd49, 0x17612f68, 0xcc6c390b, 0x8568cb2a, 0xbb9be602, 0xf29f1423, 0x29920240, 0x6096f061, 0x9a645877, 0xd360aa56, 0x086dbc35, 0x41694e14, 0xf8649ae8, 0xb16068c9, 0x6a6d7eaa, 0x23698c8b, 0xd99b249d, 0x909fd6bc, 0x4b92c0df, 0x029632fe, 0x36749a8f, 0x7f7068ae, 0xa47d7ecd, 0xed798cec, 0x178b24fa, 0x5e8fd6db, 0x8582c0b8, 0xcc863299, 0x758be665, 0x3c8f1444, 0xe7820227, 0xae86f006, 0x54745810, 0x1d70aa31, 0xc67dbc52, 0x8f794e73, 0xb18a635b, 0xf88e917a, 0x23838719, 0x6a877538, 0x9075dd2e, 0xd9712f0f, 0x027c396c, 0x4b78cb4d, 0xf2751fb1, 0xbb71ed90, 0x607cfbf3, 0x297809d2, 0xd38aa1c4, 0x9a8e53e5, 0x41834586, 0x0887b7a7 }
+};
+
+static uint32_t short_shifts[4][256] =
+{
+    { 0x00000000, 0xdcb17aa4, 0xbc8e83b9, 0x603ff91d, 0x7cf17183, 0xa0400b27, 0xc07ff23a, 0x1cce889e, 0xf9e2e306, 0x255399a2, 0x456c60bf, 0x99dd1a1b, 0x85139285, 0x59a2e821, 0x399d113c, 0xe52c6b98, 0xf629b0fd, 0x2a98ca59, 0x4aa73344, 0x961649e0, 0x8ad8c17e, 0x5669bbda, 0x365642c7, 0xeae73863, 0x0fcb53fb, 0xd37a295f, 0xb345d042, 0x6ff4aae6, 0x733a2278, 0xaf8b58dc, 0xcfb4a1c1, 0x1305db65, 0xe9bf170b, 0x350e6daf, 0x553194b2, 0x8980ee16, 0x954e6688, 0x49ff1c2c, 0x29c0e531, 0xf5719f95, 0x105df40d, 0xccec8ea9, 0xacd377b4, 0x70620d10, 0x6cac858e, 0xb01dff2a, 0xd0220637, 0x0c937c93, 0x1f96a7f6, 0xc327dd52, 0xa318244f, 0x7fa95eeb, 0x6367d675, 0xbfd6acd1, 0xdfe955cc, 0x03582f68, 0xe67444f0, 0x3ac53e54, 0x5afac749, 0x864bbded, 0x9a853573, 0x46344fd7, 0x260bb6ca, 0xfabacc6e, 0xd69258e7, 0x0a232243, 0x6a1cdb5e, 0xb6ada1fa, 0xaa632964, 0x76d253c0, 0x16edaadd, 0xca5cd079, 0x2f70bbe1, 0xf3c1c145, 0x93fe3858, 0x4f4f42fc, 0x5381ca62, 0x8f30b0c6, 0xef0f49db, 0x33be337f, 0x20bbe81a, 0xfc0a92be, 0x9c356ba3, 0x40841107, 0x5c4a9999, 0x80fbe33d, 0xe0c41a20, 0x3c756084, 0xd9590b1c, 0x05e871b8, 0x65d788a5, 0xb966f201, 0xa5a87a9f, 0x7919003b, 0x1926f926, 0xc5978382, 0x3f2d4fec, 0xe39c3548, 0x83a3cc55, 0x5f12b6f1, 0x43dc3e6f, 0x9f6d44cb, 0xff52bdd6, 0x23e3c772, 0xc6cfacea, 0x1a7ed64e, 0x7a412f53, 0xa6f055f7, 0xba3edd69, 0x668fa7cd, 0x06b05ed0, 0xda012474, 0xc904ff11, 0x15b585b5, 0x758a7ca8, 0xa93b060c, 0xb5f58e92, 0x6944f436, 0x097b0d2b, 0xd5ca778f, 0x30e61c17, 0xec5766b3, 0x8c689fae, 0x50d9e50a, 0x4c176d94, 0x90a61730, 0xf099ee2d, 0x2c289489, 0xa8c8c73f, 0x7479bd9b, 0x14464486, 0xc8f73e22, 0xd439b6bc, 0x0888cc18, 0x68b73505, 0xb4064fa1, 0x512a2439, 0x8d9b5e9d, 0xeda4a780, 0x3115dd24, 0x2ddb55ba, 0xf16a2f1e, 0x9155d603, 0x4de4aca7, 0x5ee177c2, 0x82500d66, 0xe26ff47b, 0x3ede8edf, 0x22100641, 0xfea17ce5, 0x9e9e85f8, 0x422fff5c, 0xa70394c4, 0x7bb2ee60, 0x1b8d177d, 0xc73c6dd9, 0xdbf2e547, 0x07439fe3, 0x677c66fe, 0xbbcd1c5a, 0x4177d034, 0x9dc6aa90, 0xfdf9538d, 0x21482929, 0x3d86a1b7, 0xe137db13, 0x8108220e, 0x5db958aa, 0xb8953332, 0x64244996, 0x041bb08b, 0xd8aaca2f, 0xc46442b1, 0x18d53815, 0x78eac108, 0xa45bbbac, 0xb75e60c9, 0x6bef1a6d, 0x0bd0e370, 0xd76199d4, 0xcbaf114a, 0x171e6bee, 0x772192f3, 0xab90e857, 0x4ebc83cf, 0x920df96b, 0xf2320076, 0x2e837ad2, 0x324df24c, 0xeefc88e8, 0x8ec371f5, 0x52720b51, 0x7e5a9fd8, 0xa2ebe57c, 0xc2d41c61, 0x1e6566c5, 0x02abee5b, 0xde1a94ff, 0xbe256de2, 0x62941746, 0x87b87cde, 0x5b09067a, 0x3b36ff67, 0xe78785c3, 0xfb490d5d, 0x27f877f9, 0x47c78ee4, 0x9b76f440, 0x88732f25, 0x54c25581, 0x34fdac9c, 0xe84cd638, 0xf4825ea6, 0x28332402, 0x480cdd1f, 0x94bda7bb, 0x7191cc23, 0xad20b687, 0xcd1f4f9a, 0x11ae353e, 0x0d60bda0, 0xd1d1c704, 0xb1ee3e19, 0x6d5f44bd, 0x97e588d3, 0x4b54f277, 0x2b6b0b6a, 0xf7da71ce, 0xeb14f950, 0x37a583f4, 0x579a7ae9, 0x8b2b004d, 0x6e076bd5, 0xb2b61171, 0xd289e86c, 0x0e3892c8, 0x12f61a56, 0xce4760f2, 0xae7899ef, 0x72c9e34b, 0x61cc382e, 0xbd7d428a, 0xdd42bb97, 0x01f3c133, 0x1d3d49ad, 0xc18c3309, 0xa1b3ca14, 0x7d02b0b0, 0x982edb28, 0x449fa18c, 0x24a05891, 0xf8112235, 0xe4dfaaab, 0x386ed00f, 0x58512912, 0x84e053b6 },
+    { 0x00000000, 0x547df88f, 0xa8fbf11e, 0xfc860991, 0x541b94cd, 0x00666c42, 0xfce065d3, 0xa89d9d5c, 0xa837299a, 0xfc4ad115, 0x00ccd884, 0x54b1200b, 0xfc2cbd57, 0xa85145d8, 0x54d74c49, 0x00aab4c6, 0x558225c5, 0x01ffdd4a, 0xfd79d4db, 0xa9042c54, 0x0199b108, 0x55e44987, 0xa9624016, 0xfd1fb899, 0xfdb50c5f, 0xa9c8f4d0, 0x554efd41, 0x013305ce, 0xa9ae9892, 0xfdd3601d, 0x0155698c, 0x55289103, 0xab044b8a, 0xff79b305, 0x03ffba94, 0x5782421b, 0xff1fdf47, 0xab6227c8, 0x57e42e59, 0x0399d6d6, 0x03336210, 0x574e9a9f, 0xabc8930e, 0xffb56b81, 0x5728f6dd, 0x03550e52, 0xffd307c3, 0xabaeff4c, 0xfe866e4f, 0xaafb96c0, 0x567d9f51, 0x020067de, 0xaa9dfa82, 0xfee0020d, 0x02660b9c, 0x561bf313, 0x56b147d5, 0x02ccbf5a, 0xfe4ab6cb, 0xaa374e44, 0x02aad318, 0x56d72b97, 0xaa512206, 0xfe2cda89, 0x53e4e1e5, 0x0799196a, 0xfb1f10fb, 0xaf62e874, 0x07ff7528, 0x53828da7, 0xaf048436, 0xfb797cb9, 0xfbd3c87f, 0xafae30f0, 0x53283961, 0x0755c1ee, 0xafc85cb2, 0xfbb5a43d, 0x0733adac, 0x534e5523, 0x0666c420, 0x521b3caf, 0xae9d353e, 0xfae0cdb1, 0x527d50ed, 0x0600a862, 0xfa86a1f3, 0xaefb597c, 0xae51edba, 0xfa2c1535, 0x06aa1ca4, 0x52d7e42b, 0xfa4a7977, 0xae3781f8, 0x52b18869, 0x06cc70e6, 0xf8e0aa6f, 0xac9d52e0, 0x501b5b71, 0x0466a3fe, 0xacfb3ea2, 0xf886c62d, 0x0400cfbc, 0x507d3733, 0x50d783f5, 0x04aa7b7a, 0xf82c72eb, 0xac518a64, 0x04cc1738, 0x50b1efb7, 0xac37e626, 0xf84a1ea9, 0xad628faa, 0xf91f7725, 0x05997eb4, 0x51e4863b, 0xf9791b67, 0xad04e3e8, 0x5182ea79, 0x05ff12f6, 0x0555a630, 0x51285ebf, 0xadae572e, 0xf9d3afa1, 0x514e32fd, 0x0533ca72, 0xf9b5c3e3, 0xadc83b6c, 0xa7c9c3ca, 0xf3b43b45, 0x0f3232d4, 0x5b4fca5b, 0xf3d25707, 0xa7afaf88, 0x5b29a619, 0x0f545e96, 0x0ffeea50, 0x5b8312df, 0xa7051b4e, 0xf378e3c1, 0x5be57e9d, 0x0f988612, 0xf31e8f83, 0xa763770c, 0xf24be60f, 0xa6361e80, 0x5ab01711, 0x0ecdef9e, 0xa65072c2, 0xf22d8a4d, 0x0eab83dc, 0x5ad67b53, 0x5a7ccf95, 0x0e01371a, 0xf2873e8b, 0xa6fac604, 0x0e675b58, 0x5a1aa3d7, 0xa69caa46, 0xf2e152c9, 0x0ccd8840, 0x58b070cf, 0xa436795e, 0xf04b81d1, 0x58d61c8d, 0x0cabe402, 0xf02ded93, 0xa450151c, 0xa4faa1da, 0xf0875955, 0x0c0150c4, 0x587ca84b, 0xf0e13517, 0xa49ccd98, 0x581ac409, 0x0c673c86, 0x594fad85, 0x0d32550a, 0xf1b45c9b, 0xa5c9a414, 0x0d543948, 0x5929c1c7, 0xa5afc856, 0xf1d230d9, 0xf178841f, 0xa5057c90, 0x59837501, 0x0dfe8d8e, 0xa56310d2, 0xf11ee85d, 0x0d98e1cc, 0x59e51943, 0xf42d222f, 0xa050daa0, 0x5cd6d331, 0x08ab2bbe, 0xa036b6e2, 0xf44b4e6d, 0x08cd47fc, 0x5cb0bf73, 0x5c1a0bb5, 0x0867f33a, 0xf4e1faab, 0xa09c0224, 0x08019f78, 0x5c7c67f7, 0xa0fa6e66, 0xf48796e9, 0xa1af07ea, 0xf5d2ff65, 0x0954f6f4, 0x5d290e7b, 0xf5b49327, 0xa1c96ba8, 0x5d4f6239, 0x09329ab6, 0x09982e70, 0x5de5d6ff, 0xa163df6e, 0xf51e27e1, 0x5d83babd, 0x09fe4232, 0xf5784ba3, 0xa105b32c, 0x5f2969a5, 0x0b54912a, 0xf7d298bb, 0xa3af6034, 0x0b32fd68, 0x5f4f05e7, 0xa3c90c76, 0xf7b4f4f9, 0xf71e403f, 0xa363b8b0, 0x5fe5b121, 0x0b9849ae, 0xa305d4f2, 0xf7782c7d, 0x0bfe25ec, 0x5f83dd63, 0x0aab4c60, 0x5ed6b4ef, 0xa250bd7e, 0xf62d45f1, 0x5eb0d8ad, 0x0acd2022, 0xf64b29b3, 0xa236d13c, 0xa29c65fa, 0xf6e19d75, 0x0a6794e4, 0x5e1a6c6b, 0xf687f137, 0xa2fa09b8, 0x5e7c0029, 0x0a01f8a6 },
+    { 0x00000000, 0x4a7ff165, 0x94ffe2ca, 0xde8013af, 0x2c13b365, 0x666c4200, 0xb8ec51af, 0xf293a0ca, 0x582766ca, 0x125897af, 0xccd88400, 0x86a77565, 0x7434d5af, 0x3e4b24ca, 0xe0cb3765, 0xaab4c600, 0xb04ecd94, 0xfa313cf1, 0x24b12f5e, 0x6ecede3b, 0x9c5d7ef1, 0xd6228f94, 0x08a29c3b, 0x42dd6d5e, 0xe869ab5e, 0xa2165a3b, 0x7c964994, 0x36e9b8f1, 0xc47a183b, 0x8e05e95e, 0x5085faf1, 0x1afa0b94, 0x6571edd9, 0x2f0e1cbc, 0xf18e0f13, 0xbbf1fe76, 0x49625ebc, 0x031dafd9, 0xdd9dbc76, 0x97e24d13, 0x3d568b13, 0x77297a76, 0xa9a969d9, 0xe3d698bc, 0x11453876, 0x5b3ac913, 0x85badabc, 0xcfc52bd9, 0xd53f204d, 0x9f40d128, 0x41c0c287, 0x0bbf33e2, 0xf92c9328, 0xb353624d, 0x6dd371e2, 0x27ac8087, 0x8d184687, 0xc767b7e2, 0x19e7a44d, 0x53985528, 0xa10bf5e2, 0xeb740487, 0x35f41728, 0x7f8be64d, 0xcae3dbb2, 0x809c2ad7, 0x5e1c3978, 0x1463c81d, 0xe6f068d7, 0xac8f99b2, 0x720f8a1d, 0x38707b78, 0x92c4bd78, 0xd8bb4c1d, 0x063b5fb2, 0x4c44aed7, 0xbed70e1d, 0xf4a8ff78, 0x2a28ecd7, 0x60571db2, 0x7aad1626, 0x30d2e743, 0xee52f4ec, 0xa42d0589, 0x56bea543, 0x1cc15426, 0xc2414789, 0x883eb6ec, 0x228a70ec, 0x68f58189, 0xb6759226, 0xfc0a6343, 0x0e99c389, 0x44e632ec, 0x9a662143, 0xd019d026, 0xaf92366b, 0xe5edc70e, 0x3b6dd4a1, 0x711225c4, 0x8381850e, 0xc9fe746b, 0x177e67c4, 0x5d0196a1, 0xf7b550a1, 0xbdcaa1c4, 0x634ab26b, 0x2935430e, 0xdba6e3c4, 0x91d912a1, 0x4f59010e, 0x0526f06b, 0x1fdcfbff, 0x55a30a9a, 0x8b231935, 0xc15ce850, 0x33cf489a, 0x79b0b9ff, 0xa730aa50, 0xed4f5b35, 0x47fb9d35, 0x0d846c50, 0xd3047fff, 0x997b8e9a, 0x6be82e50, 0x2197df35, 0xff17cc9a, 0xb5683dff, 0x902bc195, 0xda5430f0, 0x04d4235f, 0x4eabd23a, 0xbc3872f0, 0xf6478395, 0x28c7903a, 0x62b8615f, 0xc80ca75f, 0x8273563a, 0x5cf34595, 0x168cb4f0, 0xe41f143a, 0xae60e55f, 0x70e0f6f0, 0x3a9f0795, 0x20650c01, 0x6a1afd64, 0xb49aeecb, 0xfee51fae, 0x0c76bf64, 0x46094e01, 0x98895dae, 0xd2f6accb, 0x78426acb, 0x323d9bae, 0xecbd8801, 0xa6c27964, 0x5451d9ae, 0x1e2e28cb, 0xc0ae3b64, 0x8ad1ca01, 0xf55a2c4c, 0xbf25dd29, 0x61a5ce86, 0x2bda3fe3, 0xd9499f29, 0x93366e4c, 0x4db67de3, 0x07c98c86, 0xad7d4a86, 0xe702bbe3, 0x3982a84c, 0x73fd5929, 0x816ef9e3, 0xcb110886, 0x15911b29, 0x5feeea4c, 0x4514e1d8, 0x0f6b10bd, 0xd1eb0312, 0x9b94f277, 0x690752bd, 0x2378a3d8, 0xfdf8b077, 0xb7874112, 0x1d338712, 0x574c7677, 0x89cc65d8, 0xc3b394bd, 0x31203477, 0x7b5fc512, 0xa5dfd6bd, 0xefa027d8, 0x5ac81a27, 0x10b7eb42, 0xce37f8ed, 0x84480988, 0x76dba942, 0x3ca45827, 0xe2244b88, 0xa85bbaed, 0x02ef7ced, 0x48908d88, 0x96109e27, 0xdc6f6f42, 0x2efccf88, 0x64833eed, 0xba032d42, 0xf07cdc27, 0xea86d7b3, 0xa0f926d6, 0x7e793579, 0x3406c41c, 0xc69564d6, 0x8cea95b3, 0x526a861c, 0x18157779, 0xb2a1b179, 0xf8de401c, 0x265e53b3, 0x6c21a2d6, 0x9eb2021c, 0xd4cdf379, 0x0a4de0d6, 0x403211b3, 0x3fb9f7fe, 0x75c6069b, 0xab461534, 0xe139e451, 0x13aa449b, 0x59d5b5fe, 0x8755a651, 0xcd2a5734, 0x679e9134, 0x2de16051, 0xf36173fe, 0xb91e829b, 0x4b8d2251, 0x01f2d334, 0xdf72c09b, 0x950d31fe, 0x8ff73a6a, 0xc588cb0f, 0x1b08d8a0, 0x517729c5, 0xa3e4890f, 0xe99b786a, 0x371b6bc5, 0x7d649aa0, 0xd7d05ca0, 0x9dafadc5, 0x432fbe6a, 0x09504f0f, 0xfbc3efc5, 0xb1bc1ea0, 0x6f3c0d0f, 0x2543fc6a },
+    { 0x00000000, 0x25bbf5db, 0x4b77ebb6, 0x6ecc1e6d, 0x96efd76c, 0xb35422b7, 0xdd983cda, 0xf823c901, 0x2833d829, 0x0d882df2, 0x6344339f, 0x46ffc644, 0xbedc0f45, 0x9b67fa9e, 0xf5abe4f3, 0xd0101128, 0x5067b052, 0x75dc4589, 0x1b105be4, 0x3eabae3f, 0xc688673e, 0xe33392e5, 0x8dff8c88, 0xa8447953, 0x7854687b, 0x5def9da0, 0x332383cd, 0x16987616, 0xeebbbf17, 0xcb004acc, 0xa5cc54a1, 0x8077a17a, 0xa0cf60a4, 0x8574957f, 0xebb88b12, 0xce037ec9, 0x3620b7c8, 0x139b4213, 0x7d575c7e, 0x58eca9a5, 0x88fcb88d, 0xad474d56, 0xc38b533b, 0xe630a6e0, 0x1e136fe1, 0x3ba89a3a, 0x55648457, 0x70df718c, 0xf0a8d0f6, 0xd513252d, 0xbbdf3b40, 0x9e64ce9b, 0x6647079a, 0x43fcf241, 0x2d30ec2c, 0x088b19f7, 0xd89b08df, 0xfd20fd04, 0x93ece369, 0xb65716b2, 0x4e74dfb3, 0x6bcf2a68, 0x05033405, 0x20b8c1de, 0x4472b7b9, 0x61c94262, 0x0f055c0f, 0x2abea9d4, 0xd29d60d5, 0xf726950e, 0x99ea8b63, 0xbc517eb8, 0x6c416f90, 0x49fa9a4b, 0x27368426, 0x028d71fd, 0xfaaeb8fc, 0xdf154d27, 0xb1d9534a, 0x9462a691, 0x141507eb, 0x31aef230, 0x5f62ec5d, 0x7ad91986, 0x82fad087, 0xa741255c, 0xc98d3b31, 0xec36ceea, 0x3c26dfc2, 0x199d2a19, 0x77513474, 0x52eac1af, 0xaac908ae, 0x8f72fd75, 0xe1bee318, 0xc40516c3, 0xe4bdd71d, 0xc10622c6, 0xafca3cab, 0x8a71c970, 0x72520071, 0x57e9f5aa, 0x3925ebc7, 0x1c9e1e1c, 0xcc8e0f34, 0xe935faef, 0x87f9e482, 0xa2421159, 0x5a61d858, 0x7fda2d83, 0x111633ee, 0x34adc635, 0xb4da674f, 0x91619294, 0xffad8cf9, 0xda167922, 0x2235b023, 0x078e45f8, 0x69425b95, 0x4cf9ae4e, 0x9ce9bf66, 0xb9524abd, 0xd79e54d0, 0xf225a10b, 0x0a06680a, 0x2fbd9dd1, 0x417183bc, 0x64ca7667, 0x88e56f72, 0xad5e9aa9, 0xc39284c4, 0xe629711f, 0x1e0ab81e, 0x3bb14dc5, 0x557d53a8, 0x70c6a673, 0xa0d6b75b, 0x856d4280, 0xeba15ced, 0xce1aa936, 0x36396037, 0x138295ec, 0x7d4e8b81, 0x58f57e5a, 0xd882df20, 0xfd392afb, 0x93f53496, 0xb64ec14d, 0x4e6d084c, 0x6bd6fd97, 0x051ae3fa, 0x20a11621, 0xf0b10709, 0xd50af2d2, 0xbbc6ecbf, 0x9e7d1964, 0x665ed065, 0x43e525be, 0x2d293bd3, 0x0892ce08, 0x282a0fd6, 0x0d91fa0d, 0x635de460, 0x46e611bb, 0xbec5d8ba, 0x9b7e2d61, 0xf5b2330c, 0xd009c6d7, 0x0019d7ff, 0x25a22224, 0x4b6e3c49, 0x6ed5c992, 0x96f60093, 0xb34df548, 0xdd81eb25, 0xf83a1efe, 0x784dbf84, 0x5df64a5f, 0x333a5432, 0x1681a1e9, 0xeea268e8, 0xcb199d33, 0xa5d5835e, 0x806e7685, 0x507e67ad, 0x75c59276, 0x1b098c1b, 0x3eb279c0, 0xc691b0c1, 0xe32a451a, 0x8de65b77, 0xa85daeac, 0xcc97d8cb, 0xe92c2d10, 0x87e0337d, 0xa25bc6a6, 0x5a780fa7, 0x7fc3fa7c, 0x110fe411, 0x34b411ca, 0xe4a400e2, 0xc11ff539, 0xafd3eb54, 0x8a681e8f, 0x724bd78e, 0x57f02255, 0x393c3c38, 0x1c87c9e3, 0x9cf06899, 0xb94b9d42, 0xd787832f, 0xf23c76f4, 0x0a1fbff5, 0x2fa44a2e, 0x41685443, 0x64d3a198, 0xb4c3b0b0, 0x9178456b, 0xffb45b06, 0xda0faedd, 0x222c67dc, 0x07979207, 0x695b8c6a, 0x4ce079b1, 0x6c58b86f, 0x49e34db4, 0x272f53d9, 0x0294a602, 0xfab76f03, 0xdf0c9ad8, 0xb1c084b5, 0x947b716e, 0x446b6046, 0x61d0959d, 0x0f1c8bf0, 0x2aa77e2b, 0xd284b72a, 0xf73f42f1, 0x99f35c9c, 0xbc48a947, 0x3c3f083d, 0x1984fde6, 0x7748e38b, 0x52f31650, 0xaad0df51, 0x8f6b2a8a, 0xe1a734e7, 0xc41cc13c, 0x140cd014, 0x31b725cf, 0x5f7b3ba2, 0x7ac0ce79, 0x82e30778, 0xa758f2a3, 0xc994ecce, 0xec2f1915 }
+};
diff --git a/packages/LevelDB.1.16.0.5/LevelDB.1.16.0.5.nupkg b/packages/LevelDB.1.16.0.5/LevelDB.1.16.0.5.nupkg
new file mode 100644
index 0000000000000000000000000000000000000000..1edb7a7e55ab493f1200231f49bbe10978de2705
GIT binary patch
literal 201019
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%0D>4dEO;z`%98
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
U=$}ZW<?!D$1fE!X2VEBF-zGbO>;M1&

literal 0
HcmV?d00001

diff --git a/packages/LevelDB.1.16.0.5/LevelDB.1.16.0.5.nuspec b/packages/LevelDB.1.16.0.5/LevelDB.1.16.0.5.nuspec
new file mode 100644
index 0000000..f287451
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/LevelDB.1.16.0.5.nuspec
@@ -0,0 +1,22 @@
+<?xml version="1.0"?>
+<package xmlns="http://schemas.microsoft.com/packaging/2011/08/nuspec.xsd">
+  <metadata>
+    <id>LevelDB</id>
+    <version>1.16.0.5</version>
+    <title>LevelDB for C++</title>
+    <authors>Robert Važan</authors>
+    <owners>Robert Važan</owners>
+    <licenseUrl>http://leveldb.angeloflogic.com/license/</licenseUrl>
+    <projectUrl>http://leveldb.angeloflogic.com/</projectUrl>
+    <iconUrl>http://leveldb.angeloflogic.com/images/nuget-icon.png</iconUrl>
+    <requireLicenseAcceptance>false</requireLicenseAcceptance>
+    <description>LevelDB is an embedded key-value database with fast random writes and fast reads of key ranges. This is a source code package that embeds LevelDB into your project.</description>
+    <releaseNotes>Initial release.</releaseNotes>
+    <copyright>Copyright (C) 2011-2014 Robert Vazan &amp; upstream LevelDB developers</copyright>
+    <tags>leveldb nosql database data fast native</tags>
+    <dependencies>
+      <dependency id="Crc32C" version="1.0.4" />
+      <dependency id="Snappy" version="1.1.1.7" />
+    </dependencies>
+  </metadata>
+</package>
\ No newline at end of file
diff --git a/packages/LevelDB.1.16.0.5/build/native/LevelDB.props b/packages/LevelDB.1.16.0.5/build/native/LevelDB.props
new file mode 100644
index 0000000..11f8a7b
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/build/native/LevelDB.props
@@ -0,0 +1,18 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <PreprocessorDefinitions>LEVELDB_STATIC;LEVELDB_PLATFORM_WINDOWS;LEVELDB_WITH_SNAPPY;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(MSBuildThisFileDirectory)..\..\lib\native\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\lib\native\src\leveldb-single-file.cpp">
+      <AdditionalIncludeDirectories>$(MSBuildThisFileDirectory)..\..\lib\native\src\port\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/c.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/c.h
new file mode 100644
index 0000000..43f9d6c
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/c.h
@@ -0,0 +1,302 @@
+/* Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+  Use of this source code is governed by a BSD-style license that can be
+  found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+  C bindings for leveldb.  May be useful as a stable ABI that can be
+  used by programs that keep leveldb in a shared library, or for
+  a JNI api.
+
+  Does not support:
+  . getters for the option types
+  . custom comparators that implement key shortening
+  . custom iter, db, env, cache implementations using just the C bindings
+
+  Some conventions:
+
+  (1) We expose just opaque struct pointers and functions to clients.
+  This allows us to change internal representations without having to
+  recompile clients.
+
+  (2) For simplicity, there is no equivalent to the Slice type.  Instead,
+  the caller has to pass the pointer and length as separate
+  arguments.
+
+  (3) Errors are represented by a null-terminated c string.  NULL
+  means no error.  All operations that can raise an error are passed
+  a "char** errptr" as the last argument.  One of the following must
+  be true on entry:
+     *errptr == NULL
+     *errptr points to a malloc()ed null-terminated error message
+       (On Windows, *errptr must have been malloc()-ed by this library.)
+  On success, a leveldb routine leaves *errptr unchanged.
+  On failure, leveldb frees the old value of *errptr and
+  set *errptr to a malloc()ed error message.
+
+  (4) Bools have the type unsigned char (0 == false; rest == true)
+
+  (5) All of the pointer arguments must be non-NULL.
+*/
+
+#ifndef STORAGE_LEVELDB_INCLUDE_C_H_
+#define STORAGE_LEVELDB_INCLUDE_C_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#ifndef LEVELDB_STATIC
+#ifdef LEVELDB_EXPORTS
+#define LEVELDB_API __declspec(dllexport)
+#else
+#define LEVELDB_API __declspec(dllimport)
+#endif
+#else
+#define LEVELDB_API
+#endif
+
+/* Exported types */
+
+typedef struct leveldb_t               leveldb_t;
+typedef struct leveldb_cache_t         leveldb_cache_t;
+typedef struct leveldb_comparator_t    leveldb_comparator_t;
+typedef struct leveldb_env_t           leveldb_env_t;
+typedef struct leveldb_filelock_t      leveldb_filelock_t;
+typedef struct leveldb_filterpolicy_t  leveldb_filterpolicy_t;
+typedef struct leveldb_iterator_t      leveldb_iterator_t;
+typedef struct leveldb_logger_t        leveldb_logger_t;
+typedef struct leveldb_options_t       leveldb_options_t;
+typedef struct leveldb_randomfile_t    leveldb_randomfile_t;
+typedef struct leveldb_readoptions_t   leveldb_readoptions_t;
+typedef struct leveldb_seqfile_t       leveldb_seqfile_t;
+typedef struct leveldb_snapshot_t      leveldb_snapshot_t;
+typedef struct leveldb_writablefile_t  leveldb_writablefile_t;
+typedef struct leveldb_writebatch_t    leveldb_writebatch_t;
+typedef struct leveldb_writeoptions_t  leveldb_writeoptions_t;
+
+/* DB operations */
+
+extern LEVELDB_API leveldb_t* leveldb_open(
+    const leveldb_options_t* options,
+    const char* name,
+    char** errptr);
+
+extern LEVELDB_API void leveldb_close(leveldb_t* db);
+
+extern LEVELDB_API void leveldb_put(
+    leveldb_t* db,
+    const leveldb_writeoptions_t* options,
+    const char* key, size_t keylen,
+    const char* val, size_t vallen,
+    char** errptr);
+
+extern LEVELDB_API void leveldb_delete(
+    leveldb_t* db,
+    const leveldb_writeoptions_t* options,
+    const char* key, size_t keylen,
+    char** errptr);
+
+extern LEVELDB_API void leveldb_write(
+    leveldb_t* db,
+    const leveldb_writeoptions_t* options,
+    leveldb_writebatch_t* batch,
+    char** errptr);
+
+/* Returns NULL if not found.  A malloc()ed array otherwise.
+   Stores the length of the array in *vallen. */
+extern LEVELDB_API char* leveldb_get(
+    leveldb_t* db,
+    const leveldb_readoptions_t* options,
+    const char* key, size_t keylen,
+    size_t* vallen,
+    char** errptr);
+
+extern LEVELDB_API leveldb_iterator_t* leveldb_create_iterator(
+    leveldb_t* db,
+    const leveldb_readoptions_t* options);
+
+extern LEVELDB_API const leveldb_snapshot_t* leveldb_create_snapshot(
+    leveldb_t* db);
+
+extern LEVELDB_API void leveldb_release_snapshot(
+    leveldb_t* db,
+    const leveldb_snapshot_t* snapshot);
+
+/* Returns NULL if property name is unknown.
+   Else returns a pointer to a malloc()-ed null-terminated value. */
+extern LEVELDB_API char* leveldb_property_value(
+    leveldb_t* db,
+    const char* propname);
+
+extern LEVELDB_API void leveldb_approximate_sizes(
+    leveldb_t* db,
+    int num_ranges,
+    const char* const* range_start_key, const size_t* range_start_key_len,
+    const char* const* range_limit_key, const size_t* range_limit_key_len,
+    uint64_t* sizes);
+
+extern LEVELDB_API void leveldb_compact_range(
+    leveldb_t* db,
+    const char* start_key, size_t start_key_len,
+    const char* limit_key, size_t limit_key_len);
+
+/* Management operations */
+
+extern LEVELDB_API void leveldb_destroy_db(
+    const leveldb_options_t* options,
+    const char* name,
+    char** errptr);
+
+extern LEVELDB_API void leveldb_repair_db(
+    const leveldb_options_t* options,
+    const char* name,
+    char** errptr);
+
+/* Iterator */
+
+extern LEVELDB_API void leveldb_iter_destroy(leveldb_iterator_t*);
+extern LEVELDB_API unsigned char leveldb_iter_valid(const leveldb_iterator_t*);
+extern LEVELDB_API void leveldb_iter_seek_to_first(leveldb_iterator_t*);
+extern LEVELDB_API void leveldb_iter_seek_to_last(leveldb_iterator_t*);
+extern LEVELDB_API void leveldb_iter_seek(leveldb_iterator_t*, const char* k, size_t klen);
+extern LEVELDB_API void leveldb_iter_next(leveldb_iterator_t*);
+extern LEVELDB_API void leveldb_iter_prev(leveldb_iterator_t*);
+extern LEVELDB_API const char* leveldb_iter_key(const leveldb_iterator_t*, size_t* klen);
+extern LEVELDB_API const char* leveldb_iter_value(const leveldb_iterator_t*, size_t* vlen);
+extern LEVELDB_API void leveldb_iter_get_error(const leveldb_iterator_t*, char** errptr);
+
+/* Write batch */
+
+extern LEVELDB_API leveldb_writebatch_t* leveldb_writebatch_create();
+extern LEVELDB_API void leveldb_writebatch_destroy(leveldb_writebatch_t*);
+extern LEVELDB_API void leveldb_writebatch_clear(leveldb_writebatch_t*);
+extern LEVELDB_API void leveldb_writebatch_put(
+    leveldb_writebatch_t*,
+    const char* key, size_t klen,
+    const char* val, size_t vlen);
+extern LEVELDB_API void leveldb_writebatch_delete(
+    leveldb_writebatch_t*,
+    const char* key, size_t klen);
+extern LEVELDB_API void leveldb_writebatch_iterate(
+    leveldb_writebatch_t*,
+    void* state,
+    void (*put)(void*, const char* k, size_t klen, const char* v, size_t vlen),
+    void (*deleted)(void*, const char* k, size_t klen));
+
+/* Options */
+
+extern LEVELDB_API leveldb_options_t* leveldb_options_create();
+extern LEVELDB_API void leveldb_options_destroy(leveldb_options_t*);
+extern LEVELDB_API void leveldb_options_set_comparator(
+    leveldb_options_t*,
+    leveldb_comparator_t*);
+extern LEVELDB_API void leveldb_options_set_filter_policy(
+    leveldb_options_t*,
+    leveldb_filterpolicy_t*);
+extern LEVELDB_API void leveldb_options_set_create_if_missing(
+    leveldb_options_t*, unsigned char);
+extern LEVELDB_API void leveldb_options_set_error_if_exists(
+    leveldb_options_t*, unsigned char);
+extern LEVELDB_API void leveldb_options_set_paranoid_checks(
+    leveldb_options_t*, unsigned char);
+extern LEVELDB_API void leveldb_options_set_env(leveldb_options_t*, leveldb_env_t*);
+extern LEVELDB_API void leveldb_options_set_info_log(leveldb_options_t*, leveldb_logger_t*);
+extern LEVELDB_API void leveldb_options_set_write_buffer_size(leveldb_options_t*, size_t);
+extern LEVELDB_API void leveldb_options_set_max_open_files(leveldb_options_t*, int);
+extern LEVELDB_API void leveldb_options_set_cache(leveldb_options_t*, leveldb_cache_t*);
+extern LEVELDB_API void leveldb_options_set_block_size(leveldb_options_t*, size_t);
+extern LEVELDB_API void leveldb_options_set_block_restart_interval(leveldb_options_t*, int);
+
+enum {
+  leveldb_no_compression = 0,
+  leveldb_snappy_compression = 1
+};
+extern LEVELDB_API void leveldb_options_set_compression(leveldb_options_t*, int);
+
+/* Comparator */
+
+extern LEVELDB_API leveldb_comparator_t* leveldb_comparator_create(
+    void* state,
+    void (*destructor)(void*),
+    int (*compare)(
+        void*,
+        const char* a, size_t alen,
+        const char* b, size_t blen),
+    const char* (*name)(void*));
+extern LEVELDB_API void leveldb_comparator_destroy(leveldb_comparator_t*);
+
+/* Filter policy */
+
+extern LEVELDB_API leveldb_filterpolicy_t* leveldb_filterpolicy_create(
+    void* state,
+    void (*destructor)(void*),
+    char* (*create_filter)(
+        void*,
+        const char* const* key_array, const size_t* key_length_array,
+        int num_keys,
+        size_t* filter_length),
+    unsigned char (*key_may_match)(
+        void*,
+        const char* key, size_t length,
+        const char* filter, size_t filter_length),
+    const char* (*name)(void*));
+extern LEVELDB_API void leveldb_filterpolicy_destroy(leveldb_filterpolicy_t*);
+
+extern LEVELDB_API leveldb_filterpolicy_t* leveldb_filterpolicy_create_bloom(
+    int bits_per_key);
+
+/* Read options */
+
+extern LEVELDB_API leveldb_readoptions_t* leveldb_readoptions_create();
+extern LEVELDB_API void leveldb_readoptions_destroy(leveldb_readoptions_t*);
+extern LEVELDB_API void leveldb_readoptions_set_verify_checksums(
+    leveldb_readoptions_t*,
+    unsigned char);
+extern LEVELDB_API void leveldb_readoptions_set_fill_cache(
+    leveldb_readoptions_t*, unsigned char);
+extern LEVELDB_API void leveldb_readoptions_set_snapshot(
+    leveldb_readoptions_t*,
+    const leveldb_snapshot_t*);
+
+/* Write options */
+
+extern LEVELDB_API leveldb_writeoptions_t* leveldb_writeoptions_create();
+extern LEVELDB_API void leveldb_writeoptions_destroy(leveldb_writeoptions_t*);
+extern LEVELDB_API void leveldb_writeoptions_set_sync(
+    leveldb_writeoptions_t*, unsigned char);
+
+/* Cache */
+
+extern LEVELDB_API leveldb_cache_t* leveldb_cache_create_lru(size_t capacity);
+extern LEVELDB_API void leveldb_cache_destroy(leveldb_cache_t* cache);
+
+/* Env */
+
+extern LEVELDB_API leveldb_env_t* leveldb_create_default_env();
+extern LEVELDB_API void leveldb_env_destroy(leveldb_env_t*);
+
+/* Utility */
+
+/* Calls free(ptr).
+   REQUIRES: ptr was malloc()-ed and returned by one of the routines
+   in this file.  Note that in certain cases (typically on Windows), you
+   may need to call this routine instead of free(ptr) to dispose of
+   malloc()-ed memory returned by this library. */
+extern LEVELDB_API void leveldb_free(void* ptr);
+
+/* Return the major version number for this release. */
+extern LEVELDB_API int leveldb_major_version();
+
+/* Return the minor version number for this release. */
+extern LEVELDB_API int leveldb_minor_version();
+
+extern LEVELDB_API int leveldb_benchmark(int argc, char** argv);
+
+#ifdef __cplusplus
+}  /* end extern "C" */
+#endif
+
+#endif  /* STORAGE_LEVELDB_INCLUDE_C_H_ */
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/cache.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/cache.h
new file mode 100644
index 0000000..5e3b476
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/cache.h
@@ -0,0 +1,99 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// A Cache is an interface that maps keys to values.  It has internal
+// synchronization and may be safely accessed concurrently from
+// multiple threads.  It may automatically evict entries to make room
+// for new entries.  Values have a specified charge against the cache
+// capacity.  For example, a cache where the values are variable
+// length strings, may use the length of the string as the charge for
+// the string.
+//
+// A builtin cache implementation with a least-recently-used eviction
+// policy is provided.  Clients may use their own implementations if
+// they want something more sophisticated (like scan-resistance, a
+// custom eviction policy, variable cache sizing, etc.)
+
+#ifndef STORAGE_LEVELDB_INCLUDE_CACHE_H_
+#define STORAGE_LEVELDB_INCLUDE_CACHE_H_
+
+#include <stdint.h>
+#include "leveldb/slice.h"
+
+namespace leveldb {
+
+class Cache;
+
+// Create a new cache with a fixed size capacity.  This implementation
+// of Cache uses a least-recently-used eviction policy.
+extern Cache* NewLRUCache(size_t capacity);
+
+class Cache {
+ public:
+  Cache() { }
+
+  // Destroys all existing entries by calling the "deleter"
+  // function that was passed to the constructor.
+  virtual ~Cache();
+
+  // Opaque handle to an entry stored in the cache.
+  struct Handle { };
+
+  // Insert a mapping from key->value into the cache and assign it
+  // the specified charge against the total cache capacity.
+  //
+  // Returns a handle that corresponds to the mapping.  The caller
+  // must call this->Release(handle) when the returned mapping is no
+  // longer needed.
+  //
+  // When the inserted entry is no longer needed, the key and
+  // value will be passed to "deleter".
+  virtual Handle* Insert(const Slice& key, void* value, size_t charge,
+                         void (*deleter)(const Slice& key, void* value)) = 0;
+
+  // If the cache has no mapping for "key", returns NULL.
+  //
+  // Else return a handle that corresponds to the mapping.  The caller
+  // must call this->Release(handle) when the returned mapping is no
+  // longer needed.
+  virtual Handle* Lookup(const Slice& key) = 0;
+
+  // Release a mapping returned by a previous Lookup().
+  // REQUIRES: handle must not have been released yet.
+  // REQUIRES: handle must have been returned by a method on *this.
+  virtual void Release(Handle* handle) = 0;
+
+  // Return the value encapsulated in a handle returned by a
+  // successful Lookup().
+  // REQUIRES: handle must not have been released yet.
+  // REQUIRES: handle must have been returned by a method on *this.
+  virtual void* Value(Handle* handle) = 0;
+
+  // If the cache contains entry for key, erase it.  Note that the
+  // underlying entry will be kept around until all existing handles
+  // to it have been released.
+  virtual void Erase(const Slice& key) = 0;
+
+  // Return a new numeric id.  May be used by multiple clients who are
+  // sharing the same cache to partition the key space.  Typically the
+  // client will allocate a new id at startup and prepend the id to
+  // its cache keys.
+  virtual uint64_t NewId() = 0;
+
+ private:
+  void LRU_Remove(Handle* e);
+  void LRU_Append(Handle* e);
+  void Unref(Handle* e);
+
+  struct Rep;
+  Rep* rep_;
+
+  // No copying allowed
+  Cache(const Cache&);
+  void operator=(const Cache&);
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_UTIL_CACHE_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/comparator.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/comparator.h
new file mode 100644
index 0000000..556b984
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/comparator.h
@@ -0,0 +1,63 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_INCLUDE_COMPARATOR_H_
+#define STORAGE_LEVELDB_INCLUDE_COMPARATOR_H_
+
+#include <string>
+
+namespace leveldb {
+
+class Slice;
+
+// A Comparator object provides a total order across slices that are
+// used as keys in an sstable or a database.  A Comparator implementation
+// must be thread-safe since leveldb may invoke its methods concurrently
+// from multiple threads.
+class Comparator {
+ public:
+  virtual ~Comparator();
+
+  // Three-way comparison.  Returns value:
+  //   < 0 iff "a" < "b",
+  //   == 0 iff "a" == "b",
+  //   > 0 iff "a" > "b"
+  virtual int Compare(const Slice& a, const Slice& b) const = 0;
+
+  // The name of the comparator.  Used to check for comparator
+  // mismatches (i.e., a DB created with one comparator is
+  // accessed using a different comparator.
+  //
+  // The client of this package should switch to a new name whenever
+  // the comparator implementation changes in a way that will cause
+  // the relative ordering of any two keys to change.
+  //
+  // Names starting with "leveldb." are reserved and should not be used
+  // by any clients of this package.
+  virtual const char* Name() const = 0;
+
+  // Advanced functions: these are used to reduce the space requirements
+  // for internal data structures like index blocks.
+
+  // If *start < limit, changes *start to a short string in [start,limit).
+  // Simple comparator implementations may return with *start unchanged,
+  // i.e., an implementation of this method that does nothing is correct.
+  virtual void FindShortestSeparator(
+      std::string* start,
+      const Slice& limit) const = 0;
+
+  // Changes *key to a short string >= *key.
+  // Simple comparator implementations may return with *key unchanged,
+  // i.e., an implementation of this method that does nothing is correct.
+  virtual void FindShortSuccessor(std::string* key) const = 0;
+};
+
+// Return a builtin comparator that uses lexicographic byte-wise
+// ordering.  The result remains the property of this module and
+// must not be deleted.
+extern const Comparator* BytewiseComparator();
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_INCLUDE_COMPARATOR_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/db.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/db.h
new file mode 100644
index 0000000..463b1ef
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/db.h
@@ -0,0 +1,166 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_INCLUDE_DB_H_
+#define STORAGE_LEVELDB_INCLUDE_DB_H_
+
+#include <stdint.h>
+#include <stdio.h>
+#include "leveldb/iterator.h"
+#include "leveldb/options.h"
+
+#define LEVELDB_VERSION_MAJOR 1
+#define LEVELDB_VERSION_MINOR 16
+#define LEVELDB_VERSION_PATCH 0
+#define LEVELDB_VERSION_STRING "1.16.0.0"
+
+namespace leveldb {
+
+// Update Makefile if you change these
+static const int kMajorVersion = LEVELDB_VERSION_MAJOR;
+static const int kMinorVersion = LEVELDB_VERSION_MINOR;
+
+struct Options;
+struct ReadOptions;
+struct WriteOptions;
+class WriteBatch;
+
+// Abstract handle to particular state of a DB.
+// A Snapshot is an immutable object and can therefore be safely
+// accessed from multiple threads without any external synchronization.
+class Snapshot {
+ protected:
+  virtual ~Snapshot();
+};
+
+// A range of keys
+struct Range {
+  Slice start;          // Included in the range
+  Slice limit;          // Not included in the range
+
+  Range() { }
+  Range(const Slice& s, const Slice& l) : start(s), limit(l) { }
+};
+
+// A DB is a persistent ordered map from keys to values.
+// A DB is safe for concurrent access from multiple threads without
+// any external synchronization.
+class DB {
+ public:
+  // Open the database with the specified "name".
+  // Stores a pointer to a heap-allocated database in *dbptr and returns
+  // OK on success.
+  // Stores NULL in *dbptr and returns a non-OK status on error.
+  // Caller should delete *dbptr when it is no longer needed.
+  static Status Open(const Options& options,
+                     const std::string& name,
+                     DB** dbptr);
+
+  DB() { }
+  virtual ~DB();
+
+  // Set the database entry for "key" to "value".  Returns OK on success,
+  // and a non-OK status on error.
+  // Note: consider setting options.sync = true.
+  virtual Status Put(const WriteOptions& options,
+                     const Slice& key,
+                     const Slice& value) = 0;
+
+  // Remove the database entry (if any) for "key".  Returns OK on
+  // success, and a non-OK status on error.  It is not an error if "key"
+  // did not exist in the database.
+  // Note: consider setting options.sync = true.
+  virtual Status Delete(const WriteOptions& options, const Slice& key) = 0;
+
+  // Apply the specified updates to the database.
+  // Returns OK on success, non-OK on failure.
+  // Note: consider setting options.sync = true.
+  virtual Status Write(const WriteOptions& options, WriteBatch* updates) = 0;
+
+  // If the database contains an entry for "key" store the
+  // corresponding value in *value and return OK.
+  //
+  // If there is no entry for "key" leave *value unchanged and return
+  // a status for which Status::IsNotFound() returns true.
+  //
+  // May return some other Status on an error.
+  virtual Status Get(const ReadOptions& options,
+                     const Slice& key, std::string* value) = 0;
+
+  // Return a heap-allocated iterator over the contents of the database.
+  // The result of NewIterator() is initially invalid (caller must
+  // call one of the Seek methods on the iterator before using it).
+  //
+  // Caller should delete the iterator when it is no longer needed.
+  // The returned iterator should be deleted before this db is deleted.
+  virtual Iterator* NewIterator(const ReadOptions& options) = 0;
+
+  // Return a handle to the current DB state.  Iterators created with
+  // this handle will all observe a stable snapshot of the current DB
+  // state.  The caller must call ReleaseSnapshot(result) when the
+  // snapshot is no longer needed.
+  virtual const Snapshot* GetSnapshot() = 0;
+
+  // Release a previously acquired snapshot.  The caller must not
+  // use "snapshot" after this call.
+  virtual void ReleaseSnapshot(const Snapshot* snapshot) = 0;
+
+  // DB implementations can export properties about their state
+  // via this method.  If "property" is a valid property understood by this
+  // DB implementation, fills "*value" with its current value and returns
+  // true.  Otherwise returns false.
+  //
+  //
+  // Valid property names include:
+  //
+  //  "leveldb.num-files-at-level<N>" - return the number of files at level <N>,
+  //     where <N> is an ASCII representation of a level number (e.g. "0").
+  //  "leveldb.stats" - returns a multi-line string that describes statistics
+  //     about the internal operation of the DB.
+  //  "leveldb.sstables" - returns a multi-line string that describes all
+  //     of the sstables that make up the db contents.
+  virtual bool GetProperty(const Slice& property, std::string* value) = 0;
+
+  // For each i in [0,n-1], store in "sizes[i]", the approximate
+  // file system space used by keys in "[range[i].start .. range[i].limit)".
+  //
+  // Note that the returned sizes measure file system space usage, so
+  // if the user data compresses by a factor of ten, the returned
+  // sizes will be one-tenth the size of the corresponding user data size.
+  //
+  // The results may not include the sizes of recently written data.
+  virtual void GetApproximateSizes(const Range* range, int n,
+                                   uint64_t* sizes) = 0;
+
+  // Compact the underlying storage for the key range [*begin,*end].
+  // In particular, deleted and overwritten versions are discarded,
+  // and the data is rearranged to reduce the cost of operations
+  // needed to access the data.  This operation should typically only
+  // be invoked by users who understand the underlying implementation.
+  //
+  // begin==NULL is treated as a key before all keys in the database.
+  // end==NULL is treated as a key after all keys in the database.
+  // Therefore the following call will compact the entire database:
+  //    db->CompactRange(NULL, NULL);
+  virtual void CompactRange(const Slice* begin, const Slice* end) = 0;
+
+ private:
+  // No copying allowed
+  DB(const DB&);
+  void operator=(const DB&);
+};
+
+// Destroy the contents of the specified database.
+// Be very careful using this method.
+Status DestroyDB(const std::string& name, const Options& options);
+
+// If a DB cannot be opened, you may attempt to call this method to
+// resurrect as much of the contents of the database as possible.
+// Some data may be lost, so be careful when calling this function
+// on a database that contains important information.
+Status RepairDB(const std::string& dbname, const Options& options);
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_INCLUDE_DB_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/env.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/env.h
new file mode 100644
index 0000000..b2072d0
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/env.h
@@ -0,0 +1,333 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// An Env is an interface used by the leveldb implementation to access
+// operating system functionality like the filesystem etc.  Callers
+// may wish to provide a custom Env object when opening a database to
+// get fine gain control; e.g., to rate limit file system operations.
+//
+// All Env implementations are safe for concurrent access from
+// multiple threads without any external synchronization.
+
+#ifndef STORAGE_LEVELDB_INCLUDE_ENV_H_
+#define STORAGE_LEVELDB_INCLUDE_ENV_H_
+
+#include <string>
+#include <vector>
+#include <stdarg.h>
+#include <stdint.h>
+#include "leveldb/status.h"
+
+namespace leveldb {
+
+class FileLock;
+class Logger;
+class RandomAccessFile;
+class SequentialFile;
+class Slice;
+class WritableFile;
+
+class Env {
+ public:
+  Env() { }
+  virtual ~Env();
+
+  // Return a default environment suitable for the current operating
+  // system.  Sophisticated users may wish to provide their own Env
+  // implementation instead of relying on this default environment.
+  //
+  // The result of Default() belongs to leveldb and must never be deleted.
+  static Env* Default();
+
+  // Create a brand new sequentially-readable file with the specified name.
+  // On success, stores a pointer to the new file in *result and returns OK.
+  // On failure stores NULL in *result and returns non-OK.  If the file does
+  // not exist, returns a non-OK status.
+  //
+  // The returned file will only be accessed by one thread at a time.
+  virtual Status NewSequentialFile(const std::string& fname,
+                                   SequentialFile** result) = 0;
+
+  // Create a brand new random access read-only file with the
+  // specified name.  On success, stores a pointer to the new file in
+  // *result and returns OK.  On failure stores NULL in *result and
+  // returns non-OK.  If the file does not exist, returns a non-OK
+  // status.
+  //
+  // The returned file may be concurrently accessed by multiple threads.
+  virtual Status NewRandomAccessFile(const std::string& fname,
+                                     RandomAccessFile** result) = 0;
+
+  // Create an object that writes to a new file with the specified
+  // name.  Deletes any existing file with the same name and creates a
+  // new file.  On success, stores a pointer to the new file in
+  // *result and returns OK.  On failure stores NULL in *result and
+  // returns non-OK.
+  //
+  // The returned file will only be accessed by one thread at a time.
+  virtual Status NewWritableFile(const std::string& fname,
+                                 WritableFile** result) = 0;
+
+  // Returns true iff the named file exists.
+  virtual bool FileExists(const std::string& fname) = 0;
+
+  // Store in *result the names of the children of the specified directory.
+  // The names are relative to "dir".
+  // Original contents of *results are dropped.
+  virtual Status GetChildren(const std::string& dir,
+                             std::vector<std::string>* result) = 0;
+
+  // Delete the named file.
+  virtual Status DeleteFile(const std::string& fname) = 0;
+
+  // Create the specified directory.
+  virtual Status CreateDir(const std::string& dirname) = 0;
+
+  // Delete the specified directory.
+  virtual Status DeleteDir(const std::string& dirname) = 0;
+
+  // Store the size of fname in *file_size.
+  virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) = 0;
+
+  // Rename file src to target.
+  virtual Status RenameFile(const std::string& src,
+                            const std::string& target) = 0;
+
+  // Lock the specified file.  Used to prevent concurrent access to
+  // the same db by multiple processes.  On failure, stores NULL in
+  // *lock and returns non-OK.
+  //
+  // On success, stores a pointer to the object that represents the
+  // acquired lock in *lock and returns OK.  The caller should call
+  // UnlockFile(*lock) to release the lock.  If the process exits,
+  // the lock will be automatically released.
+  //
+  // If somebody else already holds the lock, finishes immediately
+  // with a failure.  I.e., this call does not wait for existing locks
+  // to go away.
+  //
+  // May create the named file if it does not already exist.
+  virtual Status LockFile(const std::string& fname, FileLock** lock) = 0;
+
+  // Release the lock acquired by a previous successful call to LockFile.
+  // REQUIRES: lock was returned by a successful LockFile() call
+  // REQUIRES: lock has not already been unlocked.
+  virtual Status UnlockFile(FileLock* lock) = 0;
+
+  // Arrange to run "(*function)(arg)" once in a background thread.
+  //
+  // "function" may run in an unspecified thread.  Multiple functions
+  // added to the same Env may run concurrently in different threads.
+  // I.e., the caller may not assume that background work items are
+  // serialized.
+  virtual void Schedule(
+      void (*function)(void* arg),
+      void* arg) = 0;
+
+  // Start a new thread, invoking "function(arg)" within the new thread.
+  // When "function(arg)" returns, the thread will be destroyed.
+  virtual void StartThread(void (*function)(void* arg), void* arg) = 0;
+
+  // *path is set to a temporary directory that can be used for testing. It may
+  // or many not have just been created. The directory may or may not differ
+  // between runs of the same process, but subsequent calls will return the
+  // same directory.
+  virtual Status GetTestDirectory(std::string* path) = 0;
+
+  // Create and return a log file for storing informational messages.
+  virtual Status NewLogger(const std::string& fname, Logger** result) = 0;
+
+  // Returns the number of micro-seconds since some fixed point in time. Only
+  // useful for computing deltas of time.
+  virtual uint64_t NowMicros() = 0;
+
+  // Sleep/delay the thread for the perscribed number of micro-seconds.
+  virtual void SleepForMicroseconds(int micros) = 0;
+
+ private:
+  // No copying allowed
+  Env(const Env&);
+  void operator=(const Env&);
+};
+
+// A file abstraction for reading sequentially through a file
+class SequentialFile {
+ public:
+  SequentialFile() { }
+  virtual ~SequentialFile();
+
+  // Read up to "n" bytes from the file.  "scratch[0..n-1]" may be
+  // written by this routine.  Sets "*result" to the data that was
+  // read (including if fewer than "n" bytes were successfully read).
+  // May set "*result" to point at data in "scratch[0..n-1]", so
+  // "scratch[0..n-1]" must be live when "*result" is used.
+  // If an error was encountered, returns a non-OK status.
+  //
+  // REQUIRES: External synchronization
+  virtual Status Read(size_t n, Slice* result, char* scratch) = 0;
+
+  // Skip "n" bytes from the file. This is guaranteed to be no
+  // slower that reading the same data, but may be faster.
+  //
+  // If end of file is reached, skipping will stop at the end of the
+  // file, and Skip will return OK.
+  //
+  // REQUIRES: External synchronization
+  virtual Status Skip(uint64_t n) = 0;
+
+ private:
+  // No copying allowed
+  SequentialFile(const SequentialFile&);
+  void operator=(const SequentialFile&);
+};
+
+// A file abstraction for randomly reading the contents of a file.
+class RandomAccessFile {
+ public:
+  RandomAccessFile() { }
+  virtual ~RandomAccessFile();
+
+  // Read up to "n" bytes from the file starting at "offset".
+  // "scratch[0..n-1]" may be written by this routine.  Sets "*result"
+  // to the data that was read (including if fewer than "n" bytes were
+  // successfully read).  May set "*result" to point at data in
+  // "scratch[0..n-1]", so "scratch[0..n-1]" must be live when
+  // "*result" is used.  If an error was encountered, returns a non-OK
+  // status.
+  //
+  // Safe for concurrent use by multiple threads.
+  virtual Status Read(uint64_t offset, size_t n, Slice* result,
+                      char* scratch) const = 0;
+
+ private:
+  // No copying allowed
+  RandomAccessFile(const RandomAccessFile&);
+  void operator=(const RandomAccessFile&);
+};
+
+// A file abstraction for sequential writing.  The implementation
+// must provide buffering since callers may append small fragments
+// at a time to the file.
+class WritableFile {
+ public:
+  WritableFile() { }
+  virtual ~WritableFile();
+
+  virtual Status Append(const Slice& data) = 0;
+  virtual Status Close() = 0;
+  virtual Status Flush() = 0;
+  virtual Status Sync() = 0;
+
+ private:
+  // No copying allowed
+  WritableFile(const WritableFile&);
+  void operator=(const WritableFile&);
+};
+
+// An interface for writing log messages.
+class Logger {
+ public:
+  Logger() { }
+  virtual ~Logger();
+
+  // Write an entry to the log file with the specified format.
+  virtual void Logv(const char* format, va_list ap) = 0;
+
+ private:
+  // No copying allowed
+  Logger(const Logger&);
+  void operator=(const Logger&);
+};
+
+
+// Identifies a locked file.
+class FileLock {
+ public:
+  FileLock() { }
+  virtual ~FileLock();
+ private:
+  // No copying allowed
+  FileLock(const FileLock&);
+  void operator=(const FileLock&);
+};
+
+// Log the specified data to *info_log if info_log is non-NULL.
+extern void Log(Logger* info_log, const char* format, ...)
+#   if defined(__GNUC__) || defined(__clang__)
+    __attribute__((__format__ (__printf__, 2, 3)))
+#   endif
+    ;
+
+// A utility routine: write "data" to the named file.
+extern Status WriteStringToFile(Env* env, const Slice& data,
+                                const std::string& fname);
+
+// A utility routine: read contents of named file into *data
+extern Status ReadFileToString(Env* env, const std::string& fname,
+                               std::string* data);
+
+// An implementation of Env that forwards all calls to another Env.
+// May be useful to clients who wish to override just part of the
+// functionality of another Env.
+class EnvWrapper : public Env {
+ public:
+  // Initialize an EnvWrapper that delegates all calls to *t
+  explicit EnvWrapper(Env* t) : target_(t) { }
+  virtual ~EnvWrapper();
+
+  // Return the target to which this Env forwards all calls
+  Env* target() const { return target_; }
+
+  // The following text is boilerplate that forwards all methods to target()
+  Status NewSequentialFile(const std::string& f, SequentialFile** r) {
+    return target_->NewSequentialFile(f, r);
+  }
+  Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {
+    return target_->NewRandomAccessFile(f, r);
+  }
+  Status NewWritableFile(const std::string& f, WritableFile** r) {
+    return target_->NewWritableFile(f, r);
+  }
+  bool FileExists(const std::string& f) { return target_->FileExists(f); }
+  Status GetChildren(const std::string& dir, std::vector<std::string>* r) {
+    return target_->GetChildren(dir, r);
+  }
+  Status DeleteFile(const std::string& f) { return target_->DeleteFile(f); }
+  Status CreateDir(const std::string& d) { return target_->CreateDir(d); }
+  Status DeleteDir(const std::string& d) { return target_->DeleteDir(d); }
+  Status GetFileSize(const std::string& f, uint64_t* s) {
+    return target_->GetFileSize(f, s);
+  }
+  Status RenameFile(const std::string& s, const std::string& t) {
+    return target_->RenameFile(s, t);
+  }
+  Status LockFile(const std::string& f, FileLock** l) {
+    return target_->LockFile(f, l);
+  }
+  Status UnlockFile(FileLock* l) { return target_->UnlockFile(l); }
+  void Schedule(void (*f)(void*), void* a) {
+    return target_->Schedule(f, a);
+  }
+  void StartThread(void (*f)(void*), void* a) {
+    return target_->StartThread(f, a);
+  }
+  virtual Status GetTestDirectory(std::string* path) {
+    return target_->GetTestDirectory(path);
+  }
+  virtual Status NewLogger(const std::string& fname, Logger** result) {
+    return target_->NewLogger(fname, result);
+  }
+  uint64_t NowMicros() {
+    return target_->NowMicros();
+  }
+  void SleepForMicroseconds(int micros) {
+    target_->SleepForMicroseconds(micros);
+  }
+ private:
+  Env* target_;
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_INCLUDE_ENV_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/filter_policy.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/filter_policy.h
new file mode 100644
index 0000000..1fba080
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/filter_policy.h
@@ -0,0 +1,70 @@
+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// A database can be configured with a custom FilterPolicy object.
+// This object is responsible for creating a small filter from a set
+// of keys.  These filters are stored in leveldb and are consulted
+// automatically by leveldb to decide whether or not to read some
+// information from disk. In many cases, a filter can cut down the
+// number of disk seeks form a handful to a single disk seek per
+// DB::Get() call.
+//
+// Most people will want to use the builtin bloom filter support (see
+// NewBloomFilterPolicy() below).
+
+#ifndef STORAGE_LEVELDB_INCLUDE_FILTER_POLICY_H_
+#define STORAGE_LEVELDB_INCLUDE_FILTER_POLICY_H_
+
+#include <string>
+
+namespace leveldb {
+
+class Slice;
+
+class FilterPolicy {
+ public:
+  virtual ~FilterPolicy();
+
+  // Return the name of this policy.  Note that if the filter encoding
+  // changes in an incompatible way, the name returned by this method
+  // must be changed.  Otherwise, old incompatible filters may be
+  // passed to methods of this type.
+  virtual const char* Name() const = 0;
+
+  // keys[0,n-1] contains a list of keys (potentially with duplicates)
+  // that are ordered according to the user supplied comparator.
+  // Append a filter that summarizes keys[0,n-1] to *dst.
+  //
+  // Warning: do not change the initial contents of *dst.  Instead,
+  // append the newly constructed filter to *dst.
+  virtual void CreateFilter(const Slice* keys, int n, std::string* dst)
+      const = 0;
+
+  // "filter" contains the data appended by a preceding call to
+  // CreateFilter() on this class.  This method must return true if
+  // the key was in the list of keys passed to CreateFilter().
+  // This method may return true or false if the key was not on the
+  // list, but it should aim to return false with a high probability.
+  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const = 0;
+};
+
+// Return a new filter policy that uses a bloom filter with approximately
+// the specified number of bits per key.  A good value for bits_per_key
+// is 10, which yields a filter with ~ 1% false positive rate.
+//
+// Callers must delete the result after any database that is using the
+// result has been closed.
+//
+// Note: if you are using a custom comparator that ignores some parts
+// of the keys being compared, you must not use NewBloomFilterPolicy()
+// and must provide your own FilterPolicy that also ignores the
+// corresponding parts of the keys.  For example, if the comparator
+// ignores trailing spaces, it would be incorrect to use a
+// FilterPolicy (like NewBloomFilterPolicy) that does not ignore
+// trailing spaces in keys.
+extern const FilterPolicy* NewBloomFilterPolicy(int bits_per_key);
+
+}
+
+#endif  // STORAGE_LEVELDB_INCLUDE_FILTER_POLICY_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/iterator.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/iterator.h
new file mode 100644
index 0000000..ad543eb
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/iterator.h
@@ -0,0 +1,100 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// An iterator yields a sequence of key/value pairs from a source.
+// The following class defines the interface.  Multiple implementations
+// are provided by this library.  In particular, iterators are provided
+// to access the contents of a Table or a DB.
+//
+// Multiple threads can invoke const methods on an Iterator without
+// external synchronization, but if any of the threads may call a
+// non-const method, all threads accessing the same Iterator must use
+// external synchronization.
+
+#ifndef STORAGE_LEVELDB_INCLUDE_ITERATOR_H_
+#define STORAGE_LEVELDB_INCLUDE_ITERATOR_H_
+
+#include "leveldb/slice.h"
+#include "leveldb/status.h"
+
+namespace leveldb {
+
+class Iterator {
+ public:
+  Iterator();
+  virtual ~Iterator();
+
+  // An iterator is either positioned at a key/value pair, or
+  // not valid.  This method returns true iff the iterator is valid.
+  virtual bool Valid() const = 0;
+
+  // Position at the first key in the source.  The iterator is Valid()
+  // after this call iff the source is not empty.
+  virtual void SeekToFirst() = 0;
+
+  // Position at the last key in the source.  The iterator is
+  // Valid() after this call iff the source is not empty.
+  virtual void SeekToLast() = 0;
+
+  // Position at the first key in the source that at or past target
+  // The iterator is Valid() after this call iff the source contains
+  // an entry that comes at or past target.
+  virtual void Seek(const Slice& target) = 0;
+
+  // Moves to the next entry in the source.  After this call, Valid() is
+  // true iff the iterator was not positioned at the last entry in the source.
+  // REQUIRES: Valid()
+  virtual void Next() = 0;
+
+  // Moves to the previous entry in the source.  After this call, Valid() is
+  // true iff the iterator was not positioned at the first entry in source.
+  // REQUIRES: Valid()
+  virtual void Prev() = 0;
+
+  // Return the key for the current entry.  The underlying storage for
+  // the returned slice is valid only until the next modification of
+  // the iterator.
+  // REQUIRES: Valid()
+  virtual Slice key() const = 0;
+
+  // Return the value for the current entry.  The underlying storage for
+  // the returned slice is valid only until the next modification of
+  // the iterator.
+  // REQUIRES: !AtEnd() && !AtStart()
+  virtual Slice value() const = 0;
+
+  // If an error has occurred, return it.  Else return an ok status.
+  virtual Status status() const = 0;
+
+  // Clients are allowed to register function/arg1/arg2 triples that
+  // will be invoked when this iterator is destroyed.
+  //
+  // Note that unlike all of the preceding methods, this method is
+  // not abstract and therefore clients should not override it.
+  typedef void (*CleanupFunction)(void* arg1, void* arg2);
+  void RegisterCleanup(CleanupFunction function, void* arg1, void* arg2);
+
+ private:
+  struct Cleanup {
+    CleanupFunction function;
+    void* arg1;
+    void* arg2;
+    Cleanup* next;
+  };
+  Cleanup cleanup_;
+
+  // No copying allowed
+  Iterator(const Iterator&);
+  void operator=(const Iterator&);
+};
+
+// Return an empty iterator (yields nothing).
+extern Iterator* NewEmptyIterator();
+
+// Return an empty iterator with the specified status.
+extern Iterator* NewErrorIterator(const Status& status);
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_INCLUDE_ITERATOR_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/options.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/options.h
new file mode 100644
index 0000000..fdda718
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/options.h
@@ -0,0 +1,195 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_INCLUDE_OPTIONS_H_
+#define STORAGE_LEVELDB_INCLUDE_OPTIONS_H_
+
+#include <stddef.h>
+
+namespace leveldb {
+
+class Cache;
+class Comparator;
+class Env;
+class FilterPolicy;
+class Logger;
+class Snapshot;
+
+// DB contents are stored in a set of blocks, each of which holds a
+// sequence of key,value pairs.  Each block may be compressed before
+// being stored in a file.  The following enum describes which
+// compression method (if any) is used to compress a block.
+enum CompressionType {
+  // NOTE: do not change the values of existing entries, as these are
+  // part of the persistent format on disk.
+  kNoCompression     = 0x0,
+  kSnappyCompression = 0x1
+};
+
+// Options to control the behavior of a database (passed to DB::Open)
+struct Options {
+  // -------------------
+  // Parameters that affect behavior
+
+  // Comparator used to define the order of keys in the table.
+  // Default: a comparator that uses lexicographic byte-wise ordering
+  //
+  // REQUIRES: The client must ensure that the comparator supplied
+  // here has the same name and orders keys *exactly* the same as the
+  // comparator provided to previous open calls on the same DB.
+  const Comparator* comparator;
+
+  // If true, the database will be created if it is missing.
+  // Default: false
+  bool create_if_missing;
+
+  // If true, an error is raised if the database already exists.
+  // Default: false
+  bool error_if_exists;
+
+  // If true, the implementation will do aggressive checking of the
+  // data it is processing and will stop early if it detects any
+  // errors.  This may have unforeseen ramifications: for example, a
+  // corruption of one DB entry may cause a large number of entries to
+  // become unreadable or for the entire DB to become unopenable.
+  // Default: false
+  bool paranoid_checks;
+
+  // Use the specified object to interact with the environment,
+  // e.g. to read/write files, schedule background work, etc.
+  // Default: Env::Default()
+  Env* env;
+
+  // Any internal progress/error information generated by the db will
+  // be written to info_log if it is non-NULL, or to a file stored
+  // in the same directory as the DB contents if info_log is NULL.
+  // Default: NULL
+  Logger* info_log;
+
+  // -------------------
+  // Parameters that affect performance
+
+  // Amount of data to build up in memory (backed by an unsorted log
+  // on disk) before converting to a sorted on-disk file.
+  //
+  // Larger values increase performance, especially during bulk loads.
+  // Up to two write buffers may be held in memory at the same time,
+  // so you may wish to adjust this parameter to control memory usage.
+  // Also, a larger write buffer will result in a longer recovery time
+  // the next time the database is opened.
+  //
+  // Default: 4MB
+  size_t write_buffer_size;
+
+  // Number of open files that can be used by the DB.  You may need to
+  // increase this if your database has a large working set (budget
+  // one open file per 2MB of working set).
+  //
+  // Default: 1000
+  int max_open_files;
+
+  // Control over blocks (user data is stored in a set of blocks, and
+  // a block is the unit of reading from disk).
+
+  // If non-NULL, use the specified cache for blocks.
+  // If NULL, leveldb will automatically create and use an 8MB internal cache.
+  // Default: NULL
+  Cache* block_cache;
+
+  // Approximate size of user data packed per block.  Note that the
+  // block size specified here corresponds to uncompressed data.  The
+  // actual size of the unit read from disk may be smaller if
+  // compression is enabled.  This parameter can be changed dynamically.
+  //
+  // Default: 4K
+  size_t block_size;
+
+  // Number of keys between restart points for delta encoding of keys.
+  // This parameter can be changed dynamically.  Most clients should
+  // leave this parameter alone.
+  //
+  // Default: 16
+  int block_restart_interval;
+
+  // Compress blocks using the specified compression algorithm.  This
+  // parameter can be changed dynamically.
+  //
+  // Default: kSnappyCompression, which gives lightweight but fast
+  // compression.
+  //
+  // Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:
+  //    ~200-500MB/s compression
+  //    ~400-800MB/s decompression
+  // Note that these speeds are significantly faster than most
+  // persistent storage speeds, and therefore it is typically never
+  // worth switching to kNoCompression.  Even if the input data is
+  // incompressible, the kSnappyCompression implementation will
+  // efficiently detect that and will switch to uncompressed mode.
+  CompressionType compression;
+
+  // If non-NULL, use the specified filter policy to reduce disk reads.
+  // Many applications will benefit from passing the result of
+  // NewBloomFilterPolicy() here.
+  //
+  // Default: NULL
+  const FilterPolicy* filter_policy;
+
+  // Create an Options object with default values for all fields.
+  Options();
+};
+
+// Options that control read operations
+struct ReadOptions {
+  // If true, all data read from underlying storage will be
+  // verified against corresponding checksums.
+  // Default: false
+  bool verify_checksums;
+
+  // Should the data read for this iteration be cached in memory?
+  // Callers may wish to set this field to false for bulk scans.
+  // Default: true
+  bool fill_cache;
+
+  // If "snapshot" is non-NULL, read as of the supplied snapshot
+  // (which must belong to the DB that is being read and which must
+  // not have been released).  If "snapshot" is NULL, use an impliicit
+  // snapshot of the state at the beginning of this read operation.
+  // Default: NULL
+  const Snapshot* snapshot;
+
+  ReadOptions()
+      : verify_checksums(false),
+        fill_cache(true),
+        snapshot(NULL) {
+  }
+};
+
+// Options that control write operations
+struct WriteOptions {
+  // If true, the write will be flushed from the operating system
+  // buffer cache (by calling WritableFile::Sync()) before the write
+  // is considered complete.  If this flag is true, writes will be
+  // slower.
+  //
+  // If this flag is false, and the machine crashes, some recent
+  // writes may be lost.  Note that if it is just the process that
+  // crashes (i.e., the machine does not reboot), no writes will be
+  // lost even if sync==false.
+  //
+  // In other words, a DB write with sync==false has similar
+  // crash semantics as the "write()" system call.  A DB write
+  // with sync==true has similar crash semantics to a "write()"
+  // system call followed by "fsync()".
+  //
+  // Default: false
+  bool sync;
+
+  WriteOptions()
+      : sync(false) {
+  }
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_INCLUDE_OPTIONS_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/slice.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/slice.h
new file mode 100644
index 0000000..74ea8fa
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/slice.h
@@ -0,0 +1,109 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// Slice is a simple structure containing a pointer into some external
+// storage and a size.  The user of a Slice must ensure that the slice
+// is not used after the corresponding external storage has been
+// deallocated.
+//
+// Multiple threads can invoke const methods on a Slice without
+// external synchronization, but if any of the threads may call a
+// non-const method, all threads accessing the same Slice must use
+// external synchronization.
+
+#ifndef STORAGE_LEVELDB_INCLUDE_SLICE_H_
+#define STORAGE_LEVELDB_INCLUDE_SLICE_H_
+
+#include <assert.h>
+#include <stddef.h>
+#include <string.h>
+#include <string>
+
+namespace leveldb {
+
+class Slice {
+ public:
+  // Create an empty slice.
+  Slice() : data_(""), size_(0) { }
+
+  // Create a slice that refers to d[0,n-1].
+  Slice(const char* d, size_t n) : data_(d), size_(n) { }
+
+  // Create a slice that refers to the contents of "s"
+  Slice(const std::string& s) : data_(s.data()), size_(s.size()) { }
+
+  // Create a slice that refers to s[0,strlen(s)-1]
+  Slice(const char* s) : data_(s), size_(strlen(s)) { }
+
+  // Return a pointer to the beginning of the referenced data
+  const char* data() const { return data_; }
+
+  // Return the length (in bytes) of the referenced data
+  size_t size() const { return size_; }
+
+  // Return true iff the length of the referenced data is zero
+  bool empty() const { return size_ == 0; }
+
+  // Return the ith byte in the referenced data.
+  // REQUIRES: n < size()
+  char operator[](size_t n) const {
+    assert(n < size());
+    return data_[n];
+  }
+
+  // Change this slice to refer to an empty array
+  void clear() { data_ = ""; size_ = 0; }
+
+  // Drop the first "n" bytes from this slice.
+  void remove_prefix(size_t n) {
+    assert(n <= size());
+    data_ += n;
+    size_ -= n;
+  }
+
+  // Return a string that contains the copy of the referenced data.
+  std::string ToString() const { return std::string(data_, size_); }
+
+  // Three-way comparison.  Returns value:
+  //   <  0 iff "*this" <  "b",
+  //   == 0 iff "*this" == "b",
+  //   >  0 iff "*this" >  "b"
+  int compare(const Slice& b) const;
+
+  // Return true iff "x" is a prefix of "*this"
+  bool starts_with(const Slice& x) const {
+    return ((size_ >= x.size_) &&
+            (memcmp(data_, x.data_, x.size_) == 0));
+  }
+
+ private:
+  const char* data_;
+  size_t size_;
+
+  // Intentionally copyable
+};
+
+inline bool operator==(const Slice& x, const Slice& y) {
+  return ((x.size() == y.size()) &&
+          (memcmp(x.data(), y.data(), x.size()) == 0));
+}
+
+inline bool operator!=(const Slice& x, const Slice& y) {
+  return !(x == y);
+}
+
+inline int Slice::compare(const Slice& b) const {
+  const int min_len = (size_ < b.size_) ? size_ : b.size_;
+  int r = memcmp(data_, b.data_, min_len);
+  if (r == 0) {
+    if (size_ < b.size_) r = -1;
+    else if (size_ > b.size_) r = +1;
+  }
+  return r;
+}
+
+}  // namespace leveldb
+
+
+#endif  // STORAGE_LEVELDB_INCLUDE_SLICE_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/status.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/status.h
new file mode 100644
index 0000000..11dbd4b
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/status.h
@@ -0,0 +1,106 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// A Status encapsulates the result of an operation.  It may indicate success,
+// or it may indicate an error with an associated error message.
+//
+// Multiple threads can invoke const methods on a Status without
+// external synchronization, but if any of the threads may call a
+// non-const method, all threads accessing the same Status must use
+// external synchronization.
+
+#ifndef STORAGE_LEVELDB_INCLUDE_STATUS_H_
+#define STORAGE_LEVELDB_INCLUDE_STATUS_H_
+
+#include <string>
+#include "leveldb/slice.h"
+
+namespace leveldb {
+
+class Status {
+ public:
+  // Create a success status.
+  Status() : state_(NULL) { }
+  ~Status() { delete[] state_; }
+
+  // Copy the specified status.
+  Status(const Status& s);
+  void operator=(const Status& s);
+
+  // Return a success status.
+  static Status OK() { return Status(); }
+
+  // Return error status of an appropriate type.
+  static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {
+    return Status(kNotFound, msg, msg2);
+  }
+  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {
+    return Status(kCorruption, msg, msg2);
+  }
+  static Status NotSupported(const Slice& msg, const Slice& msg2 = Slice()) {
+    return Status(kNotSupported, msg, msg2);
+  }
+  static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {
+    return Status(kInvalidArgument, msg, msg2);
+  }
+  static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {
+    return Status(kIOError, msg, msg2);
+  }
+
+  // Returns true iff the status indicates success.
+  bool ok() const { return (state_ == NULL); }
+
+  // Returns true iff the status indicates a NotFound error.
+  bool IsNotFound() const { return code() == kNotFound; }
+
+  // Returns true iff the status indicates a Corruption error.
+  bool IsCorruption() const { return code() == kCorruption; }
+
+  // Returns true iff the status indicates an IOError.
+  bool IsIOError() const { return code() == kIOError; }
+
+  // Return a string representation of this status suitable for printing.
+  // Returns the string "OK" for success.
+  std::string ToString() const;
+
+ private:
+  // OK status has a NULL state_.  Otherwise, state_ is a new[] array
+  // of the following form:
+  //    state_[0..3] == length of message
+  //    state_[4]    == code
+  //    state_[5..]  == message
+  const char* state_;
+
+  enum Code {
+    kOk = 0,
+    kNotFound = 1,
+    kCorruption = 2,
+    kNotSupported = 3,
+    kInvalidArgument = 4,
+    kIOError = 5
+  };
+
+  Code code() const {
+    return (state_ == NULL) ? kOk : static_cast<Code>(state_[4]);
+  }
+
+  Status(Code code, const Slice& msg, const Slice& msg2);
+  static const char* CopyState(const char* s);
+};
+
+inline Status::Status(const Status& s) {
+  state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);
+}
+inline void Status::operator=(const Status& s) {
+  // The following condition catches both aliasing (when this == &s),
+  // and the common case where both s and *this are ok.
+  if (state_ != s.state_) {
+    delete[] state_;
+    state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);
+  }
+}
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_INCLUDE_STATUS_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/table.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/table.h
new file mode 100644
index 0000000..a9746c3
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/table.h
@@ -0,0 +1,85 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_INCLUDE_TABLE_H_
+#define STORAGE_LEVELDB_INCLUDE_TABLE_H_
+
+#include <stdint.h>
+#include "leveldb/iterator.h"
+
+namespace leveldb {
+
+class Block;
+class BlockHandle;
+class Footer;
+struct Options;
+class RandomAccessFile;
+struct ReadOptions;
+class TableCache;
+
+// A Table is a sorted map from strings to strings.  Tables are
+// immutable and persistent.  A Table may be safely accessed from
+// multiple threads without external synchronization.
+class Table {
+ public:
+  // Attempt to open the table that is stored in bytes [0..file_size)
+  // of "file", and read the metadata entries necessary to allow
+  // retrieving data from the table.
+  //
+  // If successful, returns ok and sets "*table" to the newly opened
+  // table.  The client should delete "*table" when no longer needed.
+  // If there was an error while initializing the table, sets "*table"
+  // to NULL and returns a non-ok status.  Does not take ownership of
+  // "*source", but the client must ensure that "source" remains live
+  // for the duration of the returned table's lifetime.
+  //
+  // *file must remain live while this Table is in use.
+  static Status Open(const Options& options,
+                     RandomAccessFile* file,
+                     uint64_t file_size,
+                     Table** table);
+
+  ~Table();
+
+  // Returns a new iterator over the table contents.
+  // The result of NewIterator() is initially invalid (caller must
+  // call one of the Seek methods on the iterator before using it).
+  Iterator* NewIterator(const ReadOptions&) const;
+
+  // Given a key, return an approximate byte offset in the file where
+  // the data for that key begins (or would begin if the key were
+  // present in the file).  The returned value is in terms of file
+  // bytes, and so includes effects like compression of the underlying data.
+  // E.g., the approximate offset of the last key in the table will
+  // be close to the file length.
+  uint64_t ApproximateOffsetOf(const Slice& key) const;
+
+ private:
+  struct Rep;
+  Rep* rep_;
+
+  explicit Table(Rep* rep) { rep_ = rep; }
+  static Iterator* BlockReader(void*, const ReadOptions&, const Slice&);
+
+  // Calls (*handle_result)(arg, ...) with the entry found after a call
+  // to Seek(key).  May not make such a call if filter policy says
+  // that key is not present.
+  friend class TableCache;
+  Status InternalGet(
+      const ReadOptions&, const Slice& key,
+      void* arg,
+      void (*handle_result)(void* arg, const Slice& k, const Slice& v));
+
+
+  void ReadMeta(const Footer& footer);
+  void ReadFilter(const Slice& filter_handle_value);
+
+  // No copying allowed
+  Table(const Table&);
+  void operator=(const Table&);
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_INCLUDE_TABLE_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/table_builder.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/table_builder.h
new file mode 100644
index 0000000..5fd1dc7
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/table_builder.h
@@ -0,0 +1,92 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// TableBuilder provides the interface used to build a Table
+// (an immutable and sorted map from keys to values).
+//
+// Multiple threads can invoke const methods on a TableBuilder without
+// external synchronization, but if any of the threads may call a
+// non-const method, all threads accessing the same TableBuilder must use
+// external synchronization.
+
+#ifndef STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_
+#define STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_
+
+#include <stdint.h>
+#include "leveldb/options.h"
+#include "leveldb/status.h"
+
+namespace leveldb {
+
+class BlockBuilder;
+class BlockHandle;
+class WritableFile;
+
+class TableBuilder {
+ public:
+  // Create a builder that will store the contents of the table it is
+  // building in *file.  Does not close the file.  It is up to the
+  // caller to close the file after calling Finish().
+  TableBuilder(const Options& options, WritableFile* file);
+
+  // REQUIRES: Either Finish() or Abandon() has been called.
+  ~TableBuilder();
+
+  // Change the options used by this builder.  Note: only some of the
+  // option fields can be changed after construction.  If a field is
+  // not allowed to change dynamically and its value in the structure
+  // passed to the constructor is different from its value in the
+  // structure passed to this method, this method will return an error
+  // without changing any fields.
+  Status ChangeOptions(const Options& options);
+
+  // Add key,value to the table being constructed.
+  // REQUIRES: key is after any previously added key according to comparator.
+  // REQUIRES: Finish(), Abandon() have not been called
+  void Add(const Slice& key, const Slice& value);
+
+  // Advanced operation: flush any buffered key/value pairs to file.
+  // Can be used to ensure that two adjacent entries never live in
+  // the same data block.  Most clients should not need to use this method.
+  // REQUIRES: Finish(), Abandon() have not been called
+  void Flush();
+
+  // Return non-ok iff some error has been detected.
+  Status status() const;
+
+  // Finish building the table.  Stops using the file passed to the
+  // constructor after this function returns.
+  // REQUIRES: Finish(), Abandon() have not been called
+  Status Finish();
+
+  // Indicate that the contents of this builder should be abandoned.  Stops
+  // using the file passed to the constructor after this function returns.
+  // If the caller is not going to call Finish(), it must call Abandon()
+  // before destroying this builder.
+  // REQUIRES: Finish(), Abandon() have not been called
+  void Abandon();
+
+  // Number of calls to Add() so far.
+  uint64_t NumEntries() const;
+
+  // Size of the file generated so far.  If invoked after a successful
+  // Finish() call, returns the size of the final generated file.
+  uint64_t FileSize() const;
+
+ private:
+  bool ok() const { return status().ok(); }
+  void WriteBlock(BlockBuilder* block, BlockHandle* handle);
+  void WriteRawBlock(const Slice& data, CompressionType, BlockHandle* handle);
+
+  struct Rep;
+  Rep* rep_;
+
+  // No copying allowed
+  TableBuilder(const TableBuilder&);
+  void operator=(const TableBuilder&);
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/write_batch.h b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/write_batch.h
new file mode 100644
index 0000000..ee9aab6
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/include/leveldb/write_batch.h
@@ -0,0 +1,64 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// WriteBatch holds a collection of updates to apply atomically to a DB.
+//
+// The updates are applied in the order in which they are added
+// to the WriteBatch.  For example, the value of "key" will be "v3"
+// after the following batch is written:
+//
+//    batch.Put("key", "v1");
+//    batch.Delete("key");
+//    batch.Put("key", "v2");
+//    batch.Put("key", "v3");
+//
+// Multiple threads can invoke const methods on a WriteBatch without
+// external synchronization, but if any of the threads may call a
+// non-const method, all threads accessing the same WriteBatch must use
+// external synchronization.
+
+#ifndef STORAGE_LEVELDB_INCLUDE_WRITE_BATCH_H_
+#define STORAGE_LEVELDB_INCLUDE_WRITE_BATCH_H_
+
+#include <string>
+#include "leveldb/status.h"
+
+namespace leveldb {
+
+class Slice;
+
+class WriteBatch {
+ public:
+  WriteBatch();
+  ~WriteBatch();
+
+  // Store the mapping "key->value" in the database.
+  void Put(const Slice& key, const Slice& value);
+
+  // If the database contains a mapping for "key", erase it.  Else do nothing.
+  void Delete(const Slice& key);
+
+  // Clear all updates buffered in this batch.
+  void Clear();
+
+  // Support for iterating over the contents of a batch.
+  class Handler {
+   public:
+    virtual ~Handler();
+    virtual void Put(const Slice& key, const Slice& value) = 0;
+    virtual void Delete(const Slice& key) = 0;
+  };
+  Status Iterate(Handler* handler) const;
+
+ private:
+  friend class WriteBatchInternal;
+
+  std::string rep_;  // See comment in write_batch.cc for the format of rep_
+
+  // Intentionally copyable
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_INCLUDE_WRITE_BATCH_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/builder.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/builder.cc
new file mode 100644
index 0000000..f419882
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/builder.cc
@@ -0,0 +1,88 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "db/builder.h"
+
+#include "db/filename.h"
+#include "db/dbformat.h"
+#include "db/table_cache.h"
+#include "db/version_edit.h"
+#include "leveldb/db.h"
+#include "leveldb/env.h"
+#include "leveldb/iterator.h"
+
+namespace leveldb {
+
+Status BuildTable(const std::string& dbname,
+                  Env* env,
+                  const Options& options,
+                  TableCache* table_cache,
+                  Iterator* iter,
+                  FileMetaData* meta) {
+  Status s;
+  meta->file_size = 0;
+  iter->SeekToFirst();
+
+  std::string fname = TableFileName(dbname, meta->number);
+  if (iter->Valid()) {
+    WritableFile* file;
+    s = env->NewWritableFile(fname, &file);
+    if (!s.ok()) {
+      return s;
+    }
+
+    TableBuilder* builder = new TableBuilder(options, file);
+    meta->smallest.DecodeFrom(iter->key());
+    for (; iter->Valid(); iter->Next()) {
+      Slice key = iter->key();
+      meta->largest.DecodeFrom(key);
+      builder->Add(key, iter->value());
+    }
+
+    // Finish and check for builder errors
+    if (s.ok()) {
+      s = builder->Finish();
+      if (s.ok()) {
+        meta->file_size = builder->FileSize();
+        assert(meta->file_size > 0);
+      }
+    } else {
+      builder->Abandon();
+    }
+    delete builder;
+
+    // Finish and check for file errors
+    if (s.ok()) {
+      s = file->Sync();
+    }
+    if (s.ok()) {
+      s = file->Close();
+    }
+    delete file;
+    file = NULL;
+
+    if (s.ok()) {
+      // Verify that the table is usable
+      Iterator* it = table_cache->NewIterator(ReadOptions(),
+                                              meta->number,
+                                              meta->file_size);
+      s = it->status();
+      delete it;
+    }
+  }
+
+  // Check for input iterator errors
+  if (!iter->status().ok()) {
+    s = iter->status();
+  }
+
+  if (s.ok() && meta->file_size > 0) {
+    // Keep it
+  } else {
+    env->DeleteFile(fname);
+  }
+  return s;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/builder.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/builder.h
new file mode 100644
index 0000000..62431fc
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/builder.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_DB_BUILDER_H_
+#define STORAGE_LEVELDB_DB_BUILDER_H_
+
+#include "leveldb/status.h"
+
+namespace leveldb {
+
+struct Options;
+struct FileMetaData;
+
+class Env;
+class Iterator;
+class TableCache;
+class VersionEdit;
+
+// Build a Table file from the contents of *iter.  The generated file
+// will be named according to meta->number.  On success, the rest of
+// *meta will be filled with metadata about the generated table.
+// If no data is present in *iter, meta->file_size will be set to
+// zero, and no Table file will be produced.
+extern Status BuildTable(const std::string& dbname,
+                         Env* env,
+                         const Options& options,
+                         TableCache* table_cache,
+                         Iterator* iter,
+                         FileMetaData* meta);
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_BUILDER_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/c.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/c.cc
new file mode 100644
index 0000000..08ff0ad
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/c.cc
@@ -0,0 +1,595 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "leveldb/c.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+#include "leveldb/cache.h"
+#include "leveldb/comparator.h"
+#include "leveldb/db.h"
+#include "leveldb/env.h"
+#include "leveldb/filter_policy.h"
+#include "leveldb/iterator.h"
+#include "leveldb/options.h"
+#include "leveldb/status.h"
+#include "leveldb/write_batch.h"
+
+using leveldb::Cache;
+using leveldb::Comparator;
+using leveldb::CompressionType;
+using leveldb::DB;
+using leveldb::Env;
+using leveldb::FileLock;
+using leveldb::FilterPolicy;
+using leveldb::Iterator;
+using leveldb::kMajorVersion;
+using leveldb::kMinorVersion;
+using leveldb::Logger;
+using leveldb::NewBloomFilterPolicy;
+using leveldb::NewLRUCache;
+using leveldb::Options;
+using leveldb::RandomAccessFile;
+using leveldb::Range;
+using leveldb::ReadOptions;
+using leveldb::SequentialFile;
+using leveldb::Slice;
+using leveldb::Snapshot;
+using leveldb::Status;
+using leveldb::WritableFile;
+using leveldb::WriteBatch;
+using leveldb::WriteOptions;
+
+extern "C" {
+
+struct leveldb_t              { DB*               rep; };
+struct leveldb_iterator_t     { Iterator*         rep; };
+struct leveldb_writebatch_t   { WriteBatch        rep; };
+struct leveldb_snapshot_t     { const Snapshot*   rep; };
+struct leveldb_readoptions_t  { ReadOptions       rep; };
+struct leveldb_writeoptions_t { WriteOptions      rep; };
+struct leveldb_options_t      { Options           rep; };
+struct leveldb_cache_t        { Cache*            rep; };
+struct leveldb_seqfile_t      { SequentialFile*   rep; };
+struct leveldb_randomfile_t   { RandomAccessFile* rep; };
+struct leveldb_writablefile_t { WritableFile*     rep; };
+struct leveldb_logger_t       { Logger*           rep; };
+struct leveldb_filelock_t     { FileLock*         rep; };
+
+struct leveldb_comparator_t : public Comparator {
+  void* state_;
+  void (*destructor_)(void*);
+  int (*compare_)(
+      void*,
+      const char* a, size_t alen,
+      const char* b, size_t blen);
+  const char* (*name_)(void*);
+
+  virtual ~leveldb_comparator_t() {
+    (*destructor_)(state_);
+  }
+
+  virtual int Compare(const Slice& a, const Slice& b) const {
+    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());
+  }
+
+  virtual const char* Name() const {
+    return (*name_)(state_);
+  }
+
+  // No-ops since the C binding does not support key shortening methods.
+  virtual void FindShortestSeparator(std::string*, const Slice&) const { }
+  virtual void FindShortSuccessor(std::string* key) const { }
+};
+
+struct leveldb_filterpolicy_t : public FilterPolicy {
+  void* state_;
+  void (*destructor_)(void*);
+  const char* (*name_)(void*);
+  char* (*create_)(
+      void*,
+      const char* const* key_array, const size_t* key_length_array,
+      int num_keys,
+      size_t* filter_length);
+  unsigned char (*key_match_)(
+      void*,
+      const char* key, size_t length,
+      const char* filter, size_t filter_length);
+
+  virtual ~leveldb_filterpolicy_t() {
+    (*destructor_)(state_);
+  }
+
+  virtual const char* Name() const {
+    return (*name_)(state_);
+  }
+
+  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
+    std::vector<const char*> key_pointers(n);
+    std::vector<size_t> key_sizes(n);
+    for (int i = 0; i < n; i++) {
+      key_pointers[i] = keys[i].data();
+      key_sizes[i] = keys[i].size();
+    }
+    size_t len;
+    char* filter = (*create_)(state_, &key_pointers[0], &key_sizes[0], n, &len);
+    dst->append(filter, len);
+    free(filter);
+  }
+
+  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {
+    return (*key_match_)(state_, key.data(), key.size(),
+                         filter.data(), filter.size());
+  }
+};
+
+struct leveldb_env_t {
+  Env* rep;
+  bool is_default;
+};
+
+static bool SaveError(char** errptr, const Status& s) {
+  assert(errptr != NULL);
+  if (s.ok()) {
+    return false;
+  } else if (*errptr == NULL) {
+    *errptr = strdup(s.ToString().c_str());
+  } else {
+    // TODO(sanjay): Merge with existing error?
+    free(*errptr);
+    *errptr = strdup(s.ToString().c_str());
+  }
+  return true;
+}
+
+static char* CopyString(const std::string& str) {
+  char* result = reinterpret_cast<char*>(malloc(sizeof(char) * str.size()));
+  memcpy(result, str.data(), sizeof(char) * str.size());
+  return result;
+}
+
+leveldb_t* leveldb_open(
+    const leveldb_options_t* options,
+    const char* name,
+    char** errptr) {
+  DB* db;
+  if (SaveError(errptr, DB::Open(options->rep, std::string(name), &db))) {
+    return NULL;
+  }
+  leveldb_t* result = new leveldb_t;
+  result->rep = db;
+  return result;
+}
+
+void leveldb_close(leveldb_t* db) {
+  delete db->rep;
+  delete db;
+}
+
+void leveldb_put(
+    leveldb_t* db,
+    const leveldb_writeoptions_t* options,
+    const char* key, size_t keylen,
+    const char* val, size_t vallen,
+    char** errptr) {
+  SaveError(errptr,
+            db->rep->Put(options->rep, Slice(key, keylen), Slice(val, vallen)));
+}
+
+void leveldb_delete(
+    leveldb_t* db,
+    const leveldb_writeoptions_t* options,
+    const char* key, size_t keylen,
+    char** errptr) {
+  SaveError(errptr, db->rep->Delete(options->rep, Slice(key, keylen)));
+}
+
+
+void leveldb_write(
+    leveldb_t* db,
+    const leveldb_writeoptions_t* options,
+    leveldb_writebatch_t* batch,
+    char** errptr) {
+  SaveError(errptr, db->rep->Write(options->rep, &batch->rep));
+}
+
+char* leveldb_get(
+    leveldb_t* db,
+    const leveldb_readoptions_t* options,
+    const char* key, size_t keylen,
+    size_t* vallen,
+    char** errptr) {
+  char* result = NULL;
+  std::string tmp;
+  Status s = db->rep->Get(options->rep, Slice(key, keylen), &tmp);
+  if (s.ok()) {
+    *vallen = tmp.size();
+    result = CopyString(tmp);
+  } else {
+    *vallen = 0;
+    if (!s.IsNotFound()) {
+      SaveError(errptr, s);
+    }
+  }
+  return result;
+}
+
+leveldb_iterator_t* leveldb_create_iterator(
+    leveldb_t* db,
+    const leveldb_readoptions_t* options) {
+  leveldb_iterator_t* result = new leveldb_iterator_t;
+  result->rep = db->rep->NewIterator(options->rep);
+  return result;
+}
+
+const leveldb_snapshot_t* leveldb_create_snapshot(
+    leveldb_t* db) {
+  leveldb_snapshot_t* result = new leveldb_snapshot_t;
+  result->rep = db->rep->GetSnapshot();
+  return result;
+}
+
+void leveldb_release_snapshot(
+    leveldb_t* db,
+    const leveldb_snapshot_t* snapshot) {
+  db->rep->ReleaseSnapshot(snapshot->rep);
+  delete snapshot;
+}
+
+char* leveldb_property_value(
+    leveldb_t* db,
+    const char* propname) {
+  std::string tmp;
+  if (db->rep->GetProperty(Slice(propname), &tmp)) {
+    // We use strdup() since we expect human readable output.
+    return strdup(tmp.c_str());
+  } else {
+    return NULL;
+  }
+}
+
+void leveldb_approximate_sizes(
+    leveldb_t* db,
+    int num_ranges,
+    const char* const* range_start_key, const size_t* range_start_key_len,
+    const char* const* range_limit_key, const size_t* range_limit_key_len,
+    uint64_t* sizes) {
+  Range* ranges = new Range[num_ranges];
+  for (int i = 0; i < num_ranges; i++) {
+    ranges[i].start = Slice(range_start_key[i], range_start_key_len[i]);
+    ranges[i].limit = Slice(range_limit_key[i], range_limit_key_len[i]);
+  }
+  db->rep->GetApproximateSizes(ranges, num_ranges, sizes);
+  delete[] ranges;
+}
+
+void leveldb_compact_range(
+    leveldb_t* db,
+    const char* start_key, size_t start_key_len,
+    const char* limit_key, size_t limit_key_len) {
+  Slice a, b;
+  db->rep->CompactRange(
+      // Pass NULL Slice if corresponding "const char*" is NULL
+      (start_key ? (a = Slice(start_key, start_key_len), &a) : NULL),
+      (limit_key ? (b = Slice(limit_key, limit_key_len), &b) : NULL));
+}
+
+void leveldb_destroy_db(
+    const leveldb_options_t* options,
+    const char* name,
+    char** errptr) {
+  SaveError(errptr, DestroyDB(name, options->rep));
+}
+
+void leveldb_repair_db(
+    const leveldb_options_t* options,
+    const char* name,
+    char** errptr) {
+  SaveError(errptr, RepairDB(name, options->rep));
+}
+
+void leveldb_iter_destroy(leveldb_iterator_t* iter) {
+  delete iter->rep;
+  delete iter;
+}
+
+unsigned char leveldb_iter_valid(const leveldb_iterator_t* iter) {
+  return iter->rep->Valid();
+}
+
+void leveldb_iter_seek_to_first(leveldb_iterator_t* iter) {
+  iter->rep->SeekToFirst();
+}
+
+void leveldb_iter_seek_to_last(leveldb_iterator_t* iter) {
+  iter->rep->SeekToLast();
+}
+
+void leveldb_iter_seek(leveldb_iterator_t* iter, const char* k, size_t klen) {
+  iter->rep->Seek(Slice(k, klen));
+}
+
+void leveldb_iter_next(leveldb_iterator_t* iter) {
+  iter->rep->Next();
+}
+
+void leveldb_iter_prev(leveldb_iterator_t* iter) {
+  iter->rep->Prev();
+}
+
+const char* leveldb_iter_key(const leveldb_iterator_t* iter, size_t* klen) {
+  Slice s = iter->rep->key();
+  *klen = s.size();
+  return s.data();
+}
+
+const char* leveldb_iter_value(const leveldb_iterator_t* iter, size_t* vlen) {
+  Slice s = iter->rep->value();
+  *vlen = s.size();
+  return s.data();
+}
+
+void leveldb_iter_get_error(const leveldb_iterator_t* iter, char** errptr) {
+  SaveError(errptr, iter->rep->status());
+}
+
+leveldb_writebatch_t* leveldb_writebatch_create() {
+  return new leveldb_writebatch_t;
+}
+
+void leveldb_writebatch_destroy(leveldb_writebatch_t* b) {
+  delete b;
+}
+
+void leveldb_writebatch_clear(leveldb_writebatch_t* b) {
+  b->rep.Clear();
+}
+
+void leveldb_writebatch_put(
+    leveldb_writebatch_t* b,
+    const char* key, size_t klen,
+    const char* val, size_t vlen) {
+  b->rep.Put(Slice(key, klen), Slice(val, vlen));
+}
+
+void leveldb_writebatch_delete(
+    leveldb_writebatch_t* b,
+    const char* key, size_t klen) {
+  b->rep.Delete(Slice(key, klen));
+}
+
+void leveldb_writebatch_iterate(
+    leveldb_writebatch_t* b,
+    void* state,
+    void (*put)(void*, const char* k, size_t klen, const char* v, size_t vlen),
+    void (*deleted)(void*, const char* k, size_t klen)) {
+  class H : public WriteBatch::Handler {
+   public:
+    void* state_;
+    void (*put_)(void*, const char* k, size_t klen, const char* v, size_t vlen);
+    void (*deleted_)(void*, const char* k, size_t klen);
+    virtual void Put(const Slice& key, const Slice& value) {
+      (*put_)(state_, key.data(), key.size(), value.data(), value.size());
+    }
+    virtual void Delete(const Slice& key) {
+      (*deleted_)(state_, key.data(), key.size());
+    }
+  };
+  H handler;
+  handler.state_ = state;
+  handler.put_ = put;
+  handler.deleted_ = deleted;
+  b->rep.Iterate(&handler);
+}
+
+leveldb_options_t* leveldb_options_create() {
+  return new leveldb_options_t;
+}
+
+void leveldb_options_destroy(leveldb_options_t* options) {
+  delete options;
+}
+
+void leveldb_options_set_comparator(
+    leveldb_options_t* opt,
+    leveldb_comparator_t* cmp) {
+  opt->rep.comparator = cmp;
+}
+
+void leveldb_options_set_filter_policy(
+    leveldb_options_t* opt,
+    leveldb_filterpolicy_t* policy) {
+  opt->rep.filter_policy = policy;
+}
+
+void leveldb_options_set_create_if_missing(
+    leveldb_options_t* opt, unsigned char v) {
+  opt->rep.create_if_missing = v;
+}
+
+void leveldb_options_set_error_if_exists(
+    leveldb_options_t* opt, unsigned char v) {
+  opt->rep.error_if_exists = v;
+}
+
+void leveldb_options_set_paranoid_checks(
+    leveldb_options_t* opt, unsigned char v) {
+  opt->rep.paranoid_checks = v;
+}
+
+void leveldb_options_set_env(leveldb_options_t* opt, leveldb_env_t* env) {
+  opt->rep.env = (env ? env->rep : NULL);
+}
+
+void leveldb_options_set_info_log(leveldb_options_t* opt, leveldb_logger_t* l) {
+  opt->rep.info_log = (l ? l->rep : NULL);
+}
+
+void leveldb_options_set_write_buffer_size(leveldb_options_t* opt, size_t s) {
+  opt->rep.write_buffer_size = s;
+}
+
+void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {
+  opt->rep.max_open_files = n;
+}
+
+void leveldb_options_set_cache(leveldb_options_t* opt, leveldb_cache_t* c) {
+  opt->rep.block_cache = c->rep;
+}
+
+void leveldb_options_set_block_size(leveldb_options_t* opt, size_t s) {
+  opt->rep.block_size = s;
+}
+
+void leveldb_options_set_block_restart_interval(leveldb_options_t* opt, int n) {
+  opt->rep.block_restart_interval = n;
+}
+
+void leveldb_options_set_compression(leveldb_options_t* opt, int t) {
+  opt->rep.compression = static_cast<CompressionType>(t);
+}
+
+leveldb_comparator_t* leveldb_comparator_create(
+    void* state,
+    void (*destructor)(void*),
+    int (*compare)(
+        void*,
+        const char* a, size_t alen,
+        const char* b, size_t blen),
+    const char* (*name)(void*)) {
+  leveldb_comparator_t* result = new leveldb_comparator_t;
+  result->state_ = state;
+  result->destructor_ = destructor;
+  result->compare_ = compare;
+  result->name_ = name;
+  return result;
+}
+
+void leveldb_comparator_destroy(leveldb_comparator_t* cmp) {
+  delete cmp;
+}
+
+leveldb_filterpolicy_t* leveldb_filterpolicy_create(
+    void* state,
+    void (*destructor)(void*),
+    char* (*create_filter)(
+        void*,
+        const char* const* key_array, const size_t* key_length_array,
+        int num_keys,
+        size_t* filter_length),
+    unsigned char (*key_may_match)(
+        void*,
+        const char* key, size_t length,
+        const char* filter, size_t filter_length),
+    const char* (*name)(void*)) {
+  leveldb_filterpolicy_t* result = new leveldb_filterpolicy_t;
+  result->state_ = state;
+  result->destructor_ = destructor;
+  result->create_ = create_filter;
+  result->key_match_ = key_may_match;
+  result->name_ = name;
+  return result;
+}
+
+void leveldb_filterpolicy_destroy(leveldb_filterpolicy_t* filter) {
+  delete filter;
+}
+
+leveldb_filterpolicy_t* leveldb_filterpolicy_create_bloom(int bits_per_key) {
+  // Make a leveldb_filterpolicy_t, but override all of its methods so
+  // they delegate to a NewBloomFilterPolicy() instead of user
+  // supplied C functions.
+  struct Wrapper : public leveldb_filterpolicy_t {
+    const FilterPolicy* rep_;
+    ~Wrapper() { delete rep_; }
+    const char* Name() const { return rep_->Name(); }
+    void CreateFilter(const Slice* keys, int n, std::string* dst) const {
+      return rep_->CreateFilter(keys, n, dst);
+    }
+    bool KeyMayMatch(const Slice& key, const Slice& filter) const {
+      return rep_->KeyMayMatch(key, filter);
+    }
+    static void DoNothing(void*) { }
+  };
+  Wrapper* wrapper = new Wrapper;
+  wrapper->rep_ = NewBloomFilterPolicy(bits_per_key);
+  wrapper->state_ = NULL;
+  wrapper->destructor_ = &Wrapper::DoNothing;
+  return wrapper;
+}
+
+leveldb_readoptions_t* leveldb_readoptions_create() {
+  return new leveldb_readoptions_t;
+}
+
+void leveldb_readoptions_destroy(leveldb_readoptions_t* opt) {
+  delete opt;
+}
+
+void leveldb_readoptions_set_verify_checksums(
+    leveldb_readoptions_t* opt,
+    unsigned char v) {
+  opt->rep.verify_checksums = v;
+}
+
+void leveldb_readoptions_set_fill_cache(
+    leveldb_readoptions_t* opt, unsigned char v) {
+  opt->rep.fill_cache = v;
+}
+
+void leveldb_readoptions_set_snapshot(
+    leveldb_readoptions_t* opt,
+    const leveldb_snapshot_t* snap) {
+  opt->rep.snapshot = (snap ? snap->rep : NULL);
+}
+
+leveldb_writeoptions_t* leveldb_writeoptions_create() {
+  return new leveldb_writeoptions_t;
+}
+
+void leveldb_writeoptions_destroy(leveldb_writeoptions_t* opt) {
+  delete opt;
+}
+
+void leveldb_writeoptions_set_sync(
+    leveldb_writeoptions_t* opt, unsigned char v) {
+  opt->rep.sync = v;
+}
+
+leveldb_cache_t* leveldb_cache_create_lru(size_t capacity) {
+  leveldb_cache_t* c = new leveldb_cache_t;
+  c->rep = NewLRUCache(capacity);
+  return c;
+}
+
+void leveldb_cache_destroy(leveldb_cache_t* cache) {
+  delete cache->rep;
+  delete cache;
+}
+
+leveldb_env_t* leveldb_create_default_env() {
+  leveldb_env_t* result = new leveldb_env_t;
+  result->rep = Env::Default();
+  result->is_default = true;
+  return result;
+}
+
+void leveldb_env_destroy(leveldb_env_t* env) {
+  if (!env->is_default) delete env->rep;
+  delete env;
+}
+
+void leveldb_free(void* ptr) {
+  free(ptr);
+}
+
+int leveldb_major_version() {
+  return kMajorVersion;
+}
+
+int leveldb_minor_version() {
+  return kMinorVersion;
+}
+
+}  // end extern "C"
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/db_bench.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/db_bench.cc
new file mode 100644
index 0000000..be0d70b
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/db_bench.cc
@@ -0,0 +1,980 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "db/db_impl.h"
+#include "db/version_set.h"
+#include "leveldb/c.h"
+#include "leveldb/cache.h"
+#include "leveldb/db.h"
+#include "leveldb/env.h"
+#include "leveldb/write_batch.h"
+#include "port/port.h"
+#include "util/crc32c.h"
+#include "util/histogram.h"
+#include "util/mutexlock.h"
+#include "util/random.h"
+#include "util/testutil.h"
+
+// Comma-separated list of operations to run in the specified order
+//   Actual benchmarks:
+//      fillseq       -- write N values in sequential key order in async mode
+//      fillrandom    -- write N values in random key order in async mode
+//      overwrite     -- overwrite N values in random key order in async mode
+//      fillsync      -- write N/100 values in random key order in sync mode
+//      fill100K      -- write N/1000 100K values in random order in async mode
+//      deleteseq     -- delete N keys in sequential order
+//      deleterandom  -- delete N keys in random order
+//      readseq       -- read N times sequentially
+//      readreverse   -- read N times in reverse order
+//      readrandom    -- read N times in random order
+//      readmissing   -- read N missing keys in random order
+//      readhot       -- read N times in random order from 1% section of DB
+//      seekrandom    -- N random seeks
+//      crc32c        -- repeated crc32c of 4K of data
+//      acquireload   -- load N*1000 times
+//   Meta operations:
+//      compact     -- Compact the entire DB
+//      stats       -- Print DB stats
+//      sstables    -- Print sstable info
+//      heapprofile -- Dump a heap profile (if supported by this port)
+static const char* FLAGS_benchmarks =
+    "fillseq,"
+    "fillsync,"
+    "fillrandom,"
+    "overwrite,"
+    "readrandom,"
+    "readrandom,"  // Extra run to allow previous compactions to quiesce
+    "readseq,"
+    "readreverse,"
+    "compact,"
+    "readrandom,"
+    "readseq,"
+    "readreverse,"
+    "fill100K,"
+    "crc32c,"
+    "snappycomp,"
+    "snappyuncomp,"
+    "acquireload,"
+    ;
+
+// Number of key/values to place in database
+static int FLAGS_num = 1000000;
+
+// Number of read operations to do.  If negative, do FLAGS_num reads.
+static int FLAGS_reads = -1;
+
+// Number of concurrent threads to run.
+static int FLAGS_threads = 1;
+
+// Size of each value
+static int FLAGS_value_size = 100;
+
+// Arrange to generate values that shrink to this fraction of
+// their original size after compression
+static double FLAGS_compression_ratio = 0.5;
+
+// Print histogram of operation timings
+static bool FLAGS_histogram = false;
+
+// Number of bytes to buffer in memtable before compacting
+// (initialized to default value by "main")
+static int FLAGS_write_buffer_size = 0;
+
+// Number of bytes to use as a cache of uncompressed data.
+// Negative means use default settings.
+static int FLAGS_cache_size = -1;
+
+// Maximum number of files to keep open at the same time (use default if == 0)
+static int FLAGS_open_files = 0;
+
+// Bloom filter bits per key.
+// Negative means use default settings.
+static int FLAGS_bloom_bits = -1;
+
+// If true, do not destroy the existing database.  If you set this
+// flag and also specify a benchmark that wants a fresh database, that
+// benchmark will fail.
+static bool FLAGS_use_existing_db = false;
+
+// Use the db with the following name.
+static const char* FLAGS_db = NULL;
+
+namespace leveldb {
+
+namespace {
+
+// Helper for quickly generating random data.
+class RandomGenerator {
+ private:
+  std::string data_;
+  int pos_;
+
+ public:
+  RandomGenerator() {
+    // We use a limited amount of data over and over again and ensure
+    // that it is larger than the compression window (32KB), and also
+    // large enough to serve all typical value sizes we want to write.
+    Random rnd(301);
+    std::string piece;
+    while (data_.size() < 1048576) {
+      // Add a short fragment that is as compressible as specified
+      // by FLAGS_compression_ratio.
+      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
+      data_.append(piece);
+    }
+    pos_ = 0;
+  }
+
+  Slice Generate(size_t len) {
+    if (pos_ + len > data_.size()) {
+      pos_ = 0;
+      assert(len < data_.size());
+    }
+    pos_ += len;
+    return Slice(data_.data() + pos_ - len, len);
+  }
+};
+
+static Slice TrimSpace(Slice s) {
+  size_t start = 0;
+  while (start < s.size() && isspace(s[start])) {
+    start++;
+  }
+  size_t limit = s.size();
+  while (limit > start && isspace(s[limit-1])) {
+    limit--;
+  }
+  return Slice(s.data() + start, limit - start);
+}
+
+static void AppendWithSpace(std::string* str, Slice msg) {
+  if (msg.empty()) return;
+  if (!str->empty()) {
+    str->push_back(' ');
+  }
+  str->append(msg.data(), msg.size());
+}
+
+class Stats {
+ private:
+  double start_;
+  double finish_;
+  double seconds_;
+  int done_;
+  int next_report_;
+  int64_t bytes_;
+  double last_op_finish_;
+  Histogram hist_;
+  std::string message_;
+
+ public:
+  Stats() { Start(); }
+
+  void Start() {
+    next_report_ = 100;
+    last_op_finish_ = start_;
+    hist_.Clear();
+    done_ = 0;
+    bytes_ = 0;
+    seconds_ = 0;
+    start_ = Env::Default()->NowMicros();
+    finish_ = start_;
+    message_.clear();
+  }
+
+  void Merge(const Stats& other) {
+    hist_.Merge(other.hist_);
+    done_ += other.done_;
+    bytes_ += other.bytes_;
+    seconds_ += other.seconds_;
+    if (other.start_ < start_) start_ = other.start_;
+    if (other.finish_ > finish_) finish_ = other.finish_;
+
+    // Just keep the messages from one thread
+    if (message_.empty()) message_ = other.message_;
+  }
+
+  void Stop() {
+    finish_ = Env::Default()->NowMicros();
+    seconds_ = (finish_ - start_) * 1e-6;
+  }
+
+  void AddMessage(Slice msg) {
+    AppendWithSpace(&message_, msg);
+  }
+
+  void FinishedSingleOp() {
+    if (FLAGS_histogram) {
+      double now = Env::Default()->NowMicros();
+      double micros = now - last_op_finish_;
+      hist_.Add(micros);
+      if (micros > 20000) {
+        fprintf(stderr, "long op: %.1f micros%30s\r", micros, "");
+        fflush(stderr);
+      }
+      last_op_finish_ = now;
+    }
+
+    done_++;
+    if (done_ >= next_report_) {
+      if      (next_report_ < 1000)   next_report_ += 100;
+      else if (next_report_ < 5000)   next_report_ += 500;
+      else if (next_report_ < 10000)  next_report_ += 1000;
+      else if (next_report_ < 50000)  next_report_ += 5000;
+      else if (next_report_ < 100000) next_report_ += 10000;
+      else if (next_report_ < 500000) next_report_ += 50000;
+      else                            next_report_ += 100000;
+      fprintf(stderr, "... finished %d ops%30s\r", done_, "");
+      fflush(stderr);
+    }
+  }
+
+  void AddBytes(int64_t n) {
+    bytes_ += n;
+  }
+
+  void Report(const Slice& name) {
+    // Pretend at least one op was done in case we are running a benchmark
+    // that does not call FinishedSingleOp().
+    if (done_ < 1) done_ = 1;
+
+    std::string extra;
+    if (bytes_ > 0) {
+      // Rate is computed on actual elapsed time, not the sum of per-thread
+      // elapsed times.
+      double elapsed = (finish_ - start_) * 1e-6;
+      char rate[100];
+      snprintf(rate, sizeof(rate), "%6.1f MB/s",
+               (bytes_ / 1048576.0) / elapsed);
+      extra = rate;
+    }
+    AppendWithSpace(&extra, message_);
+
+    fprintf(stdout, "%-12s : %11.3f micros/op;%s%s\n",
+            name.ToString().c_str(),
+            seconds_ * 1e6 / done_,
+            (extra.empty() ? "" : " "),
+            extra.c_str());
+    if (FLAGS_histogram) {
+      fprintf(stdout, "Microseconds per op:\n%s\n", hist_.ToString().c_str());
+    }
+    fflush(stdout);
+  }
+};
+
+// State shared by all concurrent executions of the same benchmark.
+struct SharedState {
+  port::Mutex mu;
+  port::CondVar cv;
+  int total;
+
+  // Each thread goes through the following states:
+  //    (1) initializing
+  //    (2) waiting for others to be initialized
+  //    (3) running
+  //    (4) done
+
+  int num_initialized;
+  int num_done;
+  bool start;
+
+  SharedState() : cv(&mu) { }
+};
+
+// Per-thread state for concurrent executions of the same benchmark.
+struct ThreadState {
+  int tid;             // 0..n-1 when running in n threads
+  Random rand;         // Has different seeds for different threads
+  Stats stats;
+  SharedState* shared;
+
+  ThreadState(int index)
+      : tid(index),
+        rand(1000 + index) {
+  }
+};
+
+}  // namespace
+
+class Benchmark {
+ private:
+  Cache* cache_;
+  const FilterPolicy* filter_policy_;
+  DB* db_;
+  int num_;
+  int value_size_;
+  int entries_per_batch_;
+  WriteOptions write_options_;
+  int reads_;
+  int heap_counter_;
+
+  void PrintHeader() {
+    const int kKeySize = 16;
+    PrintEnvironment();
+    fprintf(stdout, "Keys:       %d bytes each\n", kKeySize);
+    fprintf(stdout, "Values:     %d bytes each (%d bytes after compression)\n",
+            FLAGS_value_size,
+            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));
+    fprintf(stdout, "Entries:    %d\n", num_);
+    fprintf(stdout, "RawSize:    %.1f MB (estimated)\n",
+            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
+             / 1048576.0));
+    fprintf(stdout, "FileSize:   %.1f MB (estimated)\n",
+            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)
+             / 1048576.0));
+    PrintWarnings();
+    fprintf(stdout, "------------------------------------------------\n");
+  }
+
+  void PrintWarnings() {
+#if defined(__GNUC__) && !defined(__OPTIMIZE__)
+    fprintf(stdout,
+            "WARNING: Optimization is disabled: benchmarks unnecessarily slow\n"
+            );
+#endif
+#ifndef NDEBUG
+    fprintf(stdout,
+            "WARNING: Assertions are enabled; benchmarks unnecessarily slow\n");
+#endif
+
+    // See if snappy is working by attempting to compress a compressible string
+    const char text[] = "yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy";
+    std::string compressed;
+    if (!port::Snappy_Compress(text, sizeof(text), &compressed)) {
+      fprintf(stdout, "WARNING: Snappy compression is not enabled\n");
+    } else if (compressed.size() >= sizeof(text)) {
+      fprintf(stdout, "WARNING: Snappy compression is not effective\n");
+    }
+  }
+
+  void PrintEnvironment() {
+    fprintf(stderr, "LevelDB:    version %d.%d\n",
+            kMajorVersion, kMinorVersion);
+
+#if defined(__linux)
+    time_t now = time(NULL);
+    fprintf(stderr, "Date:       %s", ctime(&now));  // ctime() adds newline
+
+    FILE* cpuinfo = fopen("/proc/cpuinfo", "r");
+    if (cpuinfo != NULL) {
+      char line[1000];
+      int num_cpus = 0;
+      std::string cpu_type;
+      std::string cache_size;
+      while (fgets(line, sizeof(line), cpuinfo) != NULL) {
+        const char* sep = strchr(line, ':');
+        if (sep == NULL) {
+          continue;
+        }
+        Slice key = TrimSpace(Slice(line, sep - 1 - line));
+        Slice val = TrimSpace(Slice(sep + 1));
+        if (key == "model name") {
+          ++num_cpus;
+          cpu_type = val.ToString();
+        } else if (key == "cache size") {
+          cache_size = val.ToString();
+        }
+      }
+      fclose(cpuinfo);
+      fprintf(stderr, "CPU:        %d * %s\n", num_cpus, cpu_type.c_str());
+      fprintf(stderr, "CPUCache:   %s\n", cache_size.c_str());
+    }
+#endif
+  }
+
+ public:
+  Benchmark()
+  : cache_(FLAGS_cache_size >= 0 ? NewLRUCache(FLAGS_cache_size) : NULL),
+    filter_policy_(FLAGS_bloom_bits >= 0
+                   ? NewBloomFilterPolicy(FLAGS_bloom_bits)
+                   : NULL),
+    db_(NULL),
+    num_(FLAGS_num),
+    value_size_(FLAGS_value_size),
+    entries_per_batch_(1),
+    reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),
+    heap_counter_(0) {
+    std::vector<std::string> files;
+    Env::Default()->GetChildren(FLAGS_db, &files);
+    for (size_t i = 0; i < files.size(); i++) {
+      if (Slice(files[i]).starts_with("heap-")) {
+        Env::Default()->DeleteFile(std::string(FLAGS_db) + "/" + files[i]);
+      }
+    }
+    if (!FLAGS_use_existing_db) {
+      DestroyDB(FLAGS_db, Options());
+    }
+  }
+
+  ~Benchmark() {
+    delete db_;
+    delete cache_;
+    delete filter_policy_;
+  }
+
+  void Run() {
+    PrintHeader();
+    Open();
+
+    const char* benchmarks = FLAGS_benchmarks;
+    while (benchmarks != NULL) {
+      const char* sep = strchr(benchmarks, ',');
+      Slice name;
+      if (sep == NULL) {
+        name = benchmarks;
+        benchmarks = NULL;
+      } else {
+        name = Slice(benchmarks, sep - benchmarks);
+        benchmarks = sep + 1;
+      }
+
+      // Reset parameters that may be overriddden bwlow
+      num_ = FLAGS_num;
+      reads_ = (FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads);
+      value_size_ = FLAGS_value_size;
+      entries_per_batch_ = 1;
+      write_options_ = WriteOptions();
+
+      void (Benchmark::*method)(ThreadState*) = NULL;
+      bool fresh_db = false;
+      int num_threads = FLAGS_threads;
+
+      if (name == Slice("fillseq")) {
+        fresh_db = true;
+        method = &Benchmark::WriteSeq;
+      } else if (name == Slice("fillbatch")) {
+        fresh_db = true;
+        entries_per_batch_ = 1000;
+        method = &Benchmark::WriteSeq;
+      } else if (name == Slice("fillrandom")) {
+        fresh_db = true;
+        method = &Benchmark::WriteRandom;
+      } else if (name == Slice("overwrite")) {
+        fresh_db = false;
+        method = &Benchmark::WriteRandom;
+      } else if (name == Slice("fillsync")) {
+        fresh_db = true;
+        num_ /= 1000;
+        write_options_.sync = true;
+        method = &Benchmark::WriteRandom;
+      } else if (name == Slice("fill100K")) {
+        fresh_db = true;
+        num_ /= 1000;
+        value_size_ = 100 * 1000;
+        method = &Benchmark::WriteRandom;
+      } else if (name == Slice("readseq")) {
+        method = &Benchmark::ReadSequential;
+      } else if (name == Slice("readreverse")) {
+        method = &Benchmark::ReadReverse;
+      } else if (name == Slice("readrandom")) {
+        method = &Benchmark::ReadRandom;
+      } else if (name == Slice("readmissing")) {
+        method = &Benchmark::ReadMissing;
+      } else if (name == Slice("seekrandom")) {
+        method = &Benchmark::SeekRandom;
+      } else if (name == Slice("readhot")) {
+        method = &Benchmark::ReadHot;
+      } else if (name == Slice("readrandomsmall")) {
+        reads_ /= 1000;
+        method = &Benchmark::ReadRandom;
+      } else if (name == Slice("deleteseq")) {
+        method = &Benchmark::DeleteSeq;
+      } else if (name == Slice("deleterandom")) {
+        method = &Benchmark::DeleteRandom;
+      } else if (name == Slice("readwhilewriting")) {
+        num_threads++;  // Add extra thread for writing
+        method = &Benchmark::ReadWhileWriting;
+      } else if (name == Slice("compact")) {
+        method = &Benchmark::Compact;
+      } else if (name == Slice("crc32c")) {
+        method = &Benchmark::Crc32c;
+      } else if (name == Slice("acquireload")) {
+        method = &Benchmark::AcquireLoad;
+      } else if (name == Slice("snappycomp")) {
+        method = &Benchmark::SnappyCompress;
+      } else if (name == Slice("snappyuncomp")) {
+        method = &Benchmark::SnappyUncompress;
+      } else if (name == Slice("heapprofile")) {
+        HeapProfile();
+      } else if (name == Slice("stats")) {
+        PrintStats("leveldb.stats");
+      } else if (name == Slice("sstables")) {
+        PrintStats("leveldb.sstables");
+      } else {
+        if (name != Slice()) {  // No error message for empty name
+          fprintf(stderr, "unknown benchmark '%s'\n", name.ToString().c_str());
+        }
+      }
+
+      if (fresh_db) {
+        if (FLAGS_use_existing_db) {
+          fprintf(stdout, "%-12s : skipped (--use_existing_db is true)\n",
+                  name.ToString().c_str());
+          method = NULL;
+        } else {
+          delete db_;
+          db_ = NULL;
+          DestroyDB(FLAGS_db, Options());
+          Open();
+        }
+      }
+
+      if (method != NULL) {
+        RunBenchmark(num_threads, name, method);
+      }
+    }
+  }
+
+ private:
+  struct ThreadArg {
+    Benchmark* bm;
+    SharedState* shared;
+    ThreadState* thread;
+    void (Benchmark::*method)(ThreadState*);
+  };
+
+  static void ThreadBody(void* v) {
+    ThreadArg* arg = reinterpret_cast<ThreadArg*>(v);
+    SharedState* shared = arg->shared;
+    ThreadState* thread = arg->thread;
+    {
+      MutexLock l(&shared->mu);
+      shared->num_initialized++;
+      if (shared->num_initialized >= shared->total) {
+        shared->cv.SignalAll();
+      }
+      while (!shared->start) {
+        shared->cv.Wait();
+      }
+    }
+
+    thread->stats.Start();
+    (arg->bm->*(arg->method))(thread);
+    thread->stats.Stop();
+
+    {
+      MutexLock l(&shared->mu);
+      shared->num_done++;
+      if (shared->num_done >= shared->total) {
+        shared->cv.SignalAll();
+      }
+    }
+  }
+
+  void RunBenchmark(int n, Slice name,
+                    void (Benchmark::*method)(ThreadState*)) {
+    SharedState shared;
+    shared.total = n;
+    shared.num_initialized = 0;
+    shared.num_done = 0;
+    shared.start = false;
+
+    ThreadArg* arg = new ThreadArg[n];
+    for (int i = 0; i < n; i++) {
+      arg[i].bm = this;
+      arg[i].method = method;
+      arg[i].shared = &shared;
+      arg[i].thread = new ThreadState(i);
+      arg[i].thread->shared = &shared;
+      Env::Default()->StartThread(ThreadBody, &arg[i]);
+    }
+
+    shared.mu.Lock();
+    while (shared.num_initialized < n) {
+      shared.cv.Wait();
+    }
+
+    shared.start = true;
+    shared.cv.SignalAll();
+    while (shared.num_done < n) {
+      shared.cv.Wait();
+    }
+    shared.mu.Unlock();
+
+    for (int i = 1; i < n; i++) {
+      arg[0].thread->stats.Merge(arg[i].thread->stats);
+    }
+    arg[0].thread->stats.Report(name);
+
+    for (int i = 0; i < n; i++) {
+      delete arg[i].thread;
+    }
+    delete[] arg;
+  }
+
+  void Crc32c(ThreadState* thread) {
+    // Checksum about 500MB of data total
+    const int size = 4096;
+    const char* label = "(4K per op)";
+    std::string data(size, 'x');
+    int64_t bytes = 0;
+    uint32_t crc = 0;
+    while (bytes < 500 * 1048576) {
+      crc = crc32c::Value(data.data(), size);
+      thread->stats.FinishedSingleOp();
+      bytes += size;
+    }
+    // Print so result is not dead
+    fprintf(stderr, "... crc=0x%x\r", static_cast<unsigned int>(crc));
+
+    thread->stats.AddBytes(bytes);
+    thread->stats.AddMessage(label);
+  }
+
+  void AcquireLoad(ThreadState* thread) {
+    int dummy;
+    port::AtomicPointer ap(&dummy);
+    int count = 0;
+    void *ptr = NULL;
+    thread->stats.AddMessage("(each op is 1000 loads)");
+    while (count < 100000) {
+      for (int i = 0; i < 1000; i++) {
+        ptr = ap.Acquire_Load();
+      }
+      count++;
+      thread->stats.FinishedSingleOp();
+    }
+    if (ptr == NULL) exit(1); // Disable unused variable warning.
+  }
+
+  void SnappyCompress(ThreadState* thread) {
+    RandomGenerator gen;
+    Slice input = gen.Generate(Options().block_size);
+    int64_t bytes = 0;
+    int64_t produced = 0;
+    bool ok = true;
+    std::string compressed;
+    while (ok && bytes < 1024 * 1048576) {  // Compress 1G
+      ok = port::Snappy_Compress(input.data(), input.size(), &compressed);
+      produced += compressed.size();
+      bytes += input.size();
+      thread->stats.FinishedSingleOp();
+    }
+
+    if (!ok) {
+      thread->stats.AddMessage("(snappy failure)");
+    } else {
+      char buf[100];
+      snprintf(buf, sizeof(buf), "(output: %.1f%%)",
+               (produced * 100.0) / bytes);
+      thread->stats.AddMessage(buf);
+      thread->stats.AddBytes(bytes);
+    }
+  }
+
+  void SnappyUncompress(ThreadState* thread) {
+    RandomGenerator gen;
+    Slice input = gen.Generate(Options().block_size);
+    std::string compressed;
+    bool ok = port::Snappy_Compress(input.data(), input.size(), &compressed);
+    int64_t bytes = 0;
+    char* uncompressed = new char[input.size()];
+    while (ok && bytes < 1024 * 1048576) {  // Compress 1G
+      ok =  port::Snappy_Uncompress(compressed.data(), compressed.size(),
+                                    uncompressed);
+      bytes += input.size();
+      thread->stats.FinishedSingleOp();
+    }
+    delete[] uncompressed;
+
+    if (!ok) {
+      thread->stats.AddMessage("(snappy failure)");
+    } else {
+      thread->stats.AddBytes(bytes);
+    }
+  }
+
+  void Open() {
+    assert(db_ == NULL);
+    Options options;
+    options.create_if_missing = !FLAGS_use_existing_db;
+    options.block_cache = cache_;
+    options.write_buffer_size = FLAGS_write_buffer_size;
+    options.max_open_files = FLAGS_open_files;
+    options.filter_policy = filter_policy_;
+    Status s = DB::Open(options, FLAGS_db, &db_);
+    if (!s.ok()) {
+      fprintf(stderr, "open error: %s\n", s.ToString().c_str());
+      exit(1);
+    }
+  }
+
+  void WriteSeq(ThreadState* thread) {
+    DoWrite(thread, true);
+  }
+
+  void WriteRandom(ThreadState* thread) {
+    DoWrite(thread, false);
+  }
+
+  void DoWrite(ThreadState* thread, bool seq) {
+    if (num_ != FLAGS_num) {
+      char msg[100];
+      snprintf(msg, sizeof(msg), "(%d ops)", num_);
+      thread->stats.AddMessage(msg);
+    }
+
+    RandomGenerator gen;
+    WriteBatch batch;
+    Status s;
+    int64_t bytes = 0;
+    for (int i = 0; i < num_; i += entries_per_batch_) {
+      batch.Clear();
+      for (int j = 0; j < entries_per_batch_; j++) {
+        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
+        char key[100];
+        snprintf(key, sizeof(key), "%016d", k);
+        batch.Put(key, gen.Generate(value_size_));
+        bytes += value_size_ + strlen(key);
+        thread->stats.FinishedSingleOp();
+      }
+      s = db_->Write(write_options_, &batch);
+      if (!s.ok()) {
+        fprintf(stderr, "put error: %s\n", s.ToString().c_str());
+        exit(1);
+      }
+    }
+    thread->stats.AddBytes(bytes);
+  }
+
+  void ReadSequential(ThreadState* thread) {
+    Iterator* iter = db_->NewIterator(ReadOptions());
+    int i = 0;
+    int64_t bytes = 0;
+    for (iter->SeekToFirst(); i < reads_ && iter->Valid(); iter->Next()) {
+      bytes += iter->key().size() + iter->value().size();
+      thread->stats.FinishedSingleOp();
+      ++i;
+    }
+    delete iter;
+    thread->stats.AddBytes(bytes);
+  }
+
+  void ReadReverse(ThreadState* thread) {
+    Iterator* iter = db_->NewIterator(ReadOptions());
+    int i = 0;
+    int64_t bytes = 0;
+    for (iter->SeekToLast(); i < reads_ && iter->Valid(); iter->Prev()) {
+      bytes += iter->key().size() + iter->value().size();
+      thread->stats.FinishedSingleOp();
+      ++i;
+    }
+    delete iter;
+    thread->stats.AddBytes(bytes);
+  }
+
+  void ReadRandom(ThreadState* thread) {
+    ReadOptions options;
+    std::string value;
+    int found = 0;
+    for (int i = 0; i < reads_; i++) {
+      char key[100];
+      const int k = thread->rand.Next() % FLAGS_num;
+      snprintf(key, sizeof(key), "%016d", k);
+      if (db_->Get(options, key, &value).ok()) {
+        found++;
+      }
+      thread->stats.FinishedSingleOp();
+    }
+    char msg[100];
+    snprintf(msg, sizeof(msg), "(%d of %d found)", found, num_);
+    thread->stats.AddMessage(msg);
+  }
+
+  void ReadMissing(ThreadState* thread) {
+    ReadOptions options;
+    std::string value;
+    for (int i = 0; i < reads_; i++) {
+      char key[100];
+      const int k = thread->rand.Next() % FLAGS_num;
+      snprintf(key, sizeof(key), "%016d.", k);
+      db_->Get(options, key, &value);
+      thread->stats.FinishedSingleOp();
+    }
+  }
+
+  void ReadHot(ThreadState* thread) {
+    ReadOptions options;
+    std::string value;
+    const int range = (FLAGS_num + 99) / 100;
+    for (int i = 0; i < reads_; i++) {
+      char key[100];
+      const int k = thread->rand.Next() % range;
+      snprintf(key, sizeof(key), "%016d", k);
+      db_->Get(options, key, &value);
+      thread->stats.FinishedSingleOp();
+    }
+  }
+
+  void SeekRandom(ThreadState* thread) {
+    ReadOptions options;
+    std::string value;
+    int found = 0;
+    for (int i = 0; i < reads_; i++) {
+      Iterator* iter = db_->NewIterator(options);
+      char key[100];
+      const int k = thread->rand.Next() % FLAGS_num;
+      snprintf(key, sizeof(key), "%016d", k);
+      iter->Seek(key);
+      if (iter->Valid() && iter->key() == key) found++;
+      delete iter;
+      thread->stats.FinishedSingleOp();
+    }
+    char msg[100];
+    snprintf(msg, sizeof(msg), "(%d of %d found)", found, num_);
+    thread->stats.AddMessage(msg);
+  }
+
+  void DoDelete(ThreadState* thread, bool seq) {
+    RandomGenerator gen;
+    WriteBatch batch;
+    Status s;
+    for (int i = 0; i < num_; i += entries_per_batch_) {
+      batch.Clear();
+      for (int j = 0; j < entries_per_batch_; j++) {
+        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
+        char key[100];
+        snprintf(key, sizeof(key), "%016d", k);
+        batch.Delete(key);
+        thread->stats.FinishedSingleOp();
+      }
+      s = db_->Write(write_options_, &batch);
+      if (!s.ok()) {
+        fprintf(stderr, "del error: %s\n", s.ToString().c_str());
+        exit(1);
+      }
+    }
+  }
+
+  void DeleteSeq(ThreadState* thread) {
+    DoDelete(thread, true);
+  }
+
+  void DeleteRandom(ThreadState* thread) {
+    DoDelete(thread, false);
+  }
+
+  void ReadWhileWriting(ThreadState* thread) {
+    if (thread->tid > 0) {
+      ReadRandom(thread);
+    } else {
+      // Special thread that keeps writing until other threads are done.
+      RandomGenerator gen;
+      while (true) {
+        {
+          MutexLock l(&thread->shared->mu);
+          if (thread->shared->num_done + 1 >= thread->shared->num_initialized) {
+            // Other threads have finished
+            break;
+          }
+        }
+
+        const int k = thread->rand.Next() % FLAGS_num;
+        char key[100];
+        snprintf(key, sizeof(key), "%016d", k);
+        Status s = db_->Put(write_options_, key, gen.Generate(value_size_));
+        if (!s.ok()) {
+          fprintf(stderr, "put error: %s\n", s.ToString().c_str());
+          exit(1);
+        }
+      }
+
+      // Do not count any of the preceding work/delay in stats.
+      thread->stats.Start();
+    }
+  }
+
+  void Compact(ThreadState* thread) {
+    db_->CompactRange(NULL, NULL);
+  }
+
+  void PrintStats(const char* key) {
+    std::string stats;
+    if (!db_->GetProperty(key, &stats)) {
+      stats = "(failed)";
+    }
+    fprintf(stdout, "\n%s\n", stats.c_str());
+  }
+
+  static void WriteToFile(void* arg, const char* buf, int n) {
+    reinterpret_cast<WritableFile*>(arg)->Append(Slice(buf, n));
+  }
+
+  void HeapProfile() {
+    char fname[100];
+    snprintf(fname, sizeof(fname), "%s/heap-%04d", FLAGS_db, ++heap_counter_);
+    WritableFile* file;
+    Status s = Env::Default()->NewWritableFile(fname, &file);
+    if (!s.ok()) {
+      fprintf(stderr, "%s\n", s.ToString().c_str());
+      return;
+    }
+    bool ok = port::GetHeapProfile(WriteToFile, file);
+    delete file;
+    if (!ok) {
+      fprintf(stderr, "heap profiling not supported\n");
+      Env::Default()->DeleteFile(fname);
+    }
+  }
+};
+
+}  // namespace leveldb
+
+extern "C" int leveldb_benchmark(int argc, char** argv) {
+  FLAGS_write_buffer_size = leveldb::Options().write_buffer_size;
+  FLAGS_open_files = leveldb::Options().max_open_files;
+  std::string default_db_path;
+
+  for (int i = 1; i < argc; i++) {
+    double d;
+    int n;
+    char junk;
+    if (leveldb::Slice(argv[i]).starts_with("--benchmarks=")) {
+      FLAGS_benchmarks = argv[i] + strlen("--benchmarks=");
+    } else if (sscanf(argv[i], "--compression_ratio=%lf%c", &d, &junk) == 1) {
+      FLAGS_compression_ratio = d;
+    } else if (sscanf(argv[i], "--histogram=%d%c", &n, &junk) == 1 &&
+               (n == 0 || n == 1)) {
+      FLAGS_histogram = n;
+    } else if (sscanf(argv[i], "--use_existing_db=%d%c", &n, &junk) == 1 &&
+               (n == 0 || n == 1)) {
+      FLAGS_use_existing_db = n;
+    } else if (sscanf(argv[i], "--num=%d%c", &n, &junk) == 1) {
+      FLAGS_num = n;
+    } else if (sscanf(argv[i], "--reads=%d%c", &n, &junk) == 1) {
+      FLAGS_reads = n;
+    } else if (sscanf(argv[i], "--threads=%d%c", &n, &junk) == 1) {
+      FLAGS_threads = n;
+    } else if (sscanf(argv[i], "--value_size=%d%c", &n, &junk) == 1) {
+      FLAGS_value_size = n;
+    } else if (sscanf(argv[i], "--write_buffer_size=%d%c", &n, &junk) == 1) {
+      FLAGS_write_buffer_size = n;
+    } else if (sscanf(argv[i], "--cache_size=%d%c", &n, &junk) == 1) {
+      FLAGS_cache_size = n;
+    } else if (sscanf(argv[i], "--bloom_bits=%d%c", &n, &junk) == 1) {
+      FLAGS_bloom_bits = n;
+    } else if (sscanf(argv[i], "--open_files=%d%c", &n, &junk) == 1) {
+      FLAGS_open_files = n;
+    } else if (strncmp(argv[i], "--db=", 5) == 0) {
+      FLAGS_db = argv[i] + 5;
+    } else {
+      fprintf(stderr, "Invalid flag '%s'\n", argv[i]);
+      exit(1);
+    }
+  }
+
+  // Choose a location for the test database if none given with --db=<path>
+  if (FLAGS_db == NULL) {
+      leveldb::Env::Default()->GetTestDirectory(&default_db_path);
+      default_db_path += "/dbbench";
+      FLAGS_db = default_db_path.c_str();
+  }
+
+  leveldb::Benchmark benchmark;
+  benchmark.Run();
+  return 0;
+}
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/db_impl.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/db_impl.cc
new file mode 100644
index 0000000..faf5e7d
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/db_impl.cc
@@ -0,0 +1,1513 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "db/db_impl.h"
+
+#include <algorithm>
+#include <set>
+#include <string>
+#include <stdint.h>
+#include <stdio.h>
+#include <vector>
+#include "db/builder.h"
+#include "db/db_iter.h"
+#include "db/dbformat.h"
+#include "db/filename.h"
+#include "db/log_reader.h"
+#include "db/log_writer.h"
+#include "db/memtable.h"
+#include "db/table_cache.h"
+#include "db/version_set.h"
+#include "db/write_batch_internal.h"
+#include "leveldb/db.h"
+#include "leveldb/env.h"
+#include "leveldb/status.h"
+#include "leveldb/table.h"
+#include "leveldb/table_builder.h"
+#include "port/port.h"
+#include "table/block.h"
+#include "table/merger.h"
+#include "table/two_level_iterator.h"
+#include "util/coding.h"
+#include "util/logging.h"
+#include "util/mutexlock.h"
+
+namespace leveldb {
+
+const int kNumNonTableCacheFiles = 10;
+
+// Information kept for every waiting writer
+struct DBImpl::Writer {
+  Status status;
+  WriteBatch* batch;
+  bool sync;
+  bool done;
+  port::CondVar cv;
+
+  explicit Writer(port::Mutex* mu) : cv(mu) { }
+};
+
+struct DBImpl::CompactionState {
+  Compaction* const compaction;
+
+  // Sequence numbers < smallest_snapshot are not significant since we
+  // will never have to service a snapshot below smallest_snapshot.
+  // Therefore if we have seen a sequence number S <= smallest_snapshot,
+  // we can drop all entries for the same key with sequence numbers < S.
+  SequenceNumber smallest_snapshot;
+
+  // Files produced by compaction
+  struct Output {
+    uint64_t number;
+    uint64_t file_size;
+    InternalKey smallest, largest;
+  };
+  std::vector<Output> outputs;
+
+  // State kept for output being generated
+  WritableFile* outfile;
+  TableBuilder* builder;
+
+  uint64_t total_bytes;
+
+  Output* current_output() { return &outputs[outputs.size()-1]; }
+
+  explicit CompactionState(Compaction* c)
+      : compaction(c),
+        outfile(NULL),
+        builder(NULL),
+        total_bytes(0) {
+  }
+};
+
+// Fix user-supplied options to be reasonable
+template <class T,class V>
+static void ClipToRange(T* ptr, V minvalue, V maxvalue) {
+  if (static_cast<V>(*ptr) > maxvalue) *ptr = maxvalue;
+  if (static_cast<V>(*ptr) < minvalue) *ptr = minvalue;
+}
+Options SanitizeOptions(const std::string& dbname,
+                        const InternalKeyComparator* icmp,
+                        const InternalFilterPolicy* ipolicy,
+                        const Options& src) {
+  Options result = src;
+  result.comparator = icmp;
+  result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;
+  ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);
+  ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);
+  ClipToRange(&result.block_size,        1<<10,                       4<<20);
+  if (result.info_log == NULL) {
+    // Open a log file in the same directory as the db
+    src.env->CreateDir(dbname);  // In case it does not exist
+    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));
+    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);
+    if (!s.ok()) {
+      // No place suitable for logging
+      result.info_log = NULL;
+    }
+  }
+  if (result.block_cache == NULL) {
+    result.block_cache = NewLRUCache(8 << 20);
+  }
+  return result;
+}
+
+DBImpl::DBImpl(const Options& raw_options, const std::string& dbname)
+    : env_(raw_options.env),
+      internal_comparator_(raw_options.comparator),
+      internal_filter_policy_(raw_options.filter_policy),
+      options_(SanitizeOptions(dbname, &internal_comparator_,
+                               &internal_filter_policy_, raw_options)),
+      owns_info_log_(options_.info_log != raw_options.info_log),
+      owns_cache_(options_.block_cache != raw_options.block_cache),
+      dbname_(dbname),
+      db_lock_(NULL),
+      shutting_down_(NULL),
+      bg_cv_(&mutex_),
+      mem_(new MemTable(internal_comparator_)),
+      imm_(NULL),
+      logfile_(NULL),
+      logfile_number_(0),
+      log_(NULL),
+      seed_(0),
+      tmp_batch_(new WriteBatch),
+      bg_compaction_scheduled_(false),
+      manual_compaction_(NULL) {
+  mem_->Ref();
+  has_imm_.Release_Store(NULL);
+
+  // Reserve ten files or so for other uses and give the rest to TableCache.
+  const int table_cache_size = options_.max_open_files - kNumNonTableCacheFiles;
+  table_cache_ = new TableCache(dbname_, &options_, table_cache_size);
+
+  versions_ = new VersionSet(dbname_, &options_, table_cache_,
+                             &internal_comparator_);
+}
+
+DBImpl::~DBImpl() {
+  // Wait for background work to finish
+  mutex_.Lock();
+  shutting_down_.Release_Store(this);  // Any non-NULL value is ok
+  while (bg_compaction_scheduled_) {
+    bg_cv_.Wait();
+  }
+  mutex_.Unlock();
+
+  if (db_lock_ != NULL) {
+    env_->UnlockFile(db_lock_);
+  }
+
+  delete versions_;
+  if (mem_ != NULL) mem_->Unref();
+  if (imm_ != NULL) imm_->Unref();
+  delete tmp_batch_;
+  delete log_;
+  delete logfile_;
+  delete table_cache_;
+
+  if (owns_info_log_) {
+    delete options_.info_log;
+  }
+  if (owns_cache_) {
+    delete options_.block_cache;
+  }
+}
+
+Status DBImpl::NewDB() {
+  VersionEdit new_db;
+  new_db.SetComparatorName(user_comparator()->Name());
+  new_db.SetLogNumber(0);
+  new_db.SetNextFile(2);
+  new_db.SetLastSequence(0);
+
+  const std::string manifest = DescriptorFileName(dbname_, 1);
+  WritableFile* file;
+  Status s = env_->NewWritableFile(manifest, &file);
+  if (!s.ok()) {
+    return s;
+  }
+  {
+    log::Writer log(file);
+    std::string record;
+    new_db.EncodeTo(&record);
+    s = log.AddRecord(record);
+    if (s.ok()) {
+      s = file->Close();
+    }
+  }
+  delete file;
+  if (s.ok()) {
+    // Make "CURRENT" file that points to the new manifest file.
+    s = SetCurrentFile(env_, dbname_, 1);
+  } else {
+    env_->DeleteFile(manifest);
+  }
+  return s;
+}
+
+void DBImpl::MaybeIgnoreError(Status* s) const {
+  if (s->ok() || options_.paranoid_checks) {
+    // No change needed
+  } else {
+    Log(options_.info_log, "Ignoring error %s", s->ToString().c_str());
+    *s = Status::OK();
+  }
+}
+
+void DBImpl::DeleteObsoleteFiles() {
+  if (!bg_error_.ok()) {
+    // After a background error, we don't know whether a new version may
+    // or may not have been committed, so we cannot safely garbage collect.
+    return;
+  }
+
+  // Make a set of all of the live files
+  std::set<uint64_t> live = pending_outputs_;
+  versions_->AddLiveFiles(&live);
+
+  std::vector<std::string> filenames;
+  env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose
+  uint64_t number;
+  FileType type;
+  for (size_t i = 0; i < filenames.size(); i++) {
+    if (ParseFileName(filenames[i], &number, &type)) {
+      bool keep = true;
+      switch (type) {
+        case kLogFile:
+          keep = ((number >= versions_->LogNumber()) ||
+                  (number == versions_->PrevLogNumber()));
+          break;
+        case kDescriptorFile:
+          // Keep my manifest file, and any newer incarnations'
+          // (in case there is a race that allows other incarnations)
+          keep = (number >= versions_->ManifestFileNumber());
+          break;
+        case kTableFile:
+          keep = (live.find(number) != live.end());
+          break;
+        case kTempFile:
+          // Any temp files that are currently being written to must
+          // be recorded in pending_outputs_, which is inserted into "live"
+          keep = (live.find(number) != live.end());
+          break;
+        case kCurrentFile:
+        case kDBLockFile:
+        case kInfoLogFile:
+          keep = true;
+          break;
+      }
+
+      if (!keep) {
+        if (type == kTableFile) {
+          table_cache_->Evict(number);
+        }
+        Log(options_.info_log, "Delete type=%d #%lld\n",
+            int(type),
+            static_cast<unsigned long long>(number));
+        env_->DeleteFile(dbname_ + "/" + filenames[i]);
+      }
+    }
+  }
+}
+
+Status DBImpl::Recover(VersionEdit* edit) {
+  mutex_.AssertHeld();
+
+  // Ignore error from CreateDir since the creation of the DB is
+  // committed only when the descriptor is created, and this directory
+  // may already exist from a previous failed creation attempt.
+  env_->CreateDir(dbname_);
+  assert(db_lock_ == NULL);
+  Status s = env_->LockFile(LockFileName(dbname_), &db_lock_);
+  if (!s.ok()) {
+    return s;
+  }
+
+  if (!env_->FileExists(CurrentFileName(dbname_))) {
+    if (options_.create_if_missing) {
+      s = NewDB();
+      if (!s.ok()) {
+        return s;
+      }
+    } else {
+      return Status::InvalidArgument(
+          dbname_, "does not exist (create_if_missing is false)");
+    }
+  } else {
+    if (options_.error_if_exists) {
+      return Status::InvalidArgument(
+          dbname_, "exists (error_if_exists is true)");
+    }
+  }
+
+  s = versions_->Recover();
+  if (s.ok()) {
+    SequenceNumber max_sequence(0);
+
+    // Recover from all newer log files than the ones named in the
+    // descriptor (new log files may have been added by the previous
+    // incarnation without registering them in the descriptor).
+    //
+    // Note that PrevLogNumber() is no longer used, but we pay
+    // attention to it in case we are recovering a database
+    // produced by an older version of leveldb.
+    const uint64_t min_log = versions_->LogNumber();
+    const uint64_t prev_log = versions_->PrevLogNumber();
+    std::vector<std::string> filenames;
+    s = env_->GetChildren(dbname_, &filenames);
+    if (!s.ok()) {
+      return s;
+    }
+    std::set<uint64_t> expected;
+    versions_->AddLiveFiles(&expected);
+    uint64_t number;
+    FileType type;
+    std::vector<uint64_t> logs;
+    for (size_t i = 0; i < filenames.size(); i++) {
+      if (ParseFileName(filenames[i], &number, &type)) {
+        expected.erase(number);
+        if (type == kLogFile && ((number >= min_log) || (number == prev_log)))
+          logs.push_back(number);
+      }
+    }
+    if (!expected.empty()) {
+      char buf[50];
+      snprintf(buf, sizeof(buf), "%d missing files; e.g.",
+               static_cast<int>(expected.size()));
+      return Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));
+    }
+
+    // Recover in the order in which the logs were generated
+    std::sort(logs.begin(), logs.end());
+    for (size_t i = 0; i < logs.size(); i++) {
+      s = RecoverLogFile(logs[i], edit, &max_sequence);
+
+      // The previous incarnation may not have written any MANIFEST
+      // records after allocating this log number.  So we manually
+      // update the file number allocation counter in VersionSet.
+      versions_->MarkFileNumberUsed(logs[i]);
+    }
+
+    if (s.ok()) {
+      if (versions_->LastSequence() < max_sequence) {
+        versions_->SetLastSequence(max_sequence);
+      }
+    }
+  }
+
+  return s;
+}
+
+Status DBImpl::RecoverLogFile(uint64_t log_number,
+                              VersionEdit* edit,
+                              SequenceNumber* max_sequence) {
+  struct LogReporter : public log::Reader::Reporter {
+    Env* env;
+    Logger* info_log;
+    const char* fname;
+    Status* status;  // NULL if options_.paranoid_checks==false
+    virtual void Corruption(size_t bytes, const Status& s) {
+      Log(info_log, "%s%s: dropping %d bytes; %s",
+          (this->status == NULL ? "(ignoring error) " : ""),
+          fname, static_cast<int>(bytes), s.ToString().c_str());
+      if (this->status != NULL && this->status->ok()) *this->status = s;
+    }
+  };
+
+  mutex_.AssertHeld();
+
+  // Open the log file
+  std::string fname = LogFileName(dbname_, log_number);
+  SequentialFile* file;
+  Status status = env_->NewSequentialFile(fname, &file);
+  if (!status.ok()) {
+    MaybeIgnoreError(&status);
+    return status;
+  }
+
+  // Create the log reader.
+  LogReporter reporter;
+  reporter.env = env_;
+  reporter.info_log = options_.info_log;
+  reporter.fname = fname.c_str();
+  reporter.status = (options_.paranoid_checks ? &status : NULL);
+  // We intentially make log::Reader do checksumming even if
+  // paranoid_checks==false so that corruptions cause entire commits
+  // to be skipped instead of propagating bad information (like overly
+  // large sequence numbers).
+  log::Reader reader(file, &reporter, true/*checksum*/,
+                     0/*initial_offset*/);
+  Log(options_.info_log, "Recovering log #%llu",
+      (unsigned long long) log_number);
+
+  // Read all the records and add to a memtable
+  std::string scratch;
+  Slice record;
+  WriteBatch batch;
+  MemTable* mem = NULL;
+  while (reader.ReadRecord(&record, &scratch) &&
+         status.ok()) {
+    if (record.size() < 12) {
+      reporter.Corruption(
+          record.size(), Status::Corruption("log record too small"));
+      continue;
+    }
+    WriteBatchInternal::SetContents(&batch, record);
+
+    if (mem == NULL) {
+      mem = new MemTable(internal_comparator_);
+      mem->Ref();
+    }
+    status = WriteBatchInternal::InsertInto(&batch, mem);
+    MaybeIgnoreError(&status);
+    if (!status.ok()) {
+      break;
+    }
+    const SequenceNumber last_seq =
+        WriteBatchInternal::Sequence(&batch) +
+        WriteBatchInternal::Count(&batch) - 1;
+    if (last_seq > *max_sequence) {
+      *max_sequence = last_seq;
+    }
+
+    if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {
+      status = WriteLevel0Table(mem, edit, NULL);
+      if (!status.ok()) {
+        // Reflect errors immediately so that conditions like full
+        // file-systems cause the DB::Open() to fail.
+        break;
+      }
+      mem->Unref();
+      mem = NULL;
+    }
+  }
+
+  if (status.ok() && mem != NULL) {
+    status = WriteLevel0Table(mem, edit, NULL);
+    // Reflect errors immediately so that conditions like full
+    // file-systems cause the DB::Open() to fail.
+  }
+
+  if (mem != NULL) mem->Unref();
+  delete file;
+  return status;
+}
+
+Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,
+                                Version* base) {
+  mutex_.AssertHeld();
+  const uint64_t start_micros = env_->NowMicros();
+  FileMetaData meta;
+  meta.number = versions_->NewFileNumber();
+  pending_outputs_.insert(meta.number);
+  Iterator* iter = mem->NewIterator();
+  Log(options_.info_log, "Level-0 table #%llu: started",
+      (unsigned long long) meta.number);
+
+  Status s;
+  {
+    mutex_.Unlock();
+    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);
+    mutex_.Lock();
+  }
+
+  Log(options_.info_log, "Level-0 table #%llu: %lld bytes %s",
+      (unsigned long long) meta.number,
+      (unsigned long long) meta.file_size,
+      s.ToString().c_str());
+  delete iter;
+  pending_outputs_.erase(meta.number);
+
+
+  // Note that if file_size is zero, the file has been deleted and
+  // should not be added to the manifest.
+  int level = 0;
+  if (s.ok() && meta.file_size > 0) {
+    const Slice min_user_key = meta.smallest.user_key();
+    const Slice max_user_key = meta.largest.user_key();
+    if (base != NULL) {
+      level = base->PickLevelForMemTableOutput(min_user_key, max_user_key);
+    }
+    edit->AddFile(level, meta.number, meta.file_size,
+                  meta.smallest, meta.largest);
+  }
+
+  CompactionStats stats;
+  stats.micros = env_->NowMicros() - start_micros;
+  stats.bytes_written = meta.file_size;
+  stats_[level].Add(stats);
+  return s;
+}
+
+void DBImpl::CompactMemTable() {
+  mutex_.AssertHeld();
+  assert(imm_ != NULL);
+
+  // Save the contents of the memtable as a new Table
+  VersionEdit edit;
+  Version* base = versions_->current();
+  base->Ref();
+  Status s = WriteLevel0Table(imm_, &edit, base);
+  base->Unref();
+
+  if (s.ok() && shutting_down_.Acquire_Load()) {
+    s = Status::IOError("Deleting DB during memtable compaction");
+  }
+
+  // Replace immutable memtable with the generated Table
+  if (s.ok()) {
+    edit.SetPrevLogNumber(0);
+    edit.SetLogNumber(logfile_number_);  // Earlier logs no longer needed
+    s = versions_->LogAndApply(&edit, &mutex_);
+  }
+
+  if (s.ok()) {
+    // Commit to the new state
+    imm_->Unref();
+    imm_ = NULL;
+    has_imm_.Release_Store(NULL);
+    DeleteObsoleteFiles();
+  } else {
+    RecordBackgroundError(s);
+  }
+}
+
+void DBImpl::CompactRange(const Slice* begin, const Slice* end) {
+  int max_level_with_files = 1;
+  {
+    MutexLock l(&mutex_);
+    Version* base = versions_->current();
+    for (int level = 1; level < config::kNumLevels; level++) {
+      if (base->OverlapInLevel(level, begin, end)) {
+        max_level_with_files = level;
+      }
+    }
+  }
+  TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap
+  for (int level = 0; level < max_level_with_files; level++) {
+    TEST_CompactRange(level, begin, end);
+  }
+}
+
+void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {
+  assert(level >= 0);
+  assert(level + 1 < config::kNumLevels);
+
+  InternalKey begin_storage, end_storage;
+
+  ManualCompaction manual;
+  manual.level = level;
+  manual.done = false;
+  if (begin == NULL) {
+    manual.begin = NULL;
+  } else {
+    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);
+    manual.begin = &begin_storage;
+  }
+  if (end == NULL) {
+    manual.end = NULL;
+  } else {
+    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));
+    manual.end = &end_storage;
+  }
+
+  MutexLock l(&mutex_);
+  while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {
+    if (manual_compaction_ == NULL) {  // Idle
+      manual_compaction_ = &manual;
+      MaybeScheduleCompaction();
+    } else {  // Running either my compaction or another compaction.
+      bg_cv_.Wait();
+    }
+  }
+  if (manual_compaction_ == &manual) {
+    // Cancel my manual compaction since we aborted early for some reason.
+    manual_compaction_ = NULL;
+  }
+}
+
+Status DBImpl::TEST_CompactMemTable() {
+  // NULL batch means just wait for earlier writes to be done
+  Status s = Write(WriteOptions(), NULL);
+  if (s.ok()) {
+    // Wait until the compaction completes
+    MutexLock l(&mutex_);
+    while (imm_ != NULL && bg_error_.ok()) {
+      bg_cv_.Wait();
+    }
+    if (imm_ != NULL) {
+      s = bg_error_;
+    }
+  }
+  return s;
+}
+
+void DBImpl::RecordBackgroundError(const Status& s) {
+  mutex_.AssertHeld();
+  if (bg_error_.ok()) {
+    bg_error_ = s;
+    bg_cv_.SignalAll();
+  }
+}
+
+void DBImpl::MaybeScheduleCompaction() {
+  mutex_.AssertHeld();
+  if (bg_compaction_scheduled_) {
+    // Already scheduled
+  } else if (shutting_down_.Acquire_Load()) {
+    // DB is being deleted; no more background compactions
+  } else if (!bg_error_.ok()) {
+    // Already got an error; no more changes
+  } else if (imm_ == NULL &&
+             manual_compaction_ == NULL &&
+             !versions_->NeedsCompaction()) {
+    // No work to be done
+  } else {
+    bg_compaction_scheduled_ = true;
+    env_->Schedule(&DBImpl::BGWork, this);
+  }
+}
+
+void DBImpl::BGWork(void* db) {
+  reinterpret_cast<DBImpl*>(db)->BackgroundCall();
+}
+
+void DBImpl::BackgroundCall() {
+  MutexLock l(&mutex_);
+  assert(bg_compaction_scheduled_);
+  if (shutting_down_.Acquire_Load()) {
+    // No more background work when shutting down.
+  } else if (!bg_error_.ok()) {
+    // No more background work after a background error.
+  } else {
+    BackgroundCompaction();
+  }
+
+  bg_compaction_scheduled_ = false;
+
+  // Previous compaction may have produced too many files in a level,
+  // so reschedule another compaction if needed.
+  MaybeScheduleCompaction();
+  bg_cv_.SignalAll();
+}
+
+void DBImpl::BackgroundCompaction() {
+  mutex_.AssertHeld();
+
+  if (imm_ != NULL) {
+    CompactMemTable();
+    return;
+  }
+
+  Compaction* c;
+  bool is_manual = (manual_compaction_ != NULL);
+  InternalKey manual_end;
+  if (is_manual) {
+    ManualCompaction* m = manual_compaction_;
+    c = versions_->CompactRange(m->level, m->begin, m->end);
+    m->done = (c == NULL);
+    if (c != NULL) {
+      manual_end = c->input(0, c->num_input_files(0) - 1)->largest;
+    }
+    Log(options_.info_log,
+        "Manual compaction at level-%d from %s .. %s; will stop at %s\n",
+        m->level,
+        (m->begin ? m->begin->DebugString().c_str() : "(begin)"),
+        (m->end ? m->end->DebugString().c_str() : "(end)"),
+        (m->done ? "(end)" : manual_end.DebugString().c_str()));
+  } else {
+    c = versions_->PickCompaction();
+  }
+
+  Status status;
+  if (c == NULL) {
+    // Nothing to do
+  } else if (!is_manual && c->IsTrivialMove()) {
+    // Move file to next level
+    assert(c->num_input_files(0) == 1);
+    FileMetaData* f = c->input(0, 0);
+    c->edit()->DeleteFile(c->level(), f->number);
+    c->edit()->AddFile(c->level() + 1, f->number, f->file_size,
+                       f->smallest, f->largest);
+    status = versions_->LogAndApply(c->edit(), &mutex_);
+    if (!status.ok()) {
+      RecordBackgroundError(status);
+    }
+    VersionSet::LevelSummaryStorage tmp;
+    Log(options_.info_log, "Moved #%lld to level-%d %lld bytes %s: %s\n",
+        static_cast<unsigned long long>(f->number),
+        c->level() + 1,
+        static_cast<unsigned long long>(f->file_size),
+        status.ToString().c_str(),
+        versions_->LevelSummary(&tmp));
+  } else {
+    CompactionState* compact = new CompactionState(c);
+    status = DoCompactionWork(compact);
+    if (!status.ok()) {
+      RecordBackgroundError(status);
+    }
+    CleanupCompaction(compact);
+    c->ReleaseInputs();
+    DeleteObsoleteFiles();
+  }
+  delete c;
+
+  if (status.ok()) {
+    // Done
+  } else if (shutting_down_.Acquire_Load()) {
+    // Ignore compaction errors found during shutting down
+  } else {
+    Log(options_.info_log,
+        "Compaction error: %s", status.ToString().c_str());
+  }
+
+  if (is_manual) {
+    ManualCompaction* m = manual_compaction_;
+    if (!status.ok()) {
+      m->done = true;
+    }
+    if (!m->done) {
+      // We only compacted part of the requested range.  Update *m
+      // to the range that is left to be compacted.
+      m->tmp_storage = manual_end;
+      m->begin = &m->tmp_storage;
+    }
+    manual_compaction_ = NULL;
+  }
+}
+
+void DBImpl::CleanupCompaction(CompactionState* compact) {
+  mutex_.AssertHeld();
+  if (compact->builder != NULL) {
+    // May happen if we get a shutdown call in the middle of compaction
+    compact->builder->Abandon();
+    delete compact->builder;
+  } else {
+    assert(compact->outfile == NULL);
+  }
+  delete compact->outfile;
+  for (size_t i = 0; i < compact->outputs.size(); i++) {
+    const CompactionState::Output& out = compact->outputs[i];
+    pending_outputs_.erase(out.number);
+  }
+  delete compact;
+}
+
+Status DBImpl::OpenCompactionOutputFile(CompactionState* compact) {
+  assert(compact != NULL);
+  assert(compact->builder == NULL);
+  uint64_t file_number;
+  {
+    mutex_.Lock();
+    file_number = versions_->NewFileNumber();
+    pending_outputs_.insert(file_number);
+    CompactionState::Output out;
+    out.number = file_number;
+    out.smallest.Clear();
+    out.largest.Clear();
+    compact->outputs.push_back(out);
+    mutex_.Unlock();
+  }
+
+  // Make the output file
+  std::string fname = TableFileName(dbname_, file_number);
+  Status s = env_->NewWritableFile(fname, &compact->outfile);
+  if (s.ok()) {
+    compact->builder = new TableBuilder(options_, compact->outfile);
+  }
+  return s;
+}
+
+Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,
+                                          Iterator* input) {
+  assert(compact != NULL);
+  assert(compact->outfile != NULL);
+  assert(compact->builder != NULL);
+
+  const uint64_t output_number = compact->current_output()->number;
+  assert(output_number != 0);
+
+  // Check for iterator errors
+  Status s = input->status();
+  const uint64_t current_entries = compact->builder->NumEntries();
+  if (s.ok()) {
+    s = compact->builder->Finish();
+  } else {
+    compact->builder->Abandon();
+  }
+  const uint64_t current_bytes = compact->builder->FileSize();
+  compact->current_output()->file_size = current_bytes;
+  compact->total_bytes += current_bytes;
+  delete compact->builder;
+  compact->builder = NULL;
+
+  // Finish and check for file errors
+  if (s.ok()) {
+    s = compact->outfile->Sync();
+  }
+  if (s.ok()) {
+    s = compact->outfile->Close();
+  }
+  delete compact->outfile;
+  compact->outfile = NULL;
+
+  if (s.ok() && current_entries > 0) {
+    // Verify that the table is usable
+    Iterator* iter = table_cache_->NewIterator(ReadOptions(),
+                                               output_number,
+                                               current_bytes);
+    s = iter->status();
+    delete iter;
+    if (s.ok()) {
+      Log(options_.info_log,
+          "Generated table #%llu: %lld keys, %lld bytes",
+          (unsigned long long) output_number,
+          (unsigned long long) current_entries,
+          (unsigned long long) current_bytes);
+    }
+  }
+  return s;
+}
+
+
+Status DBImpl::InstallCompactionResults(CompactionState* compact) {
+  mutex_.AssertHeld();
+  Log(options_.info_log,  "Compacted %d@%d + %d@%d files => %lld bytes",
+      compact->compaction->num_input_files(0),
+      compact->compaction->level(),
+      compact->compaction->num_input_files(1),
+      compact->compaction->level() + 1,
+      static_cast<long long>(compact->total_bytes));
+
+  // Add compaction outputs
+  compact->compaction->AddInputDeletions(compact->compaction->edit());
+  const int level = compact->compaction->level();
+  for (size_t i = 0; i < compact->outputs.size(); i++) {
+    const CompactionState::Output& out = compact->outputs[i];
+    compact->compaction->edit()->AddFile(
+        level + 1,
+        out.number, out.file_size, out.smallest, out.largest);
+  }
+  return versions_->LogAndApply(compact->compaction->edit(), &mutex_);
+}
+
+Status DBImpl::DoCompactionWork(CompactionState* compact) {
+  const uint64_t start_micros = env_->NowMicros();
+  int64_t imm_micros = 0;  // Micros spent doing imm_ compactions
+
+  Log(options_.info_log,  "Compacting %d@%d + %d@%d files",
+      compact->compaction->num_input_files(0),
+      compact->compaction->level(),
+      compact->compaction->num_input_files(1),
+      compact->compaction->level() + 1);
+
+  assert(versions_->NumLevelFiles(compact->compaction->level()) > 0);
+  assert(compact->builder == NULL);
+  assert(compact->outfile == NULL);
+  if (snapshots_.empty()) {
+    compact->smallest_snapshot = versions_->LastSequence();
+  } else {
+    compact->smallest_snapshot = snapshots_.oldest()->number_;
+  }
+
+  // Release mutex while we're actually doing the compaction work
+  mutex_.Unlock();
+
+  Iterator* input = versions_->MakeInputIterator(compact->compaction);
+  input->SeekToFirst();
+  Status status;
+  ParsedInternalKey ikey;
+  std::string current_user_key;
+  bool has_current_user_key = false;
+  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;
+  for (; input->Valid() && !shutting_down_.Acquire_Load(); ) {
+    // Prioritize immutable compaction work
+    if (has_imm_.NoBarrier_Load() != NULL) {
+      const uint64_t imm_start = env_->NowMicros();
+      mutex_.Lock();
+      if (imm_ != NULL) {
+        CompactMemTable();
+        bg_cv_.SignalAll();  // Wakeup MakeRoomForWrite() if necessary
+      }
+      mutex_.Unlock();
+      imm_micros += (env_->NowMicros() - imm_start);
+    }
+
+    Slice key = input->key();
+    if (compact->compaction->ShouldStopBefore(key) &&
+        compact->builder != NULL) {
+      status = FinishCompactionOutputFile(compact, input);
+      if (!status.ok()) {
+        break;
+      }
+    }
+
+    // Handle key/value, add to state, etc.
+    bool drop = false;
+    if (!ParseInternalKey(key, &ikey)) {
+      // Do not hide error keys
+      current_user_key.clear();
+      has_current_user_key = false;
+      last_sequence_for_key = kMaxSequenceNumber;
+    } else {
+      if (!has_current_user_key ||
+          user_comparator()->Compare(ikey.user_key,
+                                     Slice(current_user_key)) != 0) {
+        // First occurrence of this user key
+        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());
+        has_current_user_key = true;
+        last_sequence_for_key = kMaxSequenceNumber;
+      }
+
+      if (last_sequence_for_key <= compact->smallest_snapshot) {
+        // Hidden by an newer entry for same user key
+        drop = true;    // (A)
+      } else if (ikey.type == kTypeDeletion &&
+                 ikey.sequence <= compact->smallest_snapshot &&
+                 compact->compaction->IsBaseLevelForKey(ikey.user_key)) {
+        // For this user key:
+        // (1) there is no data in higher levels
+        // (2) data in lower levels will have larger sequence numbers
+        // (3) data in layers that are being compacted here and have
+        //     smaller sequence numbers will be dropped in the next
+        //     few iterations of this loop (by rule (A) above).
+        // Therefore this deletion marker is obsolete and can be dropped.
+        drop = true;
+      }
+
+      last_sequence_for_key = ikey.sequence;
+    }
+#if 0
+    Log(options_.info_log,
+        "  Compact: %s, seq %d, type: %d %d, drop: %d, is_base: %d, "
+        "%d smallest_snapshot: %d",
+        ikey.user_key.ToString().c_str(),
+        (int)ikey.sequence, ikey.type, kTypeValue, drop,
+        compact->compaction->IsBaseLevelForKey(ikey.user_key),
+        (int)last_sequence_for_key, (int)compact->smallest_snapshot);
+#endif
+
+    if (!drop) {
+      // Open output file if necessary
+      if (compact->builder == NULL) {
+        status = OpenCompactionOutputFile(compact);
+        if (!status.ok()) {
+          break;
+        }
+      }
+      if (compact->builder->NumEntries() == 0) {
+        compact->current_output()->smallest.DecodeFrom(key);
+      }
+      compact->current_output()->largest.DecodeFrom(key);
+      compact->builder->Add(key, input->value());
+
+      // Close output file if it is big enough
+      if (compact->builder->FileSize() >=
+          compact->compaction->MaxOutputFileSize()) {
+        status = FinishCompactionOutputFile(compact, input);
+        if (!status.ok()) {
+          break;
+        }
+      }
+    }
+
+    input->Next();
+  }
+
+  if (status.ok() && shutting_down_.Acquire_Load()) {
+    status = Status::IOError("Deleting DB during compaction");
+  }
+  if (status.ok() && compact->builder != NULL) {
+    status = FinishCompactionOutputFile(compact, input);
+  }
+  if (status.ok()) {
+    status = input->status();
+  }
+  delete input;
+  input = NULL;
+
+  CompactionStats stats;
+  stats.micros = env_->NowMicros() - start_micros - imm_micros;
+  for (int which = 0; which < 2; which++) {
+    for (int i = 0; i < compact->compaction->num_input_files(which); i++) {
+      stats.bytes_read += compact->compaction->input(which, i)->file_size;
+    }
+  }
+  for (size_t i = 0; i < compact->outputs.size(); i++) {
+    stats.bytes_written += compact->outputs[i].file_size;
+  }
+
+  mutex_.Lock();
+  stats_[compact->compaction->level() + 1].Add(stats);
+
+  if (status.ok()) {
+    status = InstallCompactionResults(compact);
+  }
+  if (!status.ok()) {
+    RecordBackgroundError(status);
+  }
+  VersionSet::LevelSummaryStorage tmp;
+  Log(options_.info_log,
+      "compacted to: %s", versions_->LevelSummary(&tmp));
+  return status;
+}
+
+namespace {
+struct IterState {
+  port::Mutex* mu;
+  Version* version;
+  MemTable* mem;
+  MemTable* imm;
+};
+
+static void CleanupIteratorState(void* arg1, void* arg2) {
+  IterState* state = reinterpret_cast<IterState*>(arg1);
+  state->mu->Lock();
+  state->mem->Unref();
+  if (state->imm != NULL) state->imm->Unref();
+  state->version->Unref();
+  state->mu->Unlock();
+  delete state;
+}
+}  // namespace
+
+Iterator* DBImpl::NewInternalIterator(const ReadOptions& options,
+                                      SequenceNumber* latest_snapshot,
+                                      uint32_t* seed) {
+  IterState* cleanup = new IterState;
+  mutex_.Lock();
+  *latest_snapshot = versions_->LastSequence();
+
+  // Collect together all needed child iterators
+  std::vector<Iterator*> list;
+  list.push_back(mem_->NewIterator());
+  mem_->Ref();
+  if (imm_ != NULL) {
+    list.push_back(imm_->NewIterator());
+    imm_->Ref();
+  }
+  versions_->current()->AddIterators(options, &list);
+  Iterator* internal_iter =
+      NewMergingIterator(&internal_comparator_, &list[0], list.size());
+  versions_->current()->Ref();
+
+  cleanup->mu = &mutex_;
+  cleanup->mem = mem_;
+  cleanup->imm = imm_;
+  cleanup->version = versions_->current();
+  internal_iter->RegisterCleanup(CleanupIteratorState, cleanup, NULL);
+
+  *seed = ++seed_;
+  mutex_.Unlock();
+  return internal_iter;
+}
+
+Iterator* DBImpl::TEST_NewInternalIterator() {
+  SequenceNumber ignored;
+  uint32_t ignored_seed;
+  return NewInternalIterator(ReadOptions(), &ignored, &ignored_seed);
+}
+
+int64_t DBImpl::TEST_MaxNextLevelOverlappingBytes() {
+  MutexLock l(&mutex_);
+  return versions_->MaxNextLevelOverlappingBytes();
+}
+
+Status DBImpl::Get(const ReadOptions& options,
+                   const Slice& key,
+                   std::string* value) {
+  Status s;
+  MutexLock l(&mutex_);
+  SequenceNumber snapshot;
+  if (options.snapshot != NULL) {
+    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;
+  } else {
+    snapshot = versions_->LastSequence();
+  }
+
+  MemTable* mem = mem_;
+  MemTable* imm = imm_;
+  Version* current = versions_->current();
+  mem->Ref();
+  if (imm != NULL) imm->Ref();
+  current->Ref();
+
+  bool have_stat_update = false;
+  Version::GetStats stats;
+
+  // Unlock while reading from files and memtables
+  {
+    mutex_.Unlock();
+    // First look in the memtable, then in the immutable memtable (if any).
+    LookupKey lkey(key, snapshot);
+    if (mem->Get(lkey, value, &s)) {
+      // Done
+    } else if (imm != NULL && imm->Get(lkey, value, &s)) {
+      // Done
+    } else {
+      s = current->Get(options, lkey, value, &stats);
+      have_stat_update = true;
+    }
+    mutex_.Lock();
+  }
+
+  if (have_stat_update && current->UpdateStats(stats)) {
+    MaybeScheduleCompaction();
+  }
+  mem->Unref();
+  if (imm != NULL) imm->Unref();
+  current->Unref();
+  return s;
+}
+
+Iterator* DBImpl::NewIterator(const ReadOptions& options) {
+  SequenceNumber latest_snapshot;
+  uint32_t seed;
+  Iterator* iter = NewInternalIterator(options, &latest_snapshot, &seed);
+  return NewDBIterator(
+      this, user_comparator(), iter,
+      (options.snapshot != NULL
+       ? reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_
+       : latest_snapshot),
+      seed);
+}
+
+void DBImpl::RecordReadSample(Slice key) {
+  MutexLock l(&mutex_);
+  if (versions_->current()->RecordReadSample(key)) {
+    MaybeScheduleCompaction();
+  }
+}
+
+const Snapshot* DBImpl::GetSnapshot() {
+  MutexLock l(&mutex_);
+  return snapshots_.New(versions_->LastSequence());
+}
+
+void DBImpl::ReleaseSnapshot(const Snapshot* s) {
+  MutexLock l(&mutex_);
+  snapshots_.Delete(reinterpret_cast<const SnapshotImpl*>(s));
+}
+
+// Convenience methods
+Status DBImpl::Put(const WriteOptions& o, const Slice& key, const Slice& val) {
+  return DB::Put(o, key, val);
+}
+
+Status DBImpl::Delete(const WriteOptions& options, const Slice& key) {
+  return DB::Delete(options, key);
+}
+
+Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {
+  Writer w(&mutex_);
+  w.batch = my_batch;
+  w.sync = options.sync;
+  w.done = false;
+
+  MutexLock l(&mutex_);
+  writers_.push_back(&w);
+  while (!w.done && &w != writers_.front()) {
+    w.cv.Wait();
+  }
+  if (w.done) {
+    return w.status;
+  }
+
+  // May temporarily unlock and wait.
+  Status status = MakeRoomForWrite(my_batch == NULL);
+  uint64_t last_sequence = versions_->LastSequence();
+  Writer* last_writer = &w;
+  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions
+    WriteBatch* updates = BuildBatchGroup(&last_writer);
+    WriteBatchInternal::SetSequence(updates, last_sequence + 1);
+    last_sequence += WriteBatchInternal::Count(updates);
+
+    // Add to log and apply to memtable.  We can release the lock
+    // during this phase since &w is currently responsible for logging
+    // and protects against concurrent loggers and concurrent writes
+    // into mem_.
+    {
+      mutex_.Unlock();
+      status = log_->AddRecord(WriteBatchInternal::Contents(updates));
+      bool sync_error = false;
+      if (status.ok() && options.sync) {
+        status = logfile_->Sync();
+        if (!status.ok()) {
+          sync_error = true;
+        }
+      }
+      if (status.ok()) {
+        status = WriteBatchInternal::InsertInto(updates, mem_);
+      }
+      mutex_.Lock();
+      if (sync_error) {
+        // The state of the log file is indeterminate: the log record we
+        // just added may or may not show up when the DB is re-opened.
+        // So we force the DB into a mode where all future writes fail.
+        RecordBackgroundError(status);
+      }
+    }
+    if (updates == tmp_batch_) tmp_batch_->Clear();
+
+    versions_->SetLastSequence(last_sequence);
+  }
+
+  while (true) {
+    Writer* ready = writers_.front();
+    writers_.pop_front();
+    if (ready != &w) {
+      ready->status = status;
+      ready->done = true;
+      ready->cv.Signal();
+    }
+    if (ready == last_writer) break;
+  }
+
+  // Notify new head of write queue
+  if (!writers_.empty()) {
+    writers_.front()->cv.Signal();
+  }
+
+  return status;
+}
+
+// REQUIRES: Writer list must be non-empty
+// REQUIRES: First writer must have a non-NULL batch
+WriteBatch* DBImpl::BuildBatchGroup(Writer** last_writer) {
+  assert(!writers_.empty());
+  Writer* first = writers_.front();
+  WriteBatch* result = first->batch;
+  assert(result != NULL);
+
+  size_t size = WriteBatchInternal::ByteSize(first->batch);
+
+  // Allow the group to grow up to a maximum size, but if the
+  // original write is small, limit the growth so we do not slow
+  // down the small write too much.
+  size_t max_size = 1 << 20;
+  if (size <= (128<<10)) {
+    max_size = size + (128<<10);
+  }
+
+  *last_writer = first;
+  std::deque<Writer*>::iterator iter = writers_.begin();
+  ++iter;  // Advance past "first"
+  for (; iter != writers_.end(); ++iter) {
+    Writer* w = *iter;
+    if (w->sync && !first->sync) {
+      // Do not include a sync write into a batch handled by a non-sync write.
+      break;
+    }
+
+    if (w->batch != NULL) {
+      size += WriteBatchInternal::ByteSize(w->batch);
+      if (size > max_size) {
+        // Do not make batch too big
+        break;
+      }
+
+      // Append to *reuslt
+      if (result == first->batch) {
+        // Switch to temporary batch instead of disturbing caller's batch
+        result = tmp_batch_;
+        assert(WriteBatchInternal::Count(result) == 0);
+        WriteBatchInternal::Append(result, first->batch);
+      }
+      WriteBatchInternal::Append(result, w->batch);
+    }
+    *last_writer = w;
+  }
+  return result;
+}
+
+// REQUIRES: mutex_ is held
+// REQUIRES: this thread is currently at the front of the writer queue
+Status DBImpl::MakeRoomForWrite(bool force) {
+  mutex_.AssertHeld();
+  assert(!writers_.empty());
+  bool allow_delay = !force;
+  Status s;
+  while (true) {
+    if (!bg_error_.ok()) {
+      // Yield previous error
+      s = bg_error_;
+      break;
+    } else if (
+        allow_delay &&
+        versions_->NumLevelFiles(0) >= config::kL0_SlowdownWritesTrigger) {
+      // We are getting close to hitting a hard limit on the number of
+      // L0 files.  Rather than delaying a single write by several
+      // seconds when we hit the hard limit, start delaying each
+      // individual write by 1ms to reduce latency variance.  Also,
+      // this delay hands over some CPU to the compaction thread in
+      // case it is sharing the same core as the writer.
+      mutex_.Unlock();
+      env_->SleepForMicroseconds(1000);
+      allow_delay = false;  // Do not delay a single write more than once
+      mutex_.Lock();
+    } else if (!force &&
+               (mem_->ApproximateMemoryUsage() <= options_.write_buffer_size)) {
+      // There is room in current memtable
+      break;
+    } else if (imm_ != NULL) {
+      // We have filled up the current memtable, but the previous
+      // one is still being compacted, so we wait.
+      Log(options_.info_log, "Current memtable full; waiting...\n");
+      bg_cv_.Wait();
+    } else if (versions_->NumLevelFiles(0) >= config::kL0_StopWritesTrigger) {
+      // There are too many level-0 files.
+      Log(options_.info_log, "Too many L0 files; waiting...\n");
+      bg_cv_.Wait();
+    } else {
+      // Attempt to switch to a new memtable and trigger compaction of old
+      assert(versions_->PrevLogNumber() == 0);
+      uint64_t new_log_number = versions_->NewFileNumber();
+      WritableFile* lfile = NULL;
+      s = env_->NewWritableFile(LogFileName(dbname_, new_log_number), &lfile);
+      if (!s.ok()) {
+        // Avoid chewing through file number space in a tight loop.
+        versions_->ReuseFileNumber(new_log_number);
+        break;
+      }
+      delete log_;
+      delete logfile_;
+      logfile_ = lfile;
+      logfile_number_ = new_log_number;
+      log_ = new log::Writer(lfile);
+      imm_ = mem_;
+      has_imm_.Release_Store(imm_);
+      mem_ = new MemTable(internal_comparator_);
+      mem_->Ref();
+      force = false;   // Do not force another compaction if have room
+      MaybeScheduleCompaction();
+    }
+  }
+  return s;
+}
+
+bool DBImpl::GetProperty(const Slice& property, std::string* value) {
+  value->clear();
+
+  MutexLock l(&mutex_);
+  Slice in = property;
+  Slice prefix("leveldb.");
+  if (!in.starts_with(prefix)) return false;
+  in.remove_prefix(prefix.size());
+
+  if (in.starts_with("num-files-at-level")) {
+    in.remove_prefix(strlen("num-files-at-level"));
+    uint64_t level;
+    bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();
+    if (!ok || level >= config::kNumLevels) {
+      return false;
+    } else {
+      char buf[100];
+      snprintf(buf, sizeof(buf), "%d",
+               versions_->NumLevelFiles(static_cast<int>(level)));
+      *value = buf;
+      return true;
+    }
+  } else if (in == "stats") {
+    char buf[200];
+    snprintf(buf, sizeof(buf),
+             "                               Compactions\n"
+             "Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\n"
+             "--------------------------------------------------\n"
+             );
+    value->append(buf);
+    for (int level = 0; level < config::kNumLevels; level++) {
+      int files = versions_->NumLevelFiles(level);
+      if (stats_[level].micros > 0 || files > 0) {
+        snprintf(
+            buf, sizeof(buf),
+            "%3d %8d %8.0f %9.0f %8.0f %9.0f\n",
+            level,
+            files,
+            versions_->NumLevelBytes(level) / 1048576.0,
+            stats_[level].micros / 1e6,
+            stats_[level].bytes_read / 1048576.0,
+            stats_[level].bytes_written / 1048576.0);
+        value->append(buf);
+      }
+    }
+    return true;
+  } else if (in == "sstables") {
+    *value = versions_->current()->DebugString();
+    return true;
+  }
+
+  return false;
+}
+
+void DBImpl::GetApproximateSizes(
+    const Range* range, int n,
+    uint64_t* sizes) {
+  // TODO(opt): better implementation
+  Version* v;
+  {
+    MutexLock l(&mutex_);
+    versions_->current()->Ref();
+    v = versions_->current();
+  }
+
+  for (int i = 0; i < n; i++) {
+    // Convert user_key into a corresponding internal key.
+    InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);
+    InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);
+    uint64_t start = versions_->ApproximateOffsetOf(v, k1);
+    uint64_t limit = versions_->ApproximateOffsetOf(v, k2);
+    sizes[i] = (limit >= start ? limit - start : 0);
+  }
+
+  {
+    MutexLock l(&mutex_);
+    v->Unref();
+  }
+}
+
+// Default implementations of convenience methods that subclasses of DB
+// can call if they wish
+Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {
+  WriteBatch batch;
+  batch.Put(key, value);
+  return Write(opt, &batch);
+}
+
+Status DB::Delete(const WriteOptions& opt, const Slice& key) {
+  WriteBatch batch;
+  batch.Delete(key);
+  return Write(opt, &batch);
+}
+
+DB::~DB() { }
+
+Status DB::Open(const Options& options, const std::string& dbname,
+                DB** dbptr) {
+  *dbptr = NULL;
+
+  DBImpl* impl = new DBImpl(options, dbname);
+  impl->mutex_.Lock();
+  VersionEdit edit;
+  Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists
+  if (s.ok()) {
+    uint64_t new_log_number = impl->versions_->NewFileNumber();
+    WritableFile* lfile;
+    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),
+                                     &lfile);
+    if (s.ok()) {
+      edit.SetLogNumber(new_log_number);
+      impl->logfile_ = lfile;
+      impl->logfile_number_ = new_log_number;
+      impl->log_ = new log::Writer(lfile);
+      s = impl->versions_->LogAndApply(&edit, &impl->mutex_);
+    }
+    if (s.ok()) {
+      impl->DeleteObsoleteFiles();
+      impl->MaybeScheduleCompaction();
+    }
+  }
+  impl->mutex_.Unlock();
+  if (s.ok()) {
+    *dbptr = impl;
+  } else {
+    delete impl;
+  }
+  return s;
+}
+
+Snapshot::~Snapshot() {
+}
+
+Status DestroyDB(const std::string& dbname, const Options& options) {
+  Env* env = options.env;
+  std::vector<std::string> filenames;
+  // Ignore error in case directory does not exist
+  env->GetChildren(dbname, &filenames);
+  if (filenames.empty()) {
+    return Status::OK();
+  }
+
+  FileLock* lock;
+  const std::string lockname = LockFileName(dbname);
+  Status result = env->LockFile(lockname, &lock);
+  if (result.ok()) {
+    uint64_t number;
+    FileType type;
+    for (size_t i = 0; i < filenames.size(); i++) {
+      if (ParseFileName(filenames[i], &number, &type) &&
+          type != kDBLockFile) {  // Lock file will be deleted at end
+        Status del = env->DeleteFile(dbname + "/" + filenames[i]);
+        if (result.ok() && !del.ok()) {
+          result = del;
+        }
+      }
+    }
+    env->UnlockFile(lock);  // Ignore error since state is already gone
+    env->DeleteFile(lockname);
+    env->DeleteDir(dbname);  // Ignore error in case dir contains other files
+  }
+  return result;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/db_impl.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/db_impl.h
new file mode 100644
index 0000000..cfc9981
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/db_impl.h
@@ -0,0 +1,211 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_DB_DB_IMPL_H_
+#define STORAGE_LEVELDB_DB_DB_IMPL_H_
+
+#include <deque>
+#include <set>
+#include "db/dbformat.h"
+#include "db/log_writer.h"
+#include "db/snapshot.h"
+#include "leveldb/db.h"
+#include "leveldb/env.h"
+#include "port/port.h"
+#include "port/thread_annotations.h"
+
+namespace leveldb {
+
+class MemTable;
+class TableCache;
+class Version;
+class VersionEdit;
+class VersionSet;
+
+class DBImpl : public DB {
+ public:
+  DBImpl(const Options& options, const std::string& dbname);
+  virtual ~DBImpl();
+
+  // Implementations of the DB interface
+  virtual Status Put(const WriteOptions&, const Slice& key, const Slice& value);
+  virtual Status Delete(const WriteOptions&, const Slice& key);
+  virtual Status Write(const WriteOptions& options, WriteBatch* updates);
+  virtual Status Get(const ReadOptions& options,
+                     const Slice& key,
+                     std::string* value);
+  virtual Iterator* NewIterator(const ReadOptions&);
+  virtual const Snapshot* GetSnapshot();
+  virtual void ReleaseSnapshot(const Snapshot* snapshot);
+  virtual bool GetProperty(const Slice& property, std::string* value);
+  virtual void GetApproximateSizes(const Range* range, int n, uint64_t* sizes);
+  virtual void CompactRange(const Slice* begin, const Slice* end);
+
+  // Extra methods (for testing) that are not in the public DB interface
+
+  // Compact any files in the named level that overlap [*begin,*end]
+  void TEST_CompactRange(int level, const Slice* begin, const Slice* end);
+
+  // Force current memtable contents to be compacted.
+  Status TEST_CompactMemTable();
+
+  // Return an internal iterator over the current state of the database.
+  // The keys of this iterator are internal keys (see format.h).
+  // The returned iterator should be deleted when no longer needed.
+  Iterator* TEST_NewInternalIterator();
+
+  // Return the maximum overlapping data (in bytes) at next level for any
+  // file at a level >= 1.
+  int64_t TEST_MaxNextLevelOverlappingBytes();
+
+  // Record a sample of bytes read at the specified internal key.
+  // Samples are taken approximately once every config::kReadBytesPeriod
+  // bytes.
+  void RecordReadSample(Slice key);
+
+ private:
+  friend class DB;
+  struct CompactionState;
+  struct Writer;
+
+  Iterator* NewInternalIterator(const ReadOptions&,
+                                SequenceNumber* latest_snapshot,
+                                uint32_t* seed);
+
+  Status NewDB();
+
+  // Recover the descriptor from persistent storage.  May do a significant
+  // amount of work to recover recently logged updates.  Any changes to
+  // be made to the descriptor are added to *edit.
+  Status Recover(VersionEdit* edit) EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+
+  void MaybeIgnoreError(Status* s) const;
+
+  // Delete any unneeded files and stale in-memory entries.
+  void DeleteObsoleteFiles();
+
+  // Compact the in-memory write buffer to disk.  Switches to a new
+  // log-file/memtable and writes a new descriptor iff successful.
+  // Errors are recorded in bg_error_.
+  void CompactMemTable() EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+
+  Status RecoverLogFile(uint64_t log_number,
+                        VersionEdit* edit,
+                        SequenceNumber* max_sequence)
+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+
+  Status WriteLevel0Table(MemTable* mem, VersionEdit* edit, Version* base)
+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+
+  Status MakeRoomForWrite(bool force /* compact even if there is room? */)
+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  WriteBatch* BuildBatchGroup(Writer** last_writer);
+
+  void RecordBackgroundError(const Status& s);
+
+  void MaybeScheduleCompaction() EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  static void BGWork(void* db);
+  void BackgroundCall();
+  void  BackgroundCompaction() EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  void CleanupCompaction(CompactionState* compact)
+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+  Status DoCompactionWork(CompactionState* compact)
+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+
+  Status OpenCompactionOutputFile(CompactionState* compact);
+  Status FinishCompactionOutputFile(CompactionState* compact, Iterator* input);
+  Status InstallCompactionResults(CompactionState* compact)
+      EXCLUSIVE_LOCKS_REQUIRED(mutex_);
+
+  // Constant after construction
+  Env* const env_;
+  const InternalKeyComparator internal_comparator_;
+  const InternalFilterPolicy internal_filter_policy_;
+  const Options options_;  // options_.comparator == &internal_comparator_
+  bool owns_info_log_;
+  bool owns_cache_;
+  const std::string dbname_;
+
+  // table_cache_ provides its own synchronization
+  TableCache* table_cache_;
+
+  // Lock over the persistent DB state.  Non-NULL iff successfully acquired.
+  FileLock* db_lock_;
+
+  // State below is protected by mutex_
+  port::Mutex mutex_;
+  port::AtomicPointer shutting_down_;
+  port::CondVar bg_cv_;          // Signalled when background work finishes
+  MemTable* mem_;
+  MemTable* imm_;                // Memtable being compacted
+  port::AtomicPointer has_imm_;  // So bg thread can detect non-NULL imm_
+  WritableFile* logfile_;
+  uint64_t logfile_number_;
+  log::Writer* log_;
+  uint32_t seed_;                // For sampling.
+
+  // Queue of writers.
+  std::deque<Writer*> writers_;
+  WriteBatch* tmp_batch_;
+
+  SnapshotList snapshots_;
+
+  // Set of table files to protect from deletion because they are
+  // part of ongoing compactions.
+  std::set<uint64_t> pending_outputs_;
+
+  // Has a background compaction been scheduled or is running?
+  bool bg_compaction_scheduled_;
+
+  // Information for a manual compaction
+  struct ManualCompaction {
+    int level;
+    bool done;
+    const InternalKey* begin;   // NULL means beginning of key range
+    const InternalKey* end;     // NULL means end of key range
+    InternalKey tmp_storage;    // Used to keep track of compaction progress
+  };
+  ManualCompaction* manual_compaction_;
+
+  VersionSet* versions_;
+
+  // Have we encountered a background error in paranoid mode?
+  Status bg_error_;
+
+  // Per level compaction stats.  stats_[level] stores the stats for
+  // compactions that produced data for the specified "level".
+  struct CompactionStats {
+    int64_t micros;
+    int64_t bytes_read;
+    int64_t bytes_written;
+
+    CompactionStats() : micros(0), bytes_read(0), bytes_written(0) { }
+
+    void Add(const CompactionStats& c) {
+      this->micros += c.micros;
+      this->bytes_read += c.bytes_read;
+      this->bytes_written += c.bytes_written;
+    }
+  };
+  CompactionStats stats_[config::kNumLevels];
+
+  // No copying allowed
+  DBImpl(const DBImpl&);
+  void operator=(const DBImpl&);
+
+  const Comparator* user_comparator() const {
+    return internal_comparator_.user_comparator();
+  }
+};
+
+// Sanitize db options.  The caller should delete result.info_log if
+// it is not equal to src.info_log.
+extern Options SanitizeOptions(const std::string& db,
+                               const InternalKeyComparator* icmp,
+                               const InternalFilterPolicy* ipolicy,
+                               const Options& src);
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_DB_IMPL_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/db_iter.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/db_iter.cc
new file mode 100644
index 0000000..3b2035e
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/db_iter.cc
@@ -0,0 +1,317 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "db/db_iter.h"
+
+#include "db/filename.h"
+#include "db/db_impl.h"
+#include "db/dbformat.h"
+#include "leveldb/env.h"
+#include "leveldb/iterator.h"
+#include "port/port.h"
+#include "util/logging.h"
+#include "util/mutexlock.h"
+#include "util/random.h"
+
+namespace leveldb {
+
+#if 0
+static void DumpInternalIter(Iterator* iter) {
+  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
+    ParsedInternalKey k;
+    if (!ParseInternalKey(iter->key(), &k)) {
+      fprintf(stderr, "Corrupt '%s'\n", EscapeString(iter->key()).c_str());
+    } else {
+      fprintf(stderr, "@ '%s'\n", k.DebugString().c_str());
+    }
+  }
+}
+#endif
+
+namespace {
+
+// Memtables and sstables that make the DB representation contain
+// (userkey,seq,type) => uservalue entries.  DBIter
+// combines multiple entries for the same userkey found in the DB
+// representation into a single entry while accounting for sequence
+// numbers, deletion markers, overwrites, etc.
+class DBIter: public Iterator {
+ public:
+  // Which direction is the iterator currently moving?
+  // (1) When moving forward, the internal iterator is positioned at
+  //     the exact entry that yields this->key(), this->value()
+  // (2) When moving backwards, the internal iterator is positioned
+  //     just before all entries whose user key == this->key().
+  enum Direction {
+    kForward,
+    kReverse
+  };
+
+  DBIter(DBImpl* db, const Comparator* cmp, Iterator* iter, SequenceNumber s,
+         uint32_t seed)
+      : db_(db),
+        user_comparator_(cmp),
+        iter_(iter),
+        sequence_(s),
+        direction_(kForward),
+        valid_(false),
+        rnd_(seed),
+        bytes_counter_(RandomPeriod()) {
+  }
+  virtual ~DBIter() {
+    delete iter_;
+  }
+  virtual bool Valid() const { return valid_; }
+  virtual Slice key() const {
+    assert(valid_);
+    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;
+  }
+  virtual Slice value() const {
+    assert(valid_);
+    return (direction_ == kForward) ? iter_->value() : saved_value_;
+  }
+  virtual Status status() const {
+    if (status_.ok()) {
+      return iter_->status();
+    } else {
+      return status_;
+    }
+  }
+
+  virtual void Next();
+  virtual void Prev();
+  virtual void Seek(const Slice& target);
+  virtual void SeekToFirst();
+  virtual void SeekToLast();
+
+ private:
+  void FindNextUserEntry(bool skipping, std::string* skip);
+  void FindPrevUserEntry();
+  bool ParseKey(ParsedInternalKey* key);
+
+  inline void SaveKey(const Slice& k, std::string* dst) {
+    dst->assign(k.data(), k.size());
+  }
+
+  inline void ClearSavedValue() {
+    if (saved_value_.capacity() > 1048576) {
+      std::string empty;
+      swap(empty, saved_value_);
+    } else {
+      saved_value_.clear();
+    }
+  }
+
+  // Pick next gap with average value of config::kReadBytesPeriod.
+  ssize_t RandomPeriod() {
+    return rnd_.Uniform(2*config::kReadBytesPeriod);
+  }
+
+  DBImpl* db_;
+  const Comparator* const user_comparator_;
+  Iterator* const iter_;
+  SequenceNumber const sequence_;
+
+  Status status_;
+  std::string saved_key_;     // == current key when direction_==kReverse
+  std::string saved_value_;   // == current raw value when direction_==kReverse
+  Direction direction_;
+  bool valid_;
+
+  Random rnd_;
+  ssize_t bytes_counter_;
+
+  // No copying allowed
+  DBIter(const DBIter&);
+  void operator=(const DBIter&);
+};
+
+inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {
+  Slice k = iter_->key();
+  ssize_t n = k.size() + iter_->value().size();
+  bytes_counter_ -= n;
+  while (bytes_counter_ < 0) {
+    bytes_counter_ += RandomPeriod();
+    db_->RecordReadSample(k);
+  }
+  if (!ParseInternalKey(k, ikey)) {
+    status_ = Status::Corruption("corrupted internal key in DBIter");
+    return false;
+  } else {
+    return true;
+  }
+}
+
+void DBIter::Next() {
+  assert(valid_);
+
+  if (direction_ == kReverse) {  // Switch directions?
+    direction_ = kForward;
+    // iter_ is pointing just before the entries for this->key(),
+    // so advance into the range of entries for this->key() and then
+    // use the normal skipping code below.
+    if (!iter_->Valid()) {
+      iter_->SeekToFirst();
+    } else {
+      iter_->Next();
+    }
+    if (!iter_->Valid()) {
+      valid_ = false;
+      saved_key_.clear();
+      return;
+    }
+    // saved_key_ already contains the key to skip past.
+  } else {
+    // Store in saved_key_ the current key so we skip it below.
+    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
+  }
+
+  FindNextUserEntry(true, &saved_key_);
+}
+
+void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {
+  // Loop until we hit an acceptable entry to yield
+  assert(iter_->Valid());
+  assert(direction_ == kForward);
+  do {
+    ParsedInternalKey ikey;
+    if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
+      switch (ikey.type) {
+        case kTypeDeletion:
+          // Arrange to skip all upcoming entries for this key since
+          // they are hidden by this deletion.
+          SaveKey(ikey.user_key, skip);
+          skipping = true;
+          break;
+        case kTypeValue:
+          if (skipping &&
+              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {
+            // Entry hidden
+          } else {
+            valid_ = true;
+            saved_key_.clear();
+            return;
+          }
+          break;
+      }
+    }
+    iter_->Next();
+  } while (iter_->Valid());
+  saved_key_.clear();
+  valid_ = false;
+}
+
+void DBIter::Prev() {
+  assert(valid_);
+
+  if (direction_ == kForward) {  // Switch directions?
+    // iter_ is pointing at the current entry.  Scan backwards until
+    // the key changes so we can use the normal reverse scanning code.
+    assert(iter_->Valid());  // Otherwise valid_ would have been false
+    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
+    while (true) {
+      iter_->Prev();
+      if (!iter_->Valid()) {
+        valid_ = false;
+        saved_key_.clear();
+        ClearSavedValue();
+        return;
+      }
+      if (user_comparator_->Compare(ExtractUserKey(iter_->key()),
+                                    saved_key_) < 0) {
+        break;
+      }
+    }
+    direction_ = kReverse;
+  }
+
+  FindPrevUserEntry();
+}
+
+void DBIter::FindPrevUserEntry() {
+  assert(direction_ == kReverse);
+
+  ValueType value_type = kTypeDeletion;
+  if (iter_->Valid()) {
+    do {
+      ParsedInternalKey ikey;
+      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
+        if ((value_type != kTypeDeletion) &&
+            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {
+          // We encountered a non-deleted value in entries for previous keys,
+          break;
+        }
+        value_type = ikey.type;
+        if (value_type == kTypeDeletion) {
+          saved_key_.clear();
+          ClearSavedValue();
+        } else {
+          Slice raw_value = iter_->value();
+          if (saved_value_.capacity() > raw_value.size() + 1048576) {
+            std::string empty;
+            swap(empty, saved_value_);
+          }
+          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
+          saved_value_.assign(raw_value.data(), raw_value.size());
+        }
+      }
+      iter_->Prev();
+    } while (iter_->Valid());
+  }
+
+  if (value_type == kTypeDeletion) {
+    // End
+    valid_ = false;
+    saved_key_.clear();
+    ClearSavedValue();
+    direction_ = kForward;
+  } else {
+    valid_ = true;
+  }
+}
+
+void DBIter::Seek(const Slice& target) {
+  direction_ = kForward;
+  ClearSavedValue();
+  saved_key_.clear();
+  AppendInternalKey(
+      &saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));
+  iter_->Seek(saved_key_);
+  if (iter_->Valid()) {
+    FindNextUserEntry(false, &saved_key_ /* temporary storage */);
+  } else {
+    valid_ = false;
+  }
+}
+
+void DBIter::SeekToFirst() {
+  direction_ = kForward;
+  ClearSavedValue();
+  iter_->SeekToFirst();
+  if (iter_->Valid()) {
+    FindNextUserEntry(false, &saved_key_ /* temporary storage */);
+  } else {
+    valid_ = false;
+  }
+}
+
+void DBIter::SeekToLast() {
+  direction_ = kReverse;
+  ClearSavedValue();
+  iter_->SeekToLast();
+  FindPrevUserEntry();
+}
+
+}  // anonymous namespace
+
+Iterator* NewDBIterator(
+    DBImpl* db,
+    const Comparator* user_key_comparator,
+    Iterator* internal_iter,
+    SequenceNumber sequence,
+    uint32_t seed) {
+  return new DBIter(db, user_key_comparator, internal_iter, sequence, seed);
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/db_iter.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/db_iter.h
new file mode 100644
index 0000000..04927e9
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/db_iter.h
@@ -0,0 +1,28 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_DB_DB_ITER_H_
+#define STORAGE_LEVELDB_DB_DB_ITER_H_
+
+#include <stdint.h>
+#include "leveldb/db.h"
+#include "db/dbformat.h"
+
+namespace leveldb {
+
+class DBImpl;
+
+// Return a new iterator that converts internal keys (yielded by
+// "*internal_iter") that were live at the specified "sequence" number
+// into appropriate user keys.
+extern Iterator* NewDBIterator(
+    DBImpl* db,
+    const Comparator* user_key_comparator,
+    Iterator* internal_iter,
+    SequenceNumber sequence,
+    uint32_t seed);
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_DB_ITER_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/dbformat.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/dbformat.cc
new file mode 100644
index 0000000..20a7ca4
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/dbformat.cc
@@ -0,0 +1,140 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include <stdio.h>
+#include "db/dbformat.h"
+#include "port/port.h"
+#include "util/coding.h"
+
+namespace leveldb {
+
+static uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {
+  assert(seq <= kMaxSequenceNumber);
+  assert(t <= kValueTypeForSeek);
+  return (seq << 8) | t;
+}
+
+void AppendInternalKey(std::string* result, const ParsedInternalKey& key) {
+  result->append(key.user_key.data(), key.user_key.size());
+  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
+}
+
+std::string ParsedInternalKey::DebugString() const {
+  char buf[50];
+  snprintf(buf, sizeof(buf), "' @ %llu : %d",
+           (unsigned long long) sequence,
+           int(type));
+  std::string result = "'";
+  result += EscapeString(user_key.ToString());
+  result += buf;
+  return result;
+}
+
+std::string InternalKey::DebugString() const {
+  std::string result;
+  ParsedInternalKey parsed;
+  if (ParseInternalKey(rep_, &parsed)) {
+    result = parsed.DebugString();
+  } else {
+    result = "(bad)";
+    result.append(EscapeString(rep_));
+  }
+  return result;
+}
+
+const char* InternalKeyComparator::Name() const {
+  return "leveldb.InternalKeyComparator";
+}
+
+int InternalKeyComparator::Compare(const Slice& akey, const Slice& bkey) const {
+  // Order by:
+  //    increasing user key (according to user-supplied comparator)
+  //    decreasing sequence number
+  //    decreasing type (though sequence# should be enough to disambiguate)
+  int r = user_comparator_->Compare(ExtractUserKey(akey), ExtractUserKey(bkey));
+  if (r == 0) {
+    const uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8);
+    const uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8);
+    if (anum > bnum) {
+      r = -1;
+    } else if (anum < bnum) {
+      r = +1;
+    }
+  }
+  return r;
+}
+
+void InternalKeyComparator::FindShortestSeparator(
+      std::string* start,
+      const Slice& limit) const {
+  // Attempt to shorten the user portion of the key
+  Slice user_start = ExtractUserKey(*start);
+  Slice user_limit = ExtractUserKey(limit);
+  std::string tmp(user_start.data(), user_start.size());
+  user_comparator_->FindShortestSeparator(&tmp, user_limit);
+  if (tmp.size() < user_start.size() &&
+      user_comparator_->Compare(user_start, tmp) < 0) {
+    // User key has become shorter physically, but larger logically.
+    // Tack on the earliest possible number to the shortened user key.
+    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
+    assert(this->Compare(*start, tmp) < 0);
+    assert(this->Compare(tmp, limit) < 0);
+    start->swap(tmp);
+  }
+}
+
+void InternalKeyComparator::FindShortSuccessor(std::string* key) const {
+  Slice user_key = ExtractUserKey(*key);
+  std::string tmp(user_key.data(), user_key.size());
+  user_comparator_->FindShortSuccessor(&tmp);
+  if (tmp.size() < user_key.size() &&
+      user_comparator_->Compare(user_key, tmp) < 0) {
+    // User key has become shorter physically, but larger logically.
+    // Tack on the earliest possible number to the shortened user key.
+    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
+    assert(this->Compare(*key, tmp) < 0);
+    key->swap(tmp);
+  }
+}
+
+const char* InternalFilterPolicy::Name() const {
+  return user_policy_->Name();
+}
+
+void InternalFilterPolicy::CreateFilter(const Slice* keys, int n,
+                                        std::string* dst) const {
+  // We rely on the fact that the code in table.cc does not mind us
+  // adjusting keys[].
+  Slice* mkey = const_cast<Slice*>(keys);
+  for (int i = 0; i < n; i++) {
+    mkey[i] = ExtractUserKey(keys[i]);
+    // TODO(sanjay): Suppress dups?
+  }
+  user_policy_->CreateFilter(keys, n, dst);
+}
+
+bool InternalFilterPolicy::KeyMayMatch(const Slice& key, const Slice& f) const {
+  return user_policy_->KeyMayMatch(ExtractUserKey(key), f);
+}
+
+LookupKey::LookupKey(const Slice& user_key, SequenceNumber s) {
+  size_t usize = user_key.size();
+  size_t needed = usize + 13;  // A conservative estimate
+  char* dst;
+  if (needed <= sizeof(space_)) {
+    dst = space_;
+  } else {
+    dst = new char[needed];
+  }
+  start_ = dst;
+  dst = EncodeVarint32(dst, usize + 8);
+  kstart_ = dst;
+  memcpy(dst, user_key.data(), usize);
+  dst += usize;
+  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));
+  dst += 8;
+  end_ = dst;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/dbformat.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/dbformat.h
new file mode 100644
index 0000000..5d8a032
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/dbformat.h
@@ -0,0 +1,230 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_DB_FORMAT_H_
+#define STORAGE_LEVELDB_DB_FORMAT_H_
+
+#include <stdio.h>
+#include "leveldb/comparator.h"
+#include "leveldb/db.h"
+#include "leveldb/filter_policy.h"
+#include "leveldb/slice.h"
+#include "leveldb/table_builder.h"
+#include "util/coding.h"
+#include "util/logging.h"
+
+namespace leveldb {
+
+// Grouping of constants.  We may want to make some of these
+// parameters set via options.
+namespace config {
+static const int kNumLevels = 7;
+
+// Level-0 compaction is started when we hit this many files.
+static const int kL0_CompactionTrigger = 4;
+
+// Soft limit on number of level-0 files.  We slow down writes at this point.
+static const int kL0_SlowdownWritesTrigger = 8;
+
+// Maximum number of level-0 files.  We stop writes at this point.
+static const int kL0_StopWritesTrigger = 12;
+
+// Maximum level to which a new compacted memtable is pushed if it
+// does not create overlap.  We try to push to level 2 to avoid the
+// relatively expensive level 0=>1 compactions and to avoid some
+// expensive manifest file operations.  We do not push all the way to
+// the largest level since that can generate a lot of wasted disk
+// space if the same key space is being repeatedly overwritten.
+static const int kMaxMemCompactLevel = 2;
+
+// Approximate gap in bytes between samples of data read during iteration.
+static const int kReadBytesPeriod = 1048576;
+
+}  // namespace config
+
+class InternalKey;
+
+// Value types encoded as the last component of internal keys.
+// DO NOT CHANGE THESE ENUM VALUES: they are embedded in the on-disk
+// data structures.
+enum ValueType {
+  kTypeDeletion = 0x0,
+  kTypeValue = 0x1
+};
+// kValueTypeForSeek defines the ValueType that should be passed when
+// constructing a ParsedInternalKey object for seeking to a particular
+// sequence number (since we sort sequence numbers in decreasing order
+// and the value type is embedded as the low 8 bits in the sequence
+// number in internal keys, we need to use the highest-numbered
+// ValueType, not the lowest).
+static const ValueType kValueTypeForSeek = kTypeValue;
+
+typedef uint64_t SequenceNumber;
+
+// We leave eight bits empty at the bottom so a type and sequence#
+// can be packed together into 64-bits.
+static const SequenceNumber kMaxSequenceNumber =
+    ((0x1ull << 56) - 1);
+
+struct ParsedInternalKey {
+  Slice user_key;
+  SequenceNumber sequence;
+  ValueType type;
+
+  ParsedInternalKey() { }  // Intentionally left uninitialized (for speed)
+  ParsedInternalKey(const Slice& u, const SequenceNumber& seq, ValueType t)
+      : user_key(u), sequence(seq), type(t) { }
+  std::string DebugString() const;
+};
+
+// Return the length of the encoding of "key".
+inline size_t InternalKeyEncodingLength(const ParsedInternalKey& key) {
+  return key.user_key.size() + 8;
+}
+
+// Append the serialization of "key" to *result.
+extern void AppendInternalKey(std::string* result,
+                              const ParsedInternalKey& key);
+
+// Attempt to parse an internal key from "internal_key".  On success,
+// stores the parsed data in "*result", and returns true.
+//
+// On error, returns false, leaves "*result" in an undefined state.
+extern bool ParseInternalKey(const Slice& internal_key,
+                             ParsedInternalKey* result);
+
+// Returns the user key portion of an internal key.
+inline Slice ExtractUserKey(const Slice& internal_key) {
+  assert(internal_key.size() >= 8);
+  return Slice(internal_key.data(), internal_key.size() - 8);
+}
+
+inline ValueType ExtractValueType(const Slice& internal_key) {
+  assert(internal_key.size() >= 8);
+  const size_t n = internal_key.size();
+  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
+  unsigned char c = num & 0xff;
+  return static_cast<ValueType>(c);
+}
+
+// A comparator for internal keys that uses a specified comparator for
+// the user key portion and breaks ties by decreasing sequence number.
+class InternalKeyComparator : public Comparator {
+ private:
+  const Comparator* user_comparator_;
+ public:
+  explicit InternalKeyComparator(const Comparator* c) : user_comparator_(c) { }
+  virtual const char* Name() const;
+  virtual int Compare(const Slice& a, const Slice& b) const;
+  virtual void FindShortestSeparator(
+      std::string* start,
+      const Slice& limit) const;
+  virtual void FindShortSuccessor(std::string* key) const;
+
+  const Comparator* user_comparator() const { return user_comparator_; }
+
+  int Compare(const InternalKey& a, const InternalKey& b) const;
+};
+
+// Filter policy wrapper that converts from internal keys to user keys
+class InternalFilterPolicy : public FilterPolicy {
+ private:
+  const FilterPolicy* const user_policy_;
+ public:
+  explicit InternalFilterPolicy(const FilterPolicy* p) : user_policy_(p) { }
+  virtual const char* Name() const;
+  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const;
+  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const;
+};
+
+// Modules in this directory should keep internal keys wrapped inside
+// the following class instead of plain strings so that we do not
+// incorrectly use string comparisons instead of an InternalKeyComparator.
+class InternalKey {
+ private:
+  std::string rep_;
+ public:
+  InternalKey() { }   // Leave rep_ as empty to indicate it is invalid
+  InternalKey(const Slice& user_key, SequenceNumber s, ValueType t) {
+    AppendInternalKey(&rep_, ParsedInternalKey(user_key, s, t));
+  }
+
+  void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }
+  Slice Encode() const {
+    assert(!rep_.empty());
+    return rep_;
+  }
+
+  Slice user_key() const { return ExtractUserKey(rep_); }
+
+  void SetFrom(const ParsedInternalKey& p) {
+    rep_.clear();
+    AppendInternalKey(&rep_, p);
+  }
+
+  void Clear() { rep_.clear(); }
+
+  std::string DebugString() const;
+};
+
+inline int InternalKeyComparator::Compare(
+    const InternalKey& a, const InternalKey& b) const {
+  return Compare(a.Encode(), b.Encode());
+}
+
+inline bool ParseInternalKey(const Slice& internal_key,
+                             ParsedInternalKey* result) {
+  const size_t n = internal_key.size();
+  if (n < 8) return false;
+  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
+  unsigned char c = num & 0xff;
+  result->sequence = num >> 8;
+  result->type = static_cast<ValueType>(c);
+  result->user_key = Slice(internal_key.data(), n - 8);
+  return (c <= static_cast<unsigned char>(kTypeValue));
+}
+
+// A helper class useful for DBImpl::Get()
+class LookupKey {
+ public:
+  // Initialize *this for looking up user_key at a snapshot with
+  // the specified sequence number.
+  LookupKey(const Slice& user_key, SequenceNumber sequence);
+
+  ~LookupKey();
+
+  // Return a key suitable for lookup in a MemTable.
+  Slice memtable_key() const { return Slice(start_, end_ - start_); }
+
+  // Return an internal key (suitable for passing to an internal iterator)
+  Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }
+
+  // Return the user key
+  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }
+
+ private:
+  // We construct a char array of the form:
+  //    klength  varint32               <-- start_
+  //    userkey  char[klength]          <-- kstart_
+  //    tag      uint64
+  //                                    <-- end_
+  // The array is a suitable MemTable key.
+  // The suffix starting with "userkey" can be used as an InternalKey.
+  const char* start_;
+  const char* kstart_;
+  const char* end_;
+  char space_[200];      // Avoid allocation for short keys
+
+  // No copying allowed
+  LookupKey(const LookupKey&);
+  void operator=(const LookupKey&);
+};
+
+inline LookupKey::~LookupKey() {
+  if (start_ != space_) delete[] start_;
+}
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_FORMAT_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/filename.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/filename.cc
new file mode 100644
index 0000000..da32946
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/filename.cc
@@ -0,0 +1,144 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include <ctype.h>
+#include <stdio.h>
+#include "db/filename.h"
+#include "db/dbformat.h"
+#include "leveldb/env.h"
+#include "util/logging.h"
+
+namespace leveldb {
+
+// A utility routine: write "data" to the named file and Sync() it.
+extern Status WriteStringToFileSync(Env* env, const Slice& data,
+                                    const std::string& fname);
+
+static std::string MakeFileName(const std::string& name, uint64_t number,
+                                const char* suffix) {
+  char buf[100];
+  snprintf(buf, sizeof(buf), "/%06llu.%s",
+           static_cast<unsigned long long>(number),
+           suffix);
+  return name + buf;
+}
+
+std::string LogFileName(const std::string& name, uint64_t number) {
+  assert(number > 0);
+  return MakeFileName(name, number, "log");
+}
+
+std::string TableFileName(const std::string& name, uint64_t number) {
+  assert(number > 0);
+  return MakeFileName(name, number, "ldb");
+}
+
+std::string SSTTableFileName(const std::string& name, uint64_t number) {
+  assert(number > 0);
+  return MakeFileName(name, number, "sst");
+}
+
+std::string DescriptorFileName(const std::string& dbname, uint64_t number) {
+  assert(number > 0);
+  char buf[100];
+  snprintf(buf, sizeof(buf), "/MANIFEST-%06llu",
+           static_cast<unsigned long long>(number));
+  return dbname + buf;
+}
+
+std::string CurrentFileName(const std::string& dbname) {
+  return dbname + "/CURRENT";
+}
+
+std::string LockFileName(const std::string& dbname) {
+  return dbname + "/LOCK";
+}
+
+std::string TempFileName(const std::string& dbname, uint64_t number) {
+  assert(number > 0);
+  return MakeFileName(dbname, number, "dbtmp");
+}
+
+std::string InfoLogFileName(const std::string& dbname) {
+  return dbname + "/LOG";
+}
+
+// Return the name of the old info log file for "dbname".
+std::string OldInfoLogFileName(const std::string& dbname) {
+  return dbname + "/LOG.old";
+}
+
+
+// Owned filenames have the form:
+//    dbname/CURRENT
+//    dbname/LOCK
+//    dbname/LOG
+//    dbname/LOG.old
+//    dbname/MANIFEST-[0-9]+
+//    dbname/[0-9]+.(log|sst|ldb)
+bool ParseFileName(const std::string& fname,
+                   uint64_t* number,
+                   FileType* type) {
+  Slice rest(fname);
+  if (rest == "CURRENT") {
+    *number = 0;
+    *type = kCurrentFile;
+  } else if (rest == "LOCK") {
+    *number = 0;
+    *type = kDBLockFile;
+  } else if (rest == "LOG" || rest == "LOG.old") {
+    *number = 0;
+    *type = kInfoLogFile;
+  } else if (rest.starts_with("MANIFEST-")) {
+    rest.remove_prefix(strlen("MANIFEST-"));
+    uint64_t num;
+    if (!ConsumeDecimalNumber(&rest, &num)) {
+      return false;
+    }
+    if (!rest.empty()) {
+      return false;
+    }
+    *type = kDescriptorFile;
+    *number = num;
+  } else {
+    // Avoid strtoull() to keep filename format independent of the
+    // current locale
+    uint64_t num;
+    if (!ConsumeDecimalNumber(&rest, &num)) {
+      return false;
+    }
+    Slice suffix = rest;
+    if (suffix == Slice(".log")) {
+      *type = kLogFile;
+    } else if (suffix == Slice(".sst") || suffix == Slice(".ldb")) {
+      *type = kTableFile;
+    } else if (suffix == Slice(".dbtmp")) {
+      *type = kTempFile;
+    } else {
+      return false;
+    }
+    *number = num;
+  }
+  return true;
+}
+
+Status SetCurrentFile(Env* env, const std::string& dbname,
+                      uint64_t descriptor_number) {
+  // Remove leading "dbname/" and add newline to manifest file name
+  std::string manifest = DescriptorFileName(dbname, descriptor_number);
+  Slice contents = manifest;
+  assert(contents.starts_with(dbname + "/"));
+  contents.remove_prefix(dbname.size() + 1);
+  std::string tmp = TempFileName(dbname, descriptor_number);
+  Status s = WriteStringToFileSync(env, contents.ToString() + "\n", tmp);
+  if (s.ok()) {
+    s = env->RenameFile(tmp, CurrentFileName(dbname));
+  }
+  if (!s.ok()) {
+    env->DeleteFile(tmp);
+  }
+  return s;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/filename.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/filename.h
new file mode 100644
index 0000000..87a7526
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/filename.h
@@ -0,0 +1,85 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// File names used by DB code
+
+#ifndef STORAGE_LEVELDB_DB_FILENAME_H_
+#define STORAGE_LEVELDB_DB_FILENAME_H_
+
+#include <stdint.h>
+#include <string>
+#include "leveldb/slice.h"
+#include "leveldb/status.h"
+#include "port/port.h"
+
+namespace leveldb {
+
+class Env;
+
+enum FileType {
+  kLogFile,
+  kDBLockFile,
+  kTableFile,
+  kDescriptorFile,
+  kCurrentFile,
+  kTempFile,
+  kInfoLogFile  // Either the current one, or an old one
+};
+
+// Return the name of the log file with the specified number
+// in the db named by "dbname".  The result will be prefixed with
+// "dbname".
+extern std::string LogFileName(const std::string& dbname, uint64_t number);
+
+// Return the name of the sstable with the specified number
+// in the db named by "dbname".  The result will be prefixed with
+// "dbname".
+extern std::string TableFileName(const std::string& dbname, uint64_t number);
+
+// Return the legacy file name for an sstable with the specified number
+// in the db named by "dbname". The result will be prefixed with
+// "dbname".
+extern std::string SSTTableFileName(const std::string& dbname, uint64_t number);
+
+// Return the name of the descriptor file for the db named by
+// "dbname" and the specified incarnation number.  The result will be
+// prefixed with "dbname".
+extern std::string DescriptorFileName(const std::string& dbname,
+                                      uint64_t number);
+
+// Return the name of the current file.  This file contains the name
+// of the current manifest file.  The result will be prefixed with
+// "dbname".
+extern std::string CurrentFileName(const std::string& dbname);
+
+// Return the name of the lock file for the db named by
+// "dbname".  The result will be prefixed with "dbname".
+extern std::string LockFileName(const std::string& dbname);
+
+// Return the name of a temporary file owned by the db named "dbname".
+// The result will be prefixed with "dbname".
+extern std::string TempFileName(const std::string& dbname, uint64_t number);
+
+// Return the name of the info log file for "dbname".
+extern std::string InfoLogFileName(const std::string& dbname);
+
+// Return the name of the old info log file for "dbname".
+extern std::string OldInfoLogFileName(const std::string& dbname);
+
+// If filename is a leveldb file, store the type of the file in *type.
+// The number encoded in the filename is stored in *number.  If the
+// filename was successfully parsed, returns true.  Else return false.
+extern bool ParseFileName(const std::string& filename,
+                          uint64_t* number,
+                          FileType* type);
+
+// Make the CURRENT file point to the descriptor file with the
+// specified number.
+extern Status SetCurrentFile(Env* env, const std::string& dbname,
+                             uint64_t descriptor_number);
+
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_FILENAME_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/leveldb_main.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/leveldb_main.cc
new file mode 100644
index 0000000..995d761
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/leveldb_main.cc
@@ -0,0 +1,238 @@
+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include <stdio.h>
+#include "db/dbformat.h"
+#include "db/filename.h"
+#include "db/log_reader.h"
+#include "db/version_edit.h"
+#include "db/write_batch_internal.h"
+#include "leveldb/env.h"
+#include "leveldb/iterator.h"
+#include "leveldb/options.h"
+#include "leveldb/status.h"
+#include "leveldb/table.h"
+#include "leveldb/write_batch.h"
+#include "util/logging.h"
+
+namespace leveldb {
+
+namespace {
+
+bool GuessType(const std::string& fname, FileType* type) {
+  size_t pos = fname.rfind('/');
+  std::string basename;
+  if (pos == std::string::npos) {
+    basename = fname;
+  } else {
+    basename = std::string(fname.data() + pos + 1, fname.size() - pos - 1);
+  }
+  uint64_t ignored;
+  return ParseFileName(basename, &ignored, type);
+}
+
+// Notified when log reader encounters corruption.
+class CorruptionReporter : public log::Reader::Reporter {
+ public:
+  virtual void Corruption(size_t bytes, const Status& status) {
+    printf("corruption: %d bytes; %s\n",
+            static_cast<int>(bytes),
+            status.ToString().c_str());
+  }
+};
+
+// Print contents of a log file. (*func)() is called on every record.
+bool PrintLogContents(Env* env, const std::string& fname,
+                      void (*func)(Slice)) {
+  SequentialFile* file;
+  Status s = env->NewSequentialFile(fname, &file);
+  if (!s.ok()) {
+    fprintf(stderr, "%s\n", s.ToString().c_str());
+    return false;
+  }
+  CorruptionReporter reporter;
+  log::Reader reader(file, &reporter, true, 0);
+  Slice record;
+  std::string scratch;
+  while (reader.ReadRecord(&record, &scratch)) {
+    printf("--- offset %llu; ",
+           static_cast<unsigned long long>(reader.LastRecordOffset()));
+    (*func)(record);
+  }
+  delete file;
+  return true;
+}
+
+// Called on every item found in a WriteBatch.
+class WriteBatchItemPrinter : public WriteBatch::Handler {
+ public:
+  uint64_t offset_;
+  uint64_t sequence_;
+
+  virtual void Put(const Slice& key, const Slice& value) {
+    printf("  put '%s' '%s'\n",
+           EscapeString(key).c_str(),
+           EscapeString(value).c_str());
+  }
+  virtual void Delete(const Slice& key) {
+    printf("  del '%s'\n",
+           EscapeString(key).c_str());
+  }
+};
+
+
+// Called on every log record (each one of which is a WriteBatch)
+// found in a kLogFile.
+static void WriteBatchPrinter(Slice record) {
+  if (record.size() < 12) {
+    printf("log record length %d is too small\n",
+           static_cast<int>(record.size()));
+    return;
+  }
+  WriteBatch batch;
+  WriteBatchInternal::SetContents(&batch, record);
+  printf("sequence %llu\n",
+         static_cast<unsigned long long>(WriteBatchInternal::Sequence(&batch)));
+  WriteBatchItemPrinter batch_item_printer;
+  Status s = batch.Iterate(&batch_item_printer);
+  if (!s.ok()) {
+    printf("  error: %s\n", s.ToString().c_str());
+  }
+}
+
+bool DumpLog(Env* env, const std::string& fname) {
+  return PrintLogContents(env, fname, WriteBatchPrinter);
+}
+
+// Called on every log record (each one of which is a WriteBatch)
+// found in a kDescriptorFile.
+static void VersionEditPrinter(Slice record) {
+  VersionEdit edit;
+  Status s = edit.DecodeFrom(record);
+  if (!s.ok()) {
+    printf("%s\n", s.ToString().c_str());
+    return;
+  }
+  printf("%s", edit.DebugString().c_str());
+}
+
+bool DumpDescriptor(Env* env, const std::string& fname) {
+  return PrintLogContents(env, fname, VersionEditPrinter);
+}
+
+bool DumpTable(Env* env, const std::string& fname) {
+  uint64_t file_size;
+  RandomAccessFile* file = NULL;
+  Table* table = NULL;
+  Status s = env->GetFileSize(fname, &file_size);
+  if (s.ok()) {
+    s = env->NewRandomAccessFile(fname, &file);
+  }
+  if (s.ok()) {
+    // We use the default comparator, which may or may not match the
+    // comparator used in this database. However this should not cause
+    // problems since we only use Table operations that do not require
+    // any comparisons.  In particular, we do not call Seek or Prev.
+    s = Table::Open(Options(), file, file_size, &table);
+  }
+  if (!s.ok()) {
+    fprintf(stderr, "%s\n", s.ToString().c_str());
+    delete table;
+    delete file;
+    return false;
+  }
+
+  ReadOptions ro;
+  ro.fill_cache = false;
+  Iterator* iter = table->NewIterator(ro);
+  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
+    ParsedInternalKey key;
+    if (!ParseInternalKey(iter->key(), &key)) {
+      printf("badkey '%s' => '%s'\n",
+             EscapeString(iter->key()).c_str(),
+             EscapeString(iter->value()).c_str());
+    } else {
+      char kbuf[20];
+      const char* type;
+      if (key.type == kTypeDeletion) {
+        type = "del";
+      } else if (key.type == kTypeValue) {
+        type = "val";
+      } else {
+        snprintf(kbuf, sizeof(kbuf), "%d", static_cast<int>(key.type));
+        type = kbuf;
+      }
+      printf("'%s' @ %8llu : %s => '%s'\n",
+             EscapeString(key.user_key).c_str(),
+             static_cast<unsigned long long>(key.sequence),
+             type,
+             EscapeString(iter->value()).c_str());
+    }
+  }
+  s = iter->status();
+  if (!s.ok()) {
+    printf("iterator error: %s\n", s.ToString().c_str());
+  }
+
+  delete iter;
+  delete table;
+  delete file;
+  return true;
+}
+
+bool DumpFile(Env* env, const std::string& fname) {
+  FileType ftype;
+  if (!GuessType(fname, &ftype)) {
+    fprintf(stderr, "%s: unknown file type\n", fname.c_str());
+    return false;
+  }
+  switch (ftype) {
+    case kLogFile:         return DumpLog(env, fname);
+    case kDescriptorFile:  return DumpDescriptor(env, fname);
+    case kTableFile:       return DumpTable(env, fname);
+
+    default: {
+      fprintf(stderr, "%s: not a dump-able file type\n", fname.c_str());
+      break;
+    }
+  }
+  return false;
+}
+
+bool HandleDumpCommand(Env* env, char** files, int num) {
+  bool ok = true;
+  for (int i = 0; i < num; i++) {
+    ok &= DumpFile(env, files[i]);
+  }
+  return ok;
+}
+
+}
+}  // namespace leveldb
+
+static void Usage() {
+  fprintf(
+      stderr,
+      "Usage: leveldbutil command...\n"
+      "   dump files...         -- dump contents of specified files\n"
+      );
+}
+
+int main(int argc, char** argv) {
+  leveldb::Env* env = leveldb::Env::Default();
+  bool ok = true;
+  if (argc < 2) {
+    Usage();
+    ok = false;
+  } else {
+    std::string command = argv[1];
+    if (command == "dump") {
+      ok = leveldb::HandleDumpCommand(env, argv+2, argc-2);
+    } else {
+      Usage();
+      ok = false;
+    }
+  }
+  return (ok ? 0 : 1);
+}
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/log_format.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/log_format.h
new file mode 100644
index 0000000..2690cb9
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/log_format.h
@@ -0,0 +1,35 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// Log format information shared by reader and writer.
+// See ../doc/log_format.txt for more detail.
+
+#ifndef STORAGE_LEVELDB_DB_LOG_FORMAT_H_
+#define STORAGE_LEVELDB_DB_LOG_FORMAT_H_
+
+namespace leveldb {
+namespace log {
+
+enum RecordType {
+  // Zero is reserved for preallocated files
+  kZeroType = 0,
+
+  kFullType = 1,
+
+  // For fragments
+  kFirstType = 2,
+  kMiddleType = 3,
+  kLastType = 4
+};
+static const int kMaxRecordType = kLastType;
+
+static const int kBlockSize = 32768;
+
+// Header is checksum (4 bytes), type (1 byte), length (2 bytes).
+static const int kHeaderSize = 4 + 1 + 2;
+
+}  // namespace log
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_LOG_FORMAT_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/log_reader.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/log_reader.cc
new file mode 100644
index 0000000..4919216
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/log_reader.cc
@@ -0,0 +1,266 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "db/log_reader.h"
+
+#include <stdio.h>
+#include "leveldb/env.h"
+#include "util/coding.h"
+#include "util/crc32c.h"
+
+namespace leveldb {
+namespace log {
+
+Reader::Reporter::~Reporter() {
+}
+
+Reader::Reader(SequentialFile* file, Reporter* reporter, bool checksum,
+               uint64_t initial_offset)
+    : file_(file),
+      reporter_(reporter),
+      checksum_(checksum),
+      backing_store_(new char[kBlockSize]),
+      buffer_(),
+      eof_(false),
+      last_record_offset_(0),
+      end_of_buffer_offset_(0),
+      initial_offset_(initial_offset) {
+}
+
+Reader::~Reader() {
+  delete[] backing_store_;
+}
+
+bool Reader::SkipToInitialBlock() {
+  size_t offset_in_block = initial_offset_ % kBlockSize;
+  uint64_t block_start_location = initial_offset_ - offset_in_block;
+
+  // Don't search a block if we'd be in the trailer
+  if (offset_in_block > kBlockSize - 6) {
+    offset_in_block = 0;
+    block_start_location += kBlockSize;
+  }
+
+  end_of_buffer_offset_ = block_start_location;
+
+  // Skip to start of first block that can contain the initial record
+  if (block_start_location > 0) {
+    Status skip_status = file_->Skip(block_start_location);
+    if (!skip_status.ok()) {
+      ReportDrop(block_start_location, skip_status);
+      return false;
+    }
+  }
+
+  return true;
+}
+
+bool Reader::ReadRecord(Slice* record, std::string* scratch) {
+  if (last_record_offset_ < initial_offset_) {
+    if (!SkipToInitialBlock()) {
+      return false;
+    }
+  }
+
+  scratch->clear();
+  record->clear();
+  bool in_fragmented_record = false;
+  // Record offset of the logical record that we're reading
+  // 0 is a dummy value to make compilers happy
+  uint64_t prospective_record_offset = 0;
+
+  Slice fragment;
+  while (true) {
+    uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();
+    const unsigned int record_type = ReadPhysicalRecord(&fragment);
+    switch (record_type) {
+      case kFullType:
+        if (in_fragmented_record) {
+          // Handle bug in earlier versions of log::Writer where
+          // it could emit an empty kFirstType record at the tail end
+          // of a block followed by a kFullType or kFirstType record
+          // at the beginning of the next block.
+          if (scratch->empty()) {
+            in_fragmented_record = false;
+          } else {
+            ReportCorruption(scratch->size(), "partial record without end(1)");
+          }
+        }
+        prospective_record_offset = physical_record_offset;
+        scratch->clear();
+        *record = fragment;
+        last_record_offset_ = prospective_record_offset;
+        return true;
+
+      case kFirstType:
+        if (in_fragmented_record) {
+          // Handle bug in earlier versions of log::Writer where
+          // it could emit an empty kFirstType record at the tail end
+          // of a block followed by a kFullType or kFirstType record
+          // at the beginning of the next block.
+          if (scratch->empty()) {
+            in_fragmented_record = false;
+          } else {
+            ReportCorruption(scratch->size(), "partial record without end(2)");
+          }
+        }
+        prospective_record_offset = physical_record_offset;
+        scratch->assign(fragment.data(), fragment.size());
+        in_fragmented_record = true;
+        break;
+
+      case kMiddleType:
+        if (!in_fragmented_record) {
+          ReportCorruption(fragment.size(),
+                           "missing start of fragmented record(1)");
+        } else {
+          scratch->append(fragment.data(), fragment.size());
+        }
+        break;
+
+      case kLastType:
+        if (!in_fragmented_record) {
+          ReportCorruption(fragment.size(),
+                           "missing start of fragmented record(2)");
+        } else {
+          scratch->append(fragment.data(), fragment.size());
+          *record = Slice(*scratch);
+          last_record_offset_ = prospective_record_offset;
+          return true;
+        }
+        break;
+
+      case kEof:
+        if (in_fragmented_record) {
+          // This can be caused by the writer dying immediately after
+          // writing a physical record but before completing the next; don't
+          // treat it as a corruption, just ignore the entire logical record.
+          scratch->clear();
+        }
+        return false;
+
+      case kBadRecord:
+        if (in_fragmented_record) {
+          ReportCorruption(scratch->size(), "error in middle of record");
+          in_fragmented_record = false;
+          scratch->clear();
+        }
+        break;
+
+      default: {
+        char buf[40];
+        snprintf(buf, sizeof(buf), "unknown record type %u", record_type);
+        ReportCorruption(
+            (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),
+            buf);
+        in_fragmented_record = false;
+        scratch->clear();
+        break;
+      }
+    }
+  }
+  return false;
+}
+
+uint64_t Reader::LastRecordOffset() {
+  return last_record_offset_;
+}
+
+void Reader::ReportCorruption(size_t bytes, const char* reason) {
+  ReportDrop(bytes, Status::Corruption(reason));
+}
+
+void Reader::ReportDrop(size_t bytes, const Status& reason) {
+  if (reporter_ != NULL &&
+      end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {
+    reporter_->Corruption(bytes, reason);
+  }
+}
+
+unsigned int Reader::ReadPhysicalRecord(Slice* result) {
+  while (true) {
+    if (buffer_.size() < kHeaderSize) {
+      if (!eof_) {
+        // Last read was a full read, so this is a trailer to skip
+        buffer_.clear();
+        Status status = file_->Read(kBlockSize, &buffer_, backing_store_);
+        end_of_buffer_offset_ += buffer_.size();
+        if (!status.ok()) {
+          buffer_.clear();
+          ReportDrop(kBlockSize, status);
+          eof_ = true;
+          return kEof;
+        } else if (buffer_.size() < kBlockSize) {
+          eof_ = true;
+        }
+        continue;
+      } else {
+        // Note that if buffer_ is non-empty, we have a truncated header at the
+        // end of the file, which can be caused by the writer crashing in the
+        // middle of writing the header. Instead of considering this an error,
+        // just report EOF.
+        buffer_.clear();
+        return kEof;
+      }
+    }
+
+    // Parse the header
+    const char* header = buffer_.data();
+    const uint32_t a = static_cast<uint32_t>(header[4]) & 0xff;
+    const uint32_t b = static_cast<uint32_t>(header[5]) & 0xff;
+    const unsigned int type = header[6];
+    const uint32_t length = a | (b << 8);
+    if (kHeaderSize + length > buffer_.size()) {
+      size_t drop_size = buffer_.size();
+      buffer_.clear();
+      if (!eof_) {
+        ReportCorruption(drop_size, "bad record length");
+        return kBadRecord;
+      }
+      // If the end of the file has been reached without reading |length| bytes
+      // of payload, assume the writer died in the middle of writing the record.
+      // Don't report a corruption.
+      return kEof;
+    }
+
+    if (type == kZeroType && length == 0) {
+      // Skip zero length record without reporting any drops since
+      // such records are produced by the mmap based writing code in
+      // env_posix.cc that preallocates file regions.
+      buffer_.clear();
+      return kBadRecord;
+    }
+
+    // Check crc
+    if (checksum_) {
+      uint32_t expected_crc = crc32c::Unmask(DecodeFixed32(header));
+      uint32_t actual_crc = crc32c::Value(header + 6, 1 + length);
+      if (actual_crc != expected_crc) {
+        // Drop the rest of the buffer since "length" itself may have
+        // been corrupted and if we trust it, we could find some
+        // fragment of a real log record that just happens to look
+        // like a valid log record.
+        size_t drop_size = buffer_.size();
+        buffer_.clear();
+        ReportCorruption(drop_size, "checksum mismatch");
+        return kBadRecord;
+      }
+    }
+
+    buffer_.remove_prefix(kHeaderSize + length);
+
+    // Skip physical record that started before initial_offset_
+    if (end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length <
+        initial_offset_) {
+      result->clear();
+      return kBadRecord;
+    }
+
+    *result = Slice(header + kHeaderSize, length);
+    return type;
+  }
+}
+
+}  // namespace log
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/log_reader.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/log_reader.h
new file mode 100644
index 0000000..82d4bee
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/log_reader.h
@@ -0,0 +1,108 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_DB_LOG_READER_H_
+#define STORAGE_LEVELDB_DB_LOG_READER_H_
+
+#include <stdint.h>
+
+#include "db/log_format.h"
+#include "leveldb/slice.h"
+#include "leveldb/status.h"
+
+namespace leveldb {
+
+class SequentialFile;
+
+namespace log {
+
+class Reader {
+ public:
+  // Interface for reporting errors.
+  class Reporter {
+   public:
+    virtual ~Reporter();
+
+    // Some corruption was detected.  "size" is the approximate number
+    // of bytes dropped due to the corruption.
+    virtual void Corruption(size_t bytes, const Status& status) = 0;
+  };
+
+  // Create a reader that will return log records from "*file".
+  // "*file" must remain live while this Reader is in use.
+  //
+  // If "reporter" is non-NULL, it is notified whenever some data is
+  // dropped due to a detected corruption.  "*reporter" must remain
+  // live while this Reader is in use.
+  //
+  // If "checksum" is true, verify checksums if available.
+  //
+  // The Reader will start reading at the first record located at physical
+  // position >= initial_offset within the file.
+  Reader(SequentialFile* file, Reporter* reporter, bool checksum,
+         uint64_t initial_offset);
+
+  ~Reader();
+
+  // Read the next record into *record.  Returns true if read
+  // successfully, false if we hit end of the input.  May use
+  // "*scratch" as temporary storage.  The contents filled in *record
+  // will only be valid until the next mutating operation on this
+  // reader or the next mutation to *scratch.
+  bool ReadRecord(Slice* record, std::string* scratch);
+
+  // Returns the physical offset of the last record returned by ReadRecord.
+  //
+  // Undefined before the first call to ReadRecord.
+  uint64_t LastRecordOffset();
+
+ private:
+  SequentialFile* const file_;
+  Reporter* const reporter_;
+  bool const checksum_;
+  char* const backing_store_;
+  Slice buffer_;
+  bool eof_;   // Last Read() indicated EOF by returning < kBlockSize
+
+  // Offset of the last record returned by ReadRecord.
+  uint64_t last_record_offset_;
+  // Offset of the first location past the end of buffer_.
+  uint64_t end_of_buffer_offset_;
+
+  // Offset at which to start looking for the first record to return
+  uint64_t const initial_offset_;
+
+  // Extend record types with the following special values
+  enum {
+    kEof = kMaxRecordType + 1,
+    // Returned whenever we find an invalid physical record.
+    // Currently there are three situations in which this happens:
+    // * The record has an invalid CRC (ReadPhysicalRecord reports a drop)
+    // * The record is a 0-length record (No drop is reported)
+    // * The record is below constructor's initial_offset (No drop is reported)
+    kBadRecord = kMaxRecordType + 2
+  };
+
+  // Skips all blocks that are completely before "initial_offset_".
+  //
+  // Returns true on success. Handles reporting.
+  bool SkipToInitialBlock();
+
+  // Return type, or one of the preceding special values
+  unsigned int ReadPhysicalRecord(Slice* result);
+
+  // Reports dropped bytes to the reporter.
+  // buffer_ must be updated to remove the dropped bytes prior to invocation.
+  void ReportCorruption(size_t bytes, const char* reason);
+  void ReportDrop(size_t bytes, const Status& reason);
+
+  // No copying allowed
+  Reader(const Reader&);
+  void operator=(const Reader&);
+};
+
+}  // namespace log
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_LOG_READER_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/log_writer.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/log_writer.cc
new file mode 100644
index 0000000..2da99ac
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/log_writer.cc
@@ -0,0 +1,103 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "db/log_writer.h"
+
+#include <stdint.h>
+#include "leveldb/env.h"
+#include "util/coding.h"
+#include "util/crc32c.h"
+
+namespace leveldb {
+namespace log {
+
+Writer::Writer(WritableFile* dest)
+    : dest_(dest),
+      block_offset_(0) {
+  for (int i = 0; i <= kMaxRecordType; i++) {
+    char t = static_cast<char>(i);
+    type_crc_[i] = crc32c::Value(&t, 1);
+  }
+}
+
+Writer::~Writer() {
+}
+
+Status Writer::AddRecord(const Slice& slice) {
+  const char* ptr = slice.data();
+  size_t left = slice.size();
+
+  // Fragment the record if necessary and emit it.  Note that if slice
+  // is empty, we still want to iterate once to emit a single
+  // zero-length record
+  Status s;
+  bool begin = true;
+  do {
+    const int leftover = kBlockSize - block_offset_;
+    assert(leftover >= 0);
+    if (leftover < kHeaderSize) {
+      // Switch to a new block
+      if (leftover > 0) {
+        // Fill the trailer (literal below relies on kHeaderSize being 7)
+        assert(kHeaderSize == 7);
+        dest_->Append(Slice("\x00\x00\x00\x00\x00\x00", leftover));
+      }
+      block_offset_ = 0;
+    }
+
+    // Invariant: we never leave < kHeaderSize bytes in a block.
+    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);
+
+    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;
+    const size_t fragment_length = (left < avail) ? left : avail;
+
+    RecordType type;
+    const bool end = (left == fragment_length);
+    if (begin && end) {
+      type = kFullType;
+    } else if (begin) {
+      type = kFirstType;
+    } else if (end) {
+      type = kLastType;
+    } else {
+      type = kMiddleType;
+    }
+
+    s = EmitPhysicalRecord(type, ptr, fragment_length);
+    ptr += fragment_length;
+    left -= fragment_length;
+    begin = false;
+  } while (s.ok() && left > 0);
+  return s;
+}
+
+Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr, size_t n) {
+  assert(n <= 0xffff);  // Must fit in two bytes
+  assert(block_offset_ + kHeaderSize + n <= kBlockSize);
+
+  // Format the header
+  char buf[kHeaderSize];
+  buf[4] = static_cast<char>(n & 0xff);
+  buf[5] = static_cast<char>(n >> 8);
+  buf[6] = static_cast<char>(t);
+
+  // Compute the crc of the record type and the payload.
+  uint32_t crc = crc32c::Extend(type_crc_[t], ptr, n);
+  crc = crc32c::Mask(crc);                 // Adjust for storage
+  EncodeFixed32(buf, crc);
+
+  // Write the header and the payload
+  Status s = dest_->Append(Slice(buf, kHeaderSize));
+  if (s.ok()) {
+    s = dest_->Append(Slice(ptr, n));
+    if (s.ok()) {
+      s = dest_->Flush();
+    }
+  }
+  block_offset_ += kHeaderSize + n;
+  return s;
+}
+
+}  // namespace log
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/log_writer.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/log_writer.h
new file mode 100644
index 0000000..a3a954d
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/log_writer.h
@@ -0,0 +1,48 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_DB_LOG_WRITER_H_
+#define STORAGE_LEVELDB_DB_LOG_WRITER_H_
+
+#include <stdint.h>
+#include "db/log_format.h"
+#include "leveldb/slice.h"
+#include "leveldb/status.h"
+
+namespace leveldb {
+
+class WritableFile;
+
+namespace log {
+
+class Writer {
+ public:
+  // Create a writer that will append data to "*dest".
+  // "*dest" must be initially empty.
+  // "*dest" must remain live while this Writer is in use.
+  explicit Writer(WritableFile* dest);
+  ~Writer();
+
+  Status AddRecord(const Slice& slice);
+
+ private:
+  WritableFile* dest_;
+  int block_offset_;       // Current offset in block
+
+  // crc32c values for all supported record types.  These are
+  // pre-computed to reduce the overhead of computing the crc of the
+  // record type stored in the header.
+  uint32_t type_crc_[kMaxRecordType + 1];
+
+  Status EmitPhysicalRecord(RecordType type, const char* ptr, size_t length);
+
+  // No copying allowed
+  Writer(const Writer&);
+  void operator=(const Writer&);
+};
+
+}  // namespace log
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_LOG_WRITER_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/memtable.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/memtable.cc
new file mode 100644
index 0000000..bfec0a7
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/memtable.cc
@@ -0,0 +1,145 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "db/memtable.h"
+#include "db/dbformat.h"
+#include "leveldb/comparator.h"
+#include "leveldb/env.h"
+#include "leveldb/iterator.h"
+#include "util/coding.h"
+
+namespace leveldb {
+
+static Slice GetLengthPrefixedSlice(const char* data) {
+  uint32_t len;
+  const char* p = data;
+  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume "p" is not corrupted
+  return Slice(p, len);
+}
+
+MemTable::MemTable(const InternalKeyComparator& cmp)
+    : comparator_(cmp),
+      refs_(0),
+      table_(comparator_, &arena_) {
+}
+
+MemTable::~MemTable() {
+  assert(refs_ == 0);
+}
+
+size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); }
+
+int MemTable::KeyComparator::operator()(const char* aptr, const char* bptr)
+    const {
+  // Internal keys are encoded as length-prefixed strings.
+  Slice a = GetLengthPrefixedSlice(aptr);
+  Slice b = GetLengthPrefixedSlice(bptr);
+  return comparator.Compare(a, b);
+}
+
+// Encode a suitable internal key target for "target" and return it.
+// Uses *scratch as scratch space, and the returned pointer will point
+// into this scratch space.
+static const char* EncodeKey(std::string* scratch, const Slice& target) {
+  scratch->clear();
+  PutVarint32(scratch, target.size());
+  scratch->append(target.data(), target.size());
+  return scratch->data();
+}
+
+class MemTableIterator: public Iterator {
+ public:
+  explicit MemTableIterator(MemTable::Table* table) : iter_(table) { }
+
+  virtual bool Valid() const { return iter_.Valid(); }
+  virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }
+  virtual void SeekToFirst() { iter_.SeekToFirst(); }
+  virtual void SeekToLast() { iter_.SeekToLast(); }
+  virtual void Next() { iter_.Next(); }
+  virtual void Prev() { iter_.Prev(); }
+  virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }
+  virtual Slice value() const {
+    Slice key_slice = GetLengthPrefixedSlice(iter_.key());
+    return GetLengthPrefixedSlice(key_slice.data() + key_slice.size());
+  }
+
+  virtual Status status() const { return Status::OK(); }
+
+ private:
+  MemTable::Table::Iterator iter_;
+  std::string tmp_;       // For passing to EncodeKey
+
+  // No copying allowed
+  MemTableIterator(const MemTableIterator&);
+  void operator=(const MemTableIterator&);
+};
+
+Iterator* MemTable::NewIterator() {
+  return new MemTableIterator(&table_);
+}
+
+void MemTable::Add(SequenceNumber s, ValueType type,
+                   const Slice& key,
+                   const Slice& value) {
+  // Format of an entry is concatenation of:
+  //  key_size     : varint32 of internal_key.size()
+  //  key bytes    : char[internal_key.size()]
+  //  value_size   : varint32 of value.size()
+  //  value bytes  : char[value.size()]
+  size_t key_size = key.size();
+  size_t val_size = value.size();
+  size_t internal_key_size = key_size + 8;
+  const size_t encoded_len =
+      VarintLength(internal_key_size) + internal_key_size +
+      VarintLength(val_size) + val_size;
+  char* buf = arena_.Allocate(encoded_len);
+  char* p = EncodeVarint32(buf, internal_key_size);
+  memcpy(p, key.data(), key_size);
+  p += key_size;
+  EncodeFixed64(p, (s << 8) | type);
+  p += 8;
+  p = EncodeVarint32(p, val_size);
+  memcpy(p, value.data(), val_size);
+  assert((p + val_size) - buf == encoded_len);
+  table_.Insert(buf);
+}
+
+bool MemTable::Get(const LookupKey& key, std::string* value, Status* s) {
+  Slice memkey = key.memtable_key();
+  Table::Iterator iter(&table_);
+  iter.Seek(memkey.data());
+  if (iter.Valid()) {
+    // entry format is:
+    //    klength  varint32
+    //    userkey  char[klength]
+    //    tag      uint64
+    //    vlength  varint32
+    //    value    char[vlength]
+    // Check that it belongs to same user key.  We do not check the
+    // sequence number since the Seek() call above should have skipped
+    // all entries with overly large sequence numbers.
+    const char* entry = iter.key();
+    uint32_t key_length;
+    const char* key_ptr = GetVarint32Ptr(entry, entry+5, &key_length);
+    if (comparator_.comparator.user_comparator()->Compare(
+            Slice(key_ptr, key_length - 8),
+            key.user_key()) == 0) {
+      // Correct user key
+      const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8);
+      switch (static_cast<ValueType>(tag & 0xff)) {
+        case kTypeValue: {
+          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);
+          value->assign(v.data(), v.size());
+          return true;
+        }
+        case kTypeDeletion:
+          *s = Status::NotFound(Slice());
+          return true;
+      }
+    }
+  }
+  return false;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/memtable.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/memtable.h
new file mode 100644
index 0000000..92e90bb
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/memtable.h
@@ -0,0 +1,91 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_DB_MEMTABLE_H_
+#define STORAGE_LEVELDB_DB_MEMTABLE_H_
+
+#include <string>
+#include "leveldb/db.h"
+#include "db/dbformat.h"
+#include "db/skiplist.h"
+#include "util/arena.h"
+
+namespace leveldb {
+
+class InternalKeyComparator;
+class Mutex;
+class MemTableIterator;
+
+class MemTable {
+ public:
+  // MemTables are reference counted.  The initial reference count
+  // is zero and the caller must call Ref() at least once.
+  explicit MemTable(const InternalKeyComparator& comparator);
+
+  // Increase reference count.
+  void Ref() { ++refs_; }
+
+  // Drop reference count.  Delete if no more references exist.
+  void Unref() {
+    --refs_;
+    assert(refs_ >= 0);
+    if (refs_ <= 0) {
+      delete this;
+    }
+  }
+
+  // Returns an estimate of the number of bytes of data in use by this
+  // data structure.
+  //
+  // REQUIRES: external synchronization to prevent simultaneous
+  // operations on the same MemTable.
+  size_t ApproximateMemoryUsage();
+
+  // Return an iterator that yields the contents of the memtable.
+  //
+  // The caller must ensure that the underlying MemTable remains live
+  // while the returned iterator is live.  The keys returned by this
+  // iterator are internal keys encoded by AppendInternalKey in the
+  // db/format.{h,cc} module.
+  Iterator* NewIterator();
+
+  // Add an entry into memtable that maps key to value at the
+  // specified sequence number and with the specified type.
+  // Typically value will be empty if type==kTypeDeletion.
+  void Add(SequenceNumber seq, ValueType type,
+           const Slice& key,
+           const Slice& value);
+
+  // If memtable contains a value for key, store it in *value and return true.
+  // If memtable contains a deletion for key, store a NotFound() error
+  // in *status and return true.
+  // Else, return false.
+  bool Get(const LookupKey& key, std::string* value, Status* s);
+
+ private:
+  ~MemTable();  // Private since only Unref() should be used to delete it
+
+  struct KeyComparator {
+    const InternalKeyComparator comparator;
+    explicit KeyComparator(const InternalKeyComparator& c) : comparator(c) { }
+    int operator()(const char* a, const char* b) const;
+  };
+  friend class MemTableIterator;
+  friend class MemTableBackwardIterator;
+
+  typedef SkipList<const char*, KeyComparator> Table;
+
+  KeyComparator comparator_;
+  int refs_;
+  Arena arena_;
+  Table table_;
+
+  // No copying allowed
+  MemTable(const MemTable&);
+  void operator=(const MemTable&);
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_MEMTABLE_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/repair.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/repair.cc
new file mode 100644
index 0000000..c084433
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/repair.cc
@@ -0,0 +1,462 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// We recover the contents of the descriptor from the other files we find.
+// (1) Any log files are first converted to tables
+// (2) We scan every table to compute
+//     (a) smallest/largest for the table
+//     (b) largest sequence number in the table
+// (3) We generate descriptor contents:
+//      - log number is set to zero
+//      - next-file-number is set to 1 + largest file number we found
+//      - last-sequence-number is set to largest sequence# found across
+//        all tables (see 2c)
+//      - compaction pointers are cleared
+//      - every table file is added at level 0
+//
+// Possible optimization 1:
+//   (a) Compute total size and use to pick appropriate max-level M
+//   (b) Sort tables by largest sequence# in the table
+//   (c) For each table: if it overlaps earlier table, place in level-0,
+//       else place in level-M.
+// Possible optimization 2:
+//   Store per-table metadata (smallest, largest, largest-seq#, ...)
+//   in the table's meta section to speed up ScanTable.
+
+#include "db/builder.h"
+#include "db/db_impl.h"
+#include "db/dbformat.h"
+#include "db/filename.h"
+#include "db/log_reader.h"
+#include "db/log_writer.h"
+#include "db/memtable.h"
+#include "db/table_cache.h"
+#include "db/version_edit.h"
+#include "db/write_batch_internal.h"
+#include "leveldb/comparator.h"
+#include "leveldb/db.h"
+#include "leveldb/env.h"
+
+namespace leveldb {
+
+namespace {
+
+class Repairer {
+ public:
+  Repairer(const std::string& dbname, const Options& options)
+      : dbname_(dbname),
+        env_(options.env),
+        icmp_(options.comparator),
+        ipolicy_(options.filter_policy),
+        options_(SanitizeOptions(dbname, &icmp_, &ipolicy_, options)),
+        owns_info_log_(options_.info_log != options.info_log),
+        owns_cache_(options_.block_cache != options.block_cache),
+        next_file_number_(1) {
+    // TableCache can be small since we expect each table to be opened once.
+    table_cache_ = new TableCache(dbname_, &options_, 10);
+  }
+
+  ~Repairer() {
+    delete table_cache_;
+    if (owns_info_log_) {
+      delete options_.info_log;
+    }
+    if (owns_cache_) {
+      delete options_.block_cache;
+    }
+  }
+
+  Status Run() {
+    Status status = FindFiles();
+    if (status.ok()) {
+      ConvertLogFilesToTables();
+      ExtractMetaData();
+      status = WriteDescriptor();
+    }
+    if (status.ok()) {
+      unsigned long long bytes = 0;
+      for (size_t i = 0; i < tables_.size(); i++) {
+        bytes += tables_[i].meta.file_size;
+      }
+      Log(options_.info_log,
+          "**** Repaired leveldb %s; "
+          "recovered %d files; %llu bytes. "
+          "Some data may have been lost. "
+          "****",
+          dbname_.c_str(),
+          static_cast<int>(tables_.size()),
+          bytes);
+    }
+    return status;
+  }
+
+ private:
+  struct TableInfo {
+    FileMetaData meta;
+    SequenceNumber max_sequence;
+  };
+
+  std::string const dbname_;
+  Env* const env_;
+  InternalKeyComparator const icmp_;
+  InternalFilterPolicy const ipolicy_;
+  Options const options_;
+  bool owns_info_log_;
+  bool owns_cache_;
+  TableCache* table_cache_;
+  VersionEdit edit_;
+
+  std::vector<std::string> manifests_;
+  std::vector<uint64_t> table_numbers_;
+  std::vector<uint64_t> logs_;
+  std::vector<TableInfo> tables_;
+  uint64_t next_file_number_;
+
+  Status FindFiles() {
+    std::vector<std::string> filenames;
+    Status status = env_->GetChildren(dbname_, &filenames);
+    if (!status.ok()) {
+      return status;
+    }
+    if (filenames.empty()) {
+      return Status::IOError(dbname_, "repair found no files");
+    }
+
+    uint64_t number;
+    FileType type;
+    for (size_t i = 0; i < filenames.size(); i++) {
+      if (ParseFileName(filenames[i], &number, &type)) {
+        if (type == kDescriptorFile) {
+          manifests_.push_back(filenames[i]);
+        } else {
+          if (number + 1 > next_file_number_) {
+            next_file_number_ = number + 1;
+          }
+          if (type == kLogFile) {
+            logs_.push_back(number);
+          } else if (type == kTableFile) {
+            table_numbers_.push_back(number);
+          } else {
+            // Ignore other files
+          }
+        }
+      }
+    }
+    return status;
+  }
+
+  void ConvertLogFilesToTables() {
+    for (size_t i = 0; i < logs_.size(); i++) {
+      std::string logname = LogFileName(dbname_, logs_[i]);
+      Status status = ConvertLogToTable(logs_[i]);
+      if (!status.ok()) {
+        Log(options_.info_log, "Log #%llu: ignoring conversion error: %s",
+            (unsigned long long) logs_[i],
+            status.ToString().c_str());
+      }
+      ArchiveFile(logname);
+    }
+  }
+
+  Status ConvertLogToTable(uint64_t log) {
+    struct LogReporter : public log::Reader::Reporter {
+      Env* env;
+      Logger* info_log;
+      uint64_t lognum;
+      virtual void Corruption(size_t bytes, const Status& s) {
+        // We print error messages for corruption, but continue repairing.
+        Log(info_log, "Log #%llu: dropping %d bytes; %s",
+            (unsigned long long) lognum,
+            static_cast<int>(bytes),
+            s.ToString().c_str());
+      }
+    };
+
+    // Open the log file
+    std::string logname = LogFileName(dbname_, log);
+    SequentialFile* lfile;
+    Status status = env_->NewSequentialFile(logname, &lfile);
+    if (!status.ok()) {
+      return status;
+    }
+
+    // Create the log reader.
+    LogReporter reporter;
+    reporter.env = env_;
+    reporter.info_log = options_.info_log;
+    reporter.lognum = log;
+    // We intentially make log::Reader do checksumming so that
+    // corruptions cause entire commits to be skipped instead of
+    // propagating bad information (like overly large sequence
+    // numbers).
+    log::Reader reader(lfile, &reporter, false/*do not checksum*/,
+                       0/*initial_offset*/);
+
+    // Read all the records and add to a memtable
+    std::string scratch;
+    Slice record;
+    WriteBatch batch;
+    MemTable* mem = new MemTable(icmp_);
+    mem->Ref();
+    int counter = 0;
+    while (reader.ReadRecord(&record, &scratch)) {
+      if (record.size() < 12) {
+        reporter.Corruption(
+            record.size(), Status::Corruption("log record too small"));
+        continue;
+      }
+      WriteBatchInternal::SetContents(&batch, record);
+      status = WriteBatchInternal::InsertInto(&batch, mem);
+      if (status.ok()) {
+        counter += WriteBatchInternal::Count(&batch);
+      } else {
+        Log(options_.info_log, "Log #%llu: ignoring %s",
+            (unsigned long long) log,
+            status.ToString().c_str());
+        status = Status::OK();  // Keep going with rest of file
+      }
+    }
+    delete lfile;
+
+    // Do not record a version edit for this conversion to a Table
+    // since ExtractMetaData() will also generate edits.
+    FileMetaData meta;
+    meta.number = next_file_number_++;
+    Iterator* iter = mem->NewIterator();
+    status = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);
+    delete iter;
+    mem->Unref();
+    mem = NULL;
+    if (status.ok()) {
+      if (meta.file_size > 0) {
+        table_numbers_.push_back(meta.number);
+      }
+    }
+    Log(options_.info_log, "Log #%llu: %d ops saved to Table #%llu %s",
+        (unsigned long long) log,
+        counter,
+        (unsigned long long) meta.number,
+        status.ToString().c_str());
+    return status;
+  }
+
+  void ExtractMetaData() {
+    for (size_t i = 0; i < table_numbers_.size(); i++) {
+      ScanTable(table_numbers_[i]);
+    }
+  }
+
+  Iterator* NewTableIterator(const FileMetaData& meta) {
+    // Same as compaction iterators: if paranoid_checks are on, turn
+    // on checksum verification.
+    ReadOptions r;
+    r.verify_checksums = options_.paranoid_checks;
+    return table_cache_->NewIterator(r, meta.number, meta.file_size);
+  }
+
+  void ScanTable(uint64_t number) {
+    TableInfo t;
+    t.meta.number = number;
+    std::string fname = TableFileName(dbname_, number);
+    Status status = env_->GetFileSize(fname, &t.meta.file_size);
+    if (!status.ok()) {
+      // Try alternate file name.
+      fname = SSTTableFileName(dbname_, number);
+      Status s2 = env_->GetFileSize(fname, &t.meta.file_size);
+      if (s2.ok()) {
+        status = Status::OK();
+      }
+    }
+    if (!status.ok()) {
+      ArchiveFile(TableFileName(dbname_, number));
+      ArchiveFile(SSTTableFileName(dbname_, number));
+      Log(options_.info_log, "Table #%llu: dropped: %s",
+          (unsigned long long) t.meta.number,
+          status.ToString().c_str());
+      return;
+    }
+
+    // Extract metadata by scanning through table.
+    int counter = 0;
+    Iterator* iter = NewTableIterator(t.meta);
+    bool empty = true;
+    ParsedInternalKey parsed;
+    t.max_sequence = 0;
+    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
+      Slice key = iter->key();
+      if (!ParseInternalKey(key, &parsed)) {
+        Log(options_.info_log, "Table #%llu: unparsable key %s",
+            (unsigned long long) t.meta.number,
+            EscapeString(key).c_str());
+        continue;
+      }
+
+      counter++;
+      if (empty) {
+        empty = false;
+        t.meta.smallest.DecodeFrom(key);
+      }
+      t.meta.largest.DecodeFrom(key);
+      if (parsed.sequence > t.max_sequence) {
+        t.max_sequence = parsed.sequence;
+      }
+    }
+    if (!iter->status().ok()) {
+      status = iter->status();
+    }
+    delete iter;
+    Log(options_.info_log, "Table #%llu: %d entries %s",
+        (unsigned long long) t.meta.number,
+        counter,
+        status.ToString().c_str());
+
+    if (status.ok()) {
+      tables_.push_back(t);
+    } else {
+      RepairTable(fname, t);  // RepairTable archives input file.
+    }
+  }
+
+  void RepairTable(const std::string& src, TableInfo t) {
+    // We will copy src contents to a new table and then rename the
+    // new table over the source.
+
+    // Create builder.
+    std::string copy = TableFileName(dbname_, next_file_number_++);
+    WritableFile* file;
+    Status s = env_->NewWritableFile(copy, &file);
+    if (!s.ok()) {
+      return;
+    }
+    TableBuilder* builder = new TableBuilder(options_, file);
+
+    // Copy data.
+    Iterator* iter = NewTableIterator(t.meta);
+    int counter = 0;
+    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
+      builder->Add(iter->key(), iter->value());
+      counter++;
+    }
+    delete iter;
+    table_cache_->Evict(t.meta.number);
+
+    ArchiveFile(src);
+    if (counter == 0) {
+      builder->Abandon();  // Nothing to save
+    } else {
+      s = builder->Finish();
+      if (s.ok()) {
+        t.meta.file_size = builder->FileSize();
+      }
+    }
+    delete builder;
+    builder = NULL;
+
+    if (s.ok()) {
+      s = file->Close();
+    }
+    delete file;
+    file = NULL;
+
+    if (counter > 0 && s.ok()) {
+      std::string orig = TableFileName(dbname_, t.meta.number);
+      s = env_->RenameFile(copy, orig);
+      if (s.ok()) {
+        Log(options_.info_log, "Table #%llu: %d entries repaired",
+            (unsigned long long) t.meta.number, counter);
+        tables_.push_back(t);
+      }
+    }
+    if (!s.ok()) {
+      env_->DeleteFile(copy);
+    }
+  }
+
+  Status WriteDescriptor() {
+    std::string tmp = TempFileName(dbname_, 1);
+    WritableFile* file;
+    Status status = env_->NewWritableFile(tmp, &file);
+    if (!status.ok()) {
+      return status;
+    }
+
+    SequenceNumber max_sequence = 0;
+    for (size_t i = 0; i < tables_.size(); i++) {
+      if (max_sequence < tables_[i].max_sequence) {
+        max_sequence = tables_[i].max_sequence;
+      }
+    }
+
+    edit_.SetComparatorName(icmp_.user_comparator()->Name());
+    edit_.SetLogNumber(0);
+    edit_.SetNextFile(next_file_number_);
+    edit_.SetLastSequence(max_sequence);
+
+    for (size_t i = 0; i < tables_.size(); i++) {
+      // TODO(opt): separate out into multiple levels
+      const TableInfo& t = tables_[i];
+      edit_.AddFile(0, t.meta.number, t.meta.file_size,
+                    t.meta.smallest, t.meta.largest);
+    }
+
+    //fprintf(stderr, "NewDescriptor:\n%s\n", edit_.DebugString().c_str());
+    {
+      log::Writer log(file);
+      std::string record;
+      edit_.EncodeTo(&record);
+      status = log.AddRecord(record);
+    }
+    if (status.ok()) {
+      status = file->Close();
+    }
+    delete file;
+    file = NULL;
+
+    if (!status.ok()) {
+      env_->DeleteFile(tmp);
+    } else {
+      // Discard older manifests
+      for (size_t i = 0; i < manifests_.size(); i++) {
+        ArchiveFile(dbname_ + "/" + manifests_[i]);
+      }
+
+      // Install new manifest
+      status = env_->RenameFile(tmp, DescriptorFileName(dbname_, 1));
+      if (status.ok()) {
+        status = SetCurrentFile(env_, dbname_, 1);
+      } else {
+        env_->DeleteFile(tmp);
+      }
+    }
+    return status;
+  }
+
+  void ArchiveFile(const std::string& fname) {
+    // Move into another directory.  E.g., for
+    //    dir/foo
+    // rename to
+    //    dir/lost/foo
+    const char* slash = strrchr(fname.c_str(), '/');
+    std::string new_dir;
+    if (slash != NULL) {
+      new_dir.assign(fname.data(), slash - fname.data());
+    }
+    new_dir.append("/lost");
+    env_->CreateDir(new_dir);  // Ignore error
+    std::string new_file = new_dir;
+    new_file.append("/");
+    new_file.append((slash == NULL) ? fname.c_str() : slash + 1);
+    Status s = env_->RenameFile(fname, new_file);
+    Log(options_.info_log, "Archiving %s: %s\n",
+        fname.c_str(), s.ToString().c_str());
+  }
+};
+}  // namespace
+
+Status RepairDB(const std::string& dbname, const Options& options) {
+  Repairer repairer(dbname, options);
+  return repairer.Run();
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/skiplist.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/skiplist.h
new file mode 100644
index 0000000..af85be6
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/skiplist.h
@@ -0,0 +1,379 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// Thread safety
+// -------------
+//
+// Writes require external synchronization, most likely a mutex.
+// Reads require a guarantee that the SkipList will not be destroyed
+// while the read is in progress.  Apart from that, reads progress
+// without any internal locking or synchronization.
+//
+// Invariants:
+//
+// (1) Allocated nodes are never deleted until the SkipList is
+// destroyed.  This is trivially guaranteed by the code since we
+// never delete any skip list nodes.
+//
+// (2) The contents of a Node except for the next/prev pointers are
+// immutable after the Node has been linked into the SkipList.
+// Only Insert() modifies the list, and it is careful to initialize
+// a node and use release-stores to publish the nodes in one or
+// more lists.
+//
+// ... prev vs. next pointer ordering ...
+
+#include <assert.h>
+#include <stdlib.h>
+#include "port/port.h"
+#include "util/arena.h"
+#include "util/random.h"
+
+namespace leveldb {
+
+class Arena;
+
+template<typename Key, class Comparator>
+class SkipList {
+ private:
+  struct Node;
+
+ public:
+  // Create a new SkipList object that will use "cmp" for comparing keys,
+  // and will allocate memory using "*arena".  Objects allocated in the arena
+  // must remain allocated for the lifetime of the skiplist object.
+  explicit SkipList(Comparator cmp, Arena* arena);
+
+  // Insert key into the list.
+  // REQUIRES: nothing that compares equal to key is currently in the list.
+  void Insert(const Key& key);
+
+  // Returns true iff an entry that compares equal to key is in the list.
+  bool Contains(const Key& key) const;
+
+  // Iteration over the contents of a skip list
+  class Iterator {
+   public:
+    // Initialize an iterator over the specified list.
+    // The returned iterator is not valid.
+    explicit Iterator(const SkipList* list);
+
+    // Returns true iff the iterator is positioned at a valid node.
+    bool Valid() const;
+
+    // Returns the key at the current position.
+    // REQUIRES: Valid()
+    const Key& key() const;
+
+    // Advances to the next position.
+    // REQUIRES: Valid()
+    void Next();
+
+    // Advances to the previous position.
+    // REQUIRES: Valid()
+    void Prev();
+
+    // Advance to the first entry with a key >= target
+    void Seek(const Key& target);
+
+    // Position at the first entry in list.
+    // Final state of iterator is Valid() iff list is not empty.
+    void SeekToFirst();
+
+    // Position at the last entry in list.
+    // Final state of iterator is Valid() iff list is not empty.
+    void SeekToLast();
+
+   private:
+    const SkipList* list_;
+    Node* node_;
+    // Intentionally copyable
+  };
+
+ private:
+  enum { kMaxHeight = 12 };
+
+  // Immutable after construction
+  Comparator const compare_;
+  Arena* const arena_;    // Arena used for allocations of nodes
+
+  Node* const head_;
+
+  // Modified only by Insert().  Read racily by readers, but stale
+  // values are ok.
+  port::AtomicPointer max_height_;   // Height of the entire list
+
+  inline int GetMaxHeight() const {
+    return static_cast<int>(
+        reinterpret_cast<intptr_t>(max_height_.NoBarrier_Load()));
+  }
+
+  // Read/written only by Insert().
+  Random rnd_;
+
+  Node* NewNode(const Key& key, int height);
+  int RandomHeight();
+  bool Equal(const Key& a, const Key& b) const { return (compare_(a, b) == 0); }
+
+  // Return true if key is greater than the data stored in "n"
+  bool KeyIsAfterNode(const Key& key, Node* n) const;
+
+  // Return the earliest node that comes at or after key.
+  // Return NULL if there is no such node.
+  //
+  // If prev is non-NULL, fills prev[level] with pointer to previous
+  // node at "level" for every level in [0..max_height_-1].
+  Node* FindGreaterOrEqual(const Key& key, Node** prev) const;
+
+  // Return the latest node with a key < key.
+  // Return head_ if there is no such node.
+  Node* FindLessThan(const Key& key) const;
+
+  // Return the last node in the list.
+  // Return head_ if list is empty.
+  Node* FindLast() const;
+
+  // No copying allowed
+  SkipList(const SkipList&);
+  void operator=(const SkipList&);
+};
+
+// Implementation details follow
+template<typename Key, class Comparator>
+struct SkipList<Key,Comparator>::Node {
+  explicit Node(const Key& k) : key(k) { }
+
+  Key const key;
+
+  // Accessors/mutators for links.  Wrapped in methods so we can
+  // add the appropriate barriers as necessary.
+  Node* Next(int n) {
+    assert(n >= 0);
+    // Use an 'acquire load' so that we observe a fully initialized
+    // version of the returned Node.
+    return reinterpret_cast<Node*>(next_[n].Acquire_Load());
+  }
+  void SetNext(int n, Node* x) {
+    assert(n >= 0);
+    // Use a 'release store' so that anybody who reads through this
+    // pointer observes a fully initialized version of the inserted node.
+    next_[n].Release_Store(x);
+  }
+
+  // No-barrier variants that can be safely used in a few locations.
+  Node* NoBarrier_Next(int n) {
+    assert(n >= 0);
+    return reinterpret_cast<Node*>(next_[n].NoBarrier_Load());
+  }
+  void NoBarrier_SetNext(int n, Node* x) {
+    assert(n >= 0);
+    next_[n].NoBarrier_Store(x);
+  }
+
+ private:
+  // Array of length equal to the node height.  next_[0] is lowest level link.
+  port::AtomicPointer next_[1];
+};
+
+template<typename Key, class Comparator>
+typename SkipList<Key,Comparator>::Node*
+SkipList<Key,Comparator>::NewNode(const Key& key, int height) {
+  char* mem = arena_->AllocateAligned(
+      sizeof(Node) + sizeof(port::AtomicPointer) * (height - 1));
+  return new (mem) Node(key);
+}
+
+template<typename Key, class Comparator>
+inline SkipList<Key,Comparator>::Iterator::Iterator(const SkipList* list) {
+  list_ = list;
+  node_ = NULL;
+}
+
+template<typename Key, class Comparator>
+inline bool SkipList<Key,Comparator>::Iterator::Valid() const {
+  return node_ != NULL;
+}
+
+template<typename Key, class Comparator>
+inline const Key& SkipList<Key,Comparator>::Iterator::key() const {
+  assert(Valid());
+  return node_->key;
+}
+
+template<typename Key, class Comparator>
+inline void SkipList<Key,Comparator>::Iterator::Next() {
+  assert(Valid());
+  node_ = node_->Next(0);
+}
+
+template<typename Key, class Comparator>
+inline void SkipList<Key,Comparator>::Iterator::Prev() {
+  // Instead of using explicit "prev" links, we just search for the
+  // last node that falls before key.
+  assert(Valid());
+  node_ = list_->FindLessThan(node_->key);
+  if (node_ == list_->head_) {
+    node_ = NULL;
+  }
+}
+
+template<typename Key, class Comparator>
+inline void SkipList<Key,Comparator>::Iterator::Seek(const Key& target) {
+  node_ = list_->FindGreaterOrEqual(target, NULL);
+}
+
+template<typename Key, class Comparator>
+inline void SkipList<Key,Comparator>::Iterator::SeekToFirst() {
+  node_ = list_->head_->Next(0);
+}
+
+template<typename Key, class Comparator>
+inline void SkipList<Key,Comparator>::Iterator::SeekToLast() {
+  node_ = list_->FindLast();
+  if (node_ == list_->head_) {
+    node_ = NULL;
+  }
+}
+
+template<typename Key, class Comparator>
+int SkipList<Key,Comparator>::RandomHeight() {
+  // Increase height with probability 1 in kBranching
+  static const unsigned int kBranching = 4;
+  int height = 1;
+  while (height < kMaxHeight && ((rnd_.Next() % kBranching) == 0)) {
+    height++;
+  }
+  assert(height > 0);
+  assert(height <= kMaxHeight);
+  return height;
+}
+
+template<typename Key, class Comparator>
+bool SkipList<Key,Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {
+  // NULL n is considered infinite
+  return (n != NULL) && (compare_(n->key, key) < 0);
+}
+
+template<typename Key, class Comparator>
+typename SkipList<Key,Comparator>::Node* SkipList<Key,Comparator>::FindGreaterOrEqual(const Key& key, Node** prev)
+    const {
+  Node* x = head_;
+  int level = GetMaxHeight() - 1;
+  while (true) {
+    Node* next = x->Next(level);
+    if (KeyIsAfterNode(key, next)) {
+      // Keep searching in this list
+      x = next;
+    } else {
+      if (prev != NULL) prev[level] = x;
+      if (level == 0) {
+        return next;
+      } else {
+        // Switch to next list
+        level--;
+      }
+    }
+  }
+}
+
+template<typename Key, class Comparator>
+typename SkipList<Key,Comparator>::Node*
+SkipList<Key,Comparator>::FindLessThan(const Key& key) const {
+  Node* x = head_;
+  int level = GetMaxHeight() - 1;
+  while (true) {
+    assert(x == head_ || compare_(x->key, key) < 0);
+    Node* next = x->Next(level);
+    if (next == NULL || compare_(next->key, key) >= 0) {
+      if (level == 0) {
+        return x;
+      } else {
+        // Switch to next list
+        level--;
+      }
+    } else {
+      x = next;
+    }
+  }
+}
+
+template<typename Key, class Comparator>
+typename SkipList<Key,Comparator>::Node* SkipList<Key,Comparator>::FindLast()
+    const {
+  Node* x = head_;
+  int level = GetMaxHeight() - 1;
+  while (true) {
+    Node* next = x->Next(level);
+    if (next == NULL) {
+      if (level == 0) {
+        return x;
+      } else {
+        // Switch to next list
+        level--;
+      }
+    } else {
+      x = next;
+    }
+  }
+}
+
+template<typename Key, class Comparator>
+SkipList<Key,Comparator>::SkipList(Comparator cmp, Arena* arena)
+    : compare_(cmp),
+      arena_(arena),
+      head_(NewNode(0 /* any key will do */, kMaxHeight)),
+      max_height_(reinterpret_cast<void*>(1)),
+      rnd_(0xdeadbeef) {
+  for (int i = 0; i < kMaxHeight; i++) {
+    head_->SetNext(i, NULL);
+  }
+}
+
+template<typename Key, class Comparator>
+void SkipList<Key,Comparator>::Insert(const Key& key) {
+  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()
+  // here since Insert() is externally synchronized.
+  Node* prev[kMaxHeight];
+  Node* x = FindGreaterOrEqual(key, prev);
+
+  // Our data structure does not allow duplicate insertion
+  assert(x == NULL || !Equal(key, x->key));
+
+  int height = RandomHeight();
+  if (height > GetMaxHeight()) {
+    for (int i = GetMaxHeight(); i < height; i++) {
+      prev[i] = head_;
+    }
+    //fprintf(stderr, "Change height from %d to %d\n", max_height_, height);
+
+    // It is ok to mutate max_height_ without any synchronization
+    // with concurrent readers.  A concurrent reader that observes
+    // the new value of max_height_ will see either the old value of
+    // new level pointers from head_ (NULL), or a new value set in
+    // the loop below.  In the former case the reader will
+    // immediately drop to the next level since NULL sorts after all
+    // keys.  In the latter case the reader will use the new node.
+    max_height_.NoBarrier_Store(reinterpret_cast<void*>(height));
+  }
+
+  x = NewNode(key, height);
+  for (int i = 0; i < height; i++) {
+    // NoBarrier_SetNext() suffices since we will add a barrier when
+    // we publish a pointer to "x" in prev[i].
+    x->NoBarrier_SetNext(i, prev[i]->NoBarrier_Next(i));
+    prev[i]->SetNext(i, x);
+  }
+}
+
+template<typename Key, class Comparator>
+bool SkipList<Key,Comparator>::Contains(const Key& key) const {
+  Node* x = FindGreaterOrEqual(key, NULL);
+  if (x != NULL && Equal(key, x->key)) {
+    return true;
+  } else {
+    return false;
+  }
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/snapshot.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/snapshot.h
new file mode 100644
index 0000000..e7f8fd2
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/snapshot.h
@@ -0,0 +1,66 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_DB_SNAPSHOT_H_
+#define STORAGE_LEVELDB_DB_SNAPSHOT_H_
+
+#include "leveldb/db.h"
+
+namespace leveldb {
+
+class SnapshotList;
+
+// Snapshots are kept in a doubly-linked list in the DB.
+// Each SnapshotImpl corresponds to a particular sequence number.
+class SnapshotImpl : public Snapshot {
+ public:
+  SequenceNumber number_;  // const after creation
+
+ private:
+  friend class SnapshotList;
+
+  // SnapshotImpl is kept in a doubly-linked circular list
+  SnapshotImpl* prev_;
+  SnapshotImpl* next_;
+
+  SnapshotList* list_;                 // just for sanity checks
+};
+
+class SnapshotList {
+ public:
+  SnapshotList() {
+    list_.prev_ = &list_;
+    list_.next_ = &list_;
+  }
+
+  bool empty() const { return list_.next_ == &list_; }
+  SnapshotImpl* oldest() const { assert(!empty()); return list_.next_; }
+  SnapshotImpl* newest() const { assert(!empty()); return list_.prev_; }
+
+  const SnapshotImpl* New(SequenceNumber seq) {
+    SnapshotImpl* s = new SnapshotImpl;
+    s->number_ = seq;
+    s->list_ = this;
+    s->next_ = &list_;
+    s->prev_ = list_.prev_;
+    s->prev_->next_ = s;
+    s->next_->prev_ = s;
+    return s;
+  }
+
+  void Delete(const SnapshotImpl* s) {
+    assert(s->list_ == this);
+    s->prev_->next_ = s->next_;
+    s->next_->prev_ = s->prev_;
+    delete s;
+  }
+
+ private:
+  // Dummy head of doubly-linked list of snapshots
+  SnapshotImpl list_;
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_SNAPSHOT_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/table_cache.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/table_cache.cc
new file mode 100644
index 0000000..e3d82cd
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/table_cache.cc
@@ -0,0 +1,127 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "db/table_cache.h"
+
+#include "db/filename.h"
+#include "leveldb/env.h"
+#include "leveldb/table.h"
+#include "util/coding.h"
+
+namespace leveldb {
+
+struct TableAndFile {
+  RandomAccessFile* file;
+  Table* table;
+};
+
+static void DeleteEntry(const Slice& key, void* value) {
+  TableAndFile* tf = reinterpret_cast<TableAndFile*>(value);
+  delete tf->table;
+  delete tf->file;
+  delete tf;
+}
+
+static void UnrefEntry(void* arg1, void* arg2) {
+  Cache* cache = reinterpret_cast<Cache*>(arg1);
+  Cache::Handle* h = reinterpret_cast<Cache::Handle*>(arg2);
+  cache->Release(h);
+}
+
+TableCache::TableCache(const std::string& dbname,
+                       const Options* options,
+                       int entries)
+    : env_(options->env),
+      dbname_(dbname),
+      options_(options),
+      cache_(NewLRUCache(entries)) {
+}
+
+TableCache::~TableCache() {
+  delete cache_;
+}
+
+Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,
+                             Cache::Handle** handle) {
+  Status s;
+  char buf[sizeof(file_number)];
+  EncodeFixed64(buf, file_number);
+  Slice key(buf, sizeof(buf));
+  *handle = cache_->Lookup(key);
+  if (*handle == NULL) {
+    std::string fname = TableFileName(dbname_, file_number);
+    RandomAccessFile* file = NULL;
+    Table* table = NULL;
+    s = env_->NewRandomAccessFile(fname, &file);
+    if (!s.ok()) {
+      std::string old_fname = SSTTableFileName(dbname_, file_number);
+      if (env_->NewRandomAccessFile(old_fname, &file).ok()) {
+        s = Status::OK();
+      }
+    }
+    if (s.ok()) {
+      s = Table::Open(*options_, file, file_size, &table);
+    }
+
+    if (!s.ok()) {
+      assert(table == NULL);
+      delete file;
+      // We do not cache error results so that if the error is transient,
+      // or somebody repairs the file, we recover automatically.
+    } else {
+      TableAndFile* tf = new TableAndFile;
+      tf->file = file;
+      tf->table = table;
+      *handle = cache_->Insert(key, tf, 1, &DeleteEntry);
+    }
+  }
+  return s;
+}
+
+Iterator* TableCache::NewIterator(const ReadOptions& options,
+                                  uint64_t file_number,
+                                  uint64_t file_size,
+                                  Table** tableptr) {
+  if (tableptr != NULL) {
+    *tableptr = NULL;
+  }
+
+  Cache::Handle* handle = NULL;
+  Status s = FindTable(file_number, file_size, &handle);
+  if (!s.ok()) {
+    return NewErrorIterator(s);
+  }
+
+  Table* table = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
+  Iterator* result = table->NewIterator(options);
+  result->RegisterCleanup(&UnrefEntry, cache_, handle);
+  if (tableptr != NULL) {
+    *tableptr = table;
+  }
+  return result;
+}
+
+Status TableCache::Get(const ReadOptions& options,
+                       uint64_t file_number,
+                       uint64_t file_size,
+                       const Slice& k,
+                       void* arg,
+                       void (*saver)(void*, const Slice&, const Slice&)) {
+  Cache::Handle* handle = NULL;
+  Status s = FindTable(file_number, file_size, &handle);
+  if (s.ok()) {
+    Table* t = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
+    s = t->InternalGet(options, k, arg, saver);
+    cache_->Release(handle);
+  }
+  return s;
+}
+
+void TableCache::Evict(uint64_t file_number) {
+  char buf[sizeof(file_number)];
+  EncodeFixed64(buf, file_number);
+  cache_->Erase(Slice(buf, sizeof(buf)));
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/table_cache.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/table_cache.h
new file mode 100644
index 0000000..8cf4aaf
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/table_cache.h
@@ -0,0 +1,61 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// Thread-safe (provides internal synchronization)
+
+#ifndef STORAGE_LEVELDB_DB_TABLE_CACHE_H_
+#define STORAGE_LEVELDB_DB_TABLE_CACHE_H_
+
+#include <string>
+#include <stdint.h>
+#include "db/dbformat.h"
+#include "leveldb/cache.h"
+#include "leveldb/table.h"
+#include "port/port.h"
+
+namespace leveldb {
+
+class Env;
+
+class TableCache {
+ public:
+  TableCache(const std::string& dbname, const Options* options, int entries);
+  ~TableCache();
+
+  // Return an iterator for the specified file number (the corresponding
+  // file length must be exactly "file_size" bytes).  If "tableptr" is
+  // non-NULL, also sets "*tableptr" to point to the Table object
+  // underlying the returned iterator, or NULL if no Table object underlies
+  // the returned iterator.  The returned "*tableptr" object is owned by
+  // the cache and should not be deleted, and is valid for as long as the
+  // returned iterator is live.
+  Iterator* NewIterator(const ReadOptions& options,
+                        uint64_t file_number,
+                        uint64_t file_size,
+                        Table** tableptr = NULL);
+
+  // If a seek to internal key "k" in specified file finds an entry,
+  // call (*handle_result)(arg, found_key, found_value).
+  Status Get(const ReadOptions& options,
+             uint64_t file_number,
+             uint64_t file_size,
+             const Slice& k,
+             void* arg,
+             void (*handle_result)(void*, const Slice&, const Slice&));
+
+  // Evict any entry for the specified file number
+  void Evict(uint64_t file_number);
+
+ private:
+  Env* const env_;
+  const std::string dbname_;
+  const Options* options_;
+  Cache* cache_;
+
+  Status FindTable(uint64_t file_number, uint64_t file_size, Cache::Handle**);
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_TABLE_CACHE_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/version_edit.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/version_edit.cc
new file mode 100644
index 0000000..f10a2d5
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/version_edit.cc
@@ -0,0 +1,266 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "db/version_edit.h"
+
+#include "db/version_set.h"
+#include "util/coding.h"
+
+namespace leveldb {
+
+// Tag numbers for serialized VersionEdit.  These numbers are written to
+// disk and should not be changed.
+enum Tag {
+  kComparator           = 1,
+  kLogNumber            = 2,
+  kNextFileNumber       = 3,
+  kLastSequence         = 4,
+  kCompactPointer       = 5,
+  kDeletedFile          = 6,
+  kNewFile              = 7,
+  // 8 was used for large value refs
+  kPrevLogNumber        = 9
+};
+
+void VersionEdit::Clear() {
+  comparator_.clear();
+  log_number_ = 0;
+  prev_log_number_ = 0;
+  last_sequence_ = 0;
+  next_file_number_ = 0;
+  has_comparator_ = false;
+  has_log_number_ = false;
+  has_prev_log_number_ = false;
+  has_next_file_number_ = false;
+  has_last_sequence_ = false;
+  deleted_files_.clear();
+  new_files_.clear();
+}
+
+void VersionEdit::EncodeTo(std::string* dst) const {
+  if (has_comparator_) {
+    PutVarint32(dst, kComparator);
+    PutLengthPrefixedSlice(dst, comparator_);
+  }
+  if (has_log_number_) {
+    PutVarint32(dst, kLogNumber);
+    PutVarint64(dst, log_number_);
+  }
+  if (has_prev_log_number_) {
+    PutVarint32(dst, kPrevLogNumber);
+    PutVarint64(dst, prev_log_number_);
+  }
+  if (has_next_file_number_) {
+    PutVarint32(dst, kNextFileNumber);
+    PutVarint64(dst, next_file_number_);
+  }
+  if (has_last_sequence_) {
+    PutVarint32(dst, kLastSequence);
+    PutVarint64(dst, last_sequence_);
+  }
+
+  for (size_t i = 0; i < compact_pointers_.size(); i++) {
+    PutVarint32(dst, kCompactPointer);
+    PutVarint32(dst, compact_pointers_[i].first);  // level
+    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());
+  }
+
+  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();
+       iter != deleted_files_.end();
+       ++iter) {
+    PutVarint32(dst, kDeletedFile);
+    PutVarint32(dst, iter->first);   // level
+    PutVarint64(dst, iter->second);  // file number
+  }
+
+  for (size_t i = 0; i < new_files_.size(); i++) {
+    const FileMetaData& f = new_files_[i].second;
+    PutVarint32(dst, kNewFile);
+    PutVarint32(dst, new_files_[i].first);  // level
+    PutVarint64(dst, f.number);
+    PutVarint64(dst, f.file_size);
+    PutLengthPrefixedSlice(dst, f.smallest.Encode());
+    PutLengthPrefixedSlice(dst, f.largest.Encode());
+  }
+}
+
+static bool GetInternalKey(Slice* input, InternalKey* dst) {
+  Slice str;
+  if (GetLengthPrefixedSlice(input, &str)) {
+    dst->DecodeFrom(str);
+    return true;
+  } else {
+    return false;
+  }
+}
+
+static bool GetLevel(Slice* input, int* level) {
+  uint32_t v;
+  if (GetVarint32(input, &v) &&
+      v < config::kNumLevels) {
+    *level = v;
+    return true;
+  } else {
+    return false;
+  }
+}
+
+Status VersionEdit::DecodeFrom(const Slice& src) {
+  Clear();
+  Slice input = src;
+  const char* msg = NULL;
+  uint32_t tag;
+
+  // Temporary storage for parsing
+  int level;
+  uint64_t number;
+  FileMetaData f;
+  Slice str;
+  InternalKey key;
+
+  while (msg == NULL && GetVarint32(&input, &tag)) {
+    switch (tag) {
+      case kComparator:
+        if (GetLengthPrefixedSlice(&input, &str)) {
+          comparator_ = str.ToString();
+          has_comparator_ = true;
+        } else {
+          msg = "comparator name";
+        }
+        break;
+
+      case kLogNumber:
+        if (GetVarint64(&input, &log_number_)) {
+          has_log_number_ = true;
+        } else {
+          msg = "log number";
+        }
+        break;
+
+      case kPrevLogNumber:
+        if (GetVarint64(&input, &prev_log_number_)) {
+          has_prev_log_number_ = true;
+        } else {
+          msg = "previous log number";
+        }
+        break;
+
+      case kNextFileNumber:
+        if (GetVarint64(&input, &next_file_number_)) {
+          has_next_file_number_ = true;
+        } else {
+          msg = "next file number";
+        }
+        break;
+
+      case kLastSequence:
+        if (GetVarint64(&input, &last_sequence_)) {
+          has_last_sequence_ = true;
+        } else {
+          msg = "last sequence number";
+        }
+        break;
+
+      case kCompactPointer:
+        if (GetLevel(&input, &level) &&
+            GetInternalKey(&input, &key)) {
+          compact_pointers_.push_back(std::make_pair(level, key));
+        } else {
+          msg = "compaction pointer";
+        }
+        break;
+
+      case kDeletedFile:
+        if (GetLevel(&input, &level) &&
+            GetVarint64(&input, &number)) {
+          deleted_files_.insert(std::make_pair(level, number));
+        } else {
+          msg = "deleted file";
+        }
+        break;
+
+      case kNewFile:
+        if (GetLevel(&input, &level) &&
+            GetVarint64(&input, &f.number) &&
+            GetVarint64(&input, &f.file_size) &&
+            GetInternalKey(&input, &f.smallest) &&
+            GetInternalKey(&input, &f.largest)) {
+          new_files_.push_back(std::make_pair(level, f));
+        } else {
+          msg = "new-file entry";
+        }
+        break;
+
+      default:
+        msg = "unknown tag";
+        break;
+    }
+  }
+
+  if (msg == NULL && !input.empty()) {
+    msg = "invalid tag";
+  }
+
+  Status result;
+  if (msg != NULL) {
+    result = Status::Corruption("VersionEdit", msg);
+  }
+  return result;
+}
+
+std::string VersionEdit::DebugString() const {
+  std::string r;
+  r.append("VersionEdit {");
+  if (has_comparator_) {
+    r.append("\n  Comparator: ");
+    r.append(comparator_);
+  }
+  if (has_log_number_) {
+    r.append("\n  LogNumber: ");
+    AppendNumberTo(&r, log_number_);
+  }
+  if (has_prev_log_number_) {
+    r.append("\n  PrevLogNumber: ");
+    AppendNumberTo(&r, prev_log_number_);
+  }
+  if (has_next_file_number_) {
+    r.append("\n  NextFile: ");
+    AppendNumberTo(&r, next_file_number_);
+  }
+  if (has_last_sequence_) {
+    r.append("\n  LastSeq: ");
+    AppendNumberTo(&r, last_sequence_);
+  }
+  for (size_t i = 0; i < compact_pointers_.size(); i++) {
+    r.append("\n  CompactPointer: ");
+    AppendNumberTo(&r, compact_pointers_[i].first);
+    r.append(" ");
+    r.append(compact_pointers_[i].second.DebugString());
+  }
+  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();
+       iter != deleted_files_.end();
+       ++iter) {
+    r.append("\n  DeleteFile: ");
+    AppendNumberTo(&r, iter->first);
+    r.append(" ");
+    AppendNumberTo(&r, iter->second);
+  }
+  for (size_t i = 0; i < new_files_.size(); i++) {
+    const FileMetaData& f = new_files_[i].second;
+    r.append("\n  AddFile: ");
+    AppendNumberTo(&r, new_files_[i].first);
+    r.append(" ");
+    AppendNumberTo(&r, f.number);
+    r.append(" ");
+    AppendNumberTo(&r, f.file_size);
+    r.append(" ");
+    r.append(f.smallest.DebugString());
+    r.append(" .. ");
+    r.append(f.largest.DebugString());
+  }
+  r.append("\n}\n");
+  return r;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/version_edit.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/version_edit.h
new file mode 100644
index 0000000..eaef77b
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/version_edit.h
@@ -0,0 +1,107 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_DB_VERSION_EDIT_H_
+#define STORAGE_LEVELDB_DB_VERSION_EDIT_H_
+
+#include <set>
+#include <utility>
+#include <vector>
+#include "db/dbformat.h"
+
+namespace leveldb {
+
+class VersionSet;
+
+struct FileMetaData {
+  int refs;
+  int allowed_seeks;          // Seeks allowed until compaction
+  uint64_t number;
+  uint64_t file_size;         // File size in bytes
+  InternalKey smallest;       // Smallest internal key served by table
+  InternalKey largest;        // Largest internal key served by table
+
+  FileMetaData() : refs(0), allowed_seeks(1 << 30), file_size(0) { }
+};
+
+class VersionEdit {
+ public:
+  VersionEdit() { Clear(); }
+  ~VersionEdit() { }
+
+  void Clear();
+
+  void SetComparatorName(const Slice& name) {
+    has_comparator_ = true;
+    comparator_ = name.ToString();
+  }
+  void SetLogNumber(uint64_t num) {
+    has_log_number_ = true;
+    log_number_ = num;
+  }
+  void SetPrevLogNumber(uint64_t num) {
+    has_prev_log_number_ = true;
+    prev_log_number_ = num;
+  }
+  void SetNextFile(uint64_t num) {
+    has_next_file_number_ = true;
+    next_file_number_ = num;
+  }
+  void SetLastSequence(SequenceNumber seq) {
+    has_last_sequence_ = true;
+    last_sequence_ = seq;
+  }
+  void SetCompactPointer(int level, const InternalKey& key) {
+    compact_pointers_.push_back(std::make_pair(level, key));
+  }
+
+  // Add the specified file at the specified number.
+  // REQUIRES: This version has not been saved (see VersionSet::SaveTo)
+  // REQUIRES: "smallest" and "largest" are smallest and largest keys in file
+  void AddFile(int level, uint64_t file,
+               uint64_t file_size,
+               const InternalKey& smallest,
+               const InternalKey& largest) {
+    FileMetaData f;
+    f.number = file;
+    f.file_size = file_size;
+    f.smallest = smallest;
+    f.largest = largest;
+    new_files_.push_back(std::make_pair(level, f));
+  }
+
+  // Delete the specified "file" from the specified "level".
+  void DeleteFile(int level, uint64_t file) {
+    deleted_files_.insert(std::make_pair(level, file));
+  }
+
+  void EncodeTo(std::string* dst) const;
+  Status DecodeFrom(const Slice& src);
+
+  std::string DebugString() const;
+
+ private:
+  friend class VersionSet;
+
+  typedef std::set< std::pair<int, uint64_t> > DeletedFileSet;
+
+  std::string comparator_;
+  uint64_t log_number_;
+  uint64_t prev_log_number_;
+  uint64_t next_file_number_;
+  SequenceNumber last_sequence_;
+  bool has_comparator_;
+  bool has_log_number_;
+  bool has_prev_log_number_;
+  bool has_next_file_number_;
+  bool has_last_sequence_;
+
+  std::vector< std::pair<int, InternalKey> > compact_pointers_;
+  DeletedFileSet deleted_files_;
+  std::vector< std::pair<int, FileMetaData> > new_files_;
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_VERSION_EDIT_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/version_set.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/version_set.cc
new file mode 100644
index 0000000..517edd3
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/version_set.cc
@@ -0,0 +1,1498 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "db/version_set.h"
+
+#include <algorithm>
+#include <stdio.h>
+#include "db/filename.h"
+#include "db/log_reader.h"
+#include "db/log_writer.h"
+#include "db/memtable.h"
+#include "db/table_cache.h"
+#include "leveldb/env.h"
+#include "leveldb/table_builder.h"
+#include "table/merger.h"
+#include "table/two_level_iterator.h"
+#include "util/coding.h"
+#include "util/logging.h"
+
+namespace leveldb {
+
+static const int kTargetFileSize = 2 * 1048576;
+
+// Maximum bytes of overlaps in grandparent (i.e., level+2) before we
+// stop building a single file in a level->level+1 compaction.
+static const int64_t kMaxGrandParentOverlapBytes = 10 * kTargetFileSize;
+
+// Maximum number of bytes in all compacted files.  We avoid expanding
+// the lower level file set of a compaction if it would make the
+// total compaction cover more than this many bytes.
+static const int64_t kExpandedCompactionByteSizeLimit = 25 * kTargetFileSize;
+
+static double MaxBytesForLevel(int level) {
+  // Note: the result for level zero is not really used since we set
+  // the level-0 compaction threshold based on number of files.
+  double result = 10 * 1048576.0;  // Result for both level-0 and level-1
+  while (level > 1) {
+    result *= 10;
+    level--;
+  }
+  return result;
+}
+
+static uint64_t MaxFileSizeForLevel(int level) {
+  return kTargetFileSize;  // We could vary per level to reduce number of files?
+}
+
+static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {
+  int64_t sum = 0;
+  for (size_t i = 0; i < files.size(); i++) {
+    sum += files[i]->file_size;
+  }
+  return sum;
+}
+
+namespace {
+std::string IntSetToString(const std::set<uint64_t>& s) {
+  std::string result = "{";
+  for (std::set<uint64_t>::const_iterator it = s.begin();
+       it != s.end();
+       ++it) {
+    result += (result.size() > 1) ? "," : "";
+    result += NumberToString(*it);
+  }
+  result += "}";
+  return result;
+}
+}  // namespace
+
+Version::~Version() {
+  assert(refs_ == 0);
+
+  // Remove from linked list
+  prev_->next_ = next_;
+  next_->prev_ = prev_;
+
+  // Drop references to files
+  for (int level = 0; level < config::kNumLevels; level++) {
+    for (size_t i = 0; i < files_[level].size(); i++) {
+      FileMetaData* f = files_[level][i];
+      assert(f->refs > 0);
+      f->refs--;
+      if (f->refs <= 0) {
+        delete f;
+      }
+    }
+  }
+}
+
+int FindFile(const InternalKeyComparator& icmp,
+             const std::vector<FileMetaData*>& files,
+             const Slice& key) {
+  uint32_t left = 0;
+  uint32_t right = files.size();
+  while (left < right) {
+    uint32_t mid = (left + right) / 2;
+    const FileMetaData* f = files[mid];
+    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {
+      // Key at "mid.largest" is < "target".  Therefore all
+      // files at or before "mid" are uninteresting.
+      left = mid + 1;
+    } else {
+      // Key at "mid.largest" is >= "target".  Therefore all files
+      // after "mid" are uninteresting.
+      right = mid;
+    }
+  }
+  return right;
+}
+
+static bool AfterFile(const Comparator* ucmp,
+                      const Slice* user_key, const FileMetaData* f) {
+  // NULL user_key occurs before all keys and is therefore never after *f
+  return (user_key != NULL &&
+          ucmp->Compare(*user_key, f->largest.user_key()) > 0);
+}
+
+static bool BeforeFile(const Comparator* ucmp,
+                       const Slice* user_key, const FileMetaData* f) {
+  // NULL user_key occurs after all keys and is therefore never before *f
+  return (user_key != NULL &&
+          ucmp->Compare(*user_key, f->smallest.user_key()) < 0);
+}
+
+bool SomeFileOverlapsRange(
+    const InternalKeyComparator& icmp,
+    bool disjoint_sorted_files,
+    const std::vector<FileMetaData*>& files,
+    const Slice* smallest_user_key,
+    const Slice* largest_user_key) {
+  const Comparator* ucmp = icmp.user_comparator();
+  if (!disjoint_sorted_files) {
+    // Need to check against all files
+    for (size_t i = 0; i < files.size(); i++) {
+      const FileMetaData* f = files[i];
+      if (AfterFile(ucmp, smallest_user_key, f) ||
+          BeforeFile(ucmp, largest_user_key, f)) {
+        // No overlap
+      } else {
+        return true;  // Overlap
+      }
+    }
+    return false;
+  }
+
+  // Binary search over file list
+  uint32_t index = 0;
+  if (smallest_user_key != NULL) {
+    // Find the earliest possible internal key for smallest_user_key
+    InternalKey small(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);
+    index = FindFile(icmp, files, small.Encode());
+  }
+
+  if (index >= files.size()) {
+    // beginning of range is after all files, so no overlap.
+    return false;
+  }
+
+  return !BeforeFile(ucmp, largest_user_key, files[index]);
+}
+
+// An internal iterator.  For a given version/level pair, yields
+// information about the files in the level.  For a given entry, key()
+// is the largest key that occurs in the file, and value() is an
+// 16-byte value containing the file number and file size, both
+// encoded using EncodeFixed64.
+class Version::LevelFileNumIterator : public Iterator {
+ public:
+  LevelFileNumIterator(const InternalKeyComparator& icmp,
+                       const std::vector<FileMetaData*>* flist)
+      : icmp_(icmp),
+        flist_(flist),
+        index_(flist->size()) {        // Marks as invalid
+  }
+  virtual bool Valid() const {
+    return index_ < flist_->size();
+  }
+  virtual void Seek(const Slice& target) {
+    index_ = FindFile(icmp_, *flist_, target);
+  }
+  virtual void SeekToFirst() { index_ = 0; }
+  virtual void SeekToLast() {
+    index_ = flist_->empty() ? 0 : flist_->size() - 1;
+  }
+  virtual void Next() {
+    assert(Valid());
+    index_++;
+  }
+  virtual void Prev() {
+    assert(Valid());
+    if (index_ == 0) {
+      index_ = flist_->size();  // Marks as invalid
+    } else {
+      index_--;
+    }
+  }
+  Slice key() const {
+    assert(Valid());
+    return (*flist_)[index_]->largest.Encode();
+  }
+  Slice value() const {
+    assert(Valid());
+    EncodeFixed64(value_buf_, (*flist_)[index_]->number);
+    EncodeFixed64(value_buf_+8, (*flist_)[index_]->file_size);
+    return Slice(value_buf_, sizeof(value_buf_));
+  }
+  virtual Status status() const { return Status::OK(); }
+ private:
+  const InternalKeyComparator icmp_;
+  const std::vector<FileMetaData*>* const flist_;
+  uint32_t index_;
+
+  // Backing store for value().  Holds the file number and size.
+  mutable char value_buf_[16];
+};
+
+static Iterator* GetFileIterator(void* arg,
+                                 const ReadOptions& options,
+                                 const Slice& file_value) {
+  TableCache* cache = reinterpret_cast<TableCache*>(arg);
+  if (file_value.size() != 16) {
+    return NewErrorIterator(
+        Status::Corruption("FileReader invoked with unexpected value"));
+  } else {
+    return cache->NewIterator(options,
+                              DecodeFixed64(file_value.data()),
+                              DecodeFixed64(file_value.data() + 8));
+  }
+}
+
+Iterator* Version::NewConcatenatingIterator(const ReadOptions& options,
+                                            int level) const {
+  return NewTwoLevelIterator(
+      new LevelFileNumIterator(vset_->icmp_, &files_[level]),
+      &GetFileIterator, vset_->table_cache_, options);
+}
+
+void Version::AddIterators(const ReadOptions& options,
+                           std::vector<Iterator*>* iters) {
+  // Merge all level zero files together since they may overlap
+  for (size_t i = 0; i < files_[0].size(); i++) {
+    iters->push_back(
+        vset_->table_cache_->NewIterator(
+            options, files_[0][i]->number, files_[0][i]->file_size));
+  }
+
+  // For levels > 0, we can use a concatenating iterator that sequentially
+  // walks through the non-overlapping files in the level, opening them
+  // lazily.
+  for (int level = 1; level < config::kNumLevels; level++) {
+    if (!files_[level].empty()) {
+      iters->push_back(NewConcatenatingIterator(options, level));
+    }
+  }
+}
+
+// Callback from TableCache::Get()
+namespace {
+enum SaverState {
+  kNotFound,
+  kFound,
+  kDeleted,
+  kCorrupt,
+};
+struct Saver {
+  SaverState state;
+  const Comparator* ucmp;
+  Slice user_key;
+  std::string* value;
+};
+}
+static void SaveValue(void* arg, const Slice& ikey, const Slice& v) {
+  Saver* s = reinterpret_cast<Saver*>(arg);
+  ParsedInternalKey parsed_key;
+  if (!ParseInternalKey(ikey, &parsed_key)) {
+    s->state = kCorrupt;
+  } else {
+    if (s->ucmp->Compare(parsed_key.user_key, s->user_key) == 0) {
+      s->state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;
+      if (s->state == kFound) {
+        s->value->assign(v.data(), v.size());
+      }
+    }
+  }
+}
+
+static bool NewestFirst(FileMetaData* a, FileMetaData* b) {
+  return a->number > b->number;
+}
+
+void Version::ForEachOverlapping(Slice user_key, Slice internal_key,
+                                 void* arg,
+                                 bool (*func)(void*, int, FileMetaData*)) {
+  // TODO(sanjay): Change Version::Get() to use this function.
+  const Comparator* ucmp = vset_->icmp_.user_comparator();
+
+  // Search level-0 in order from newest to oldest.
+  std::vector<FileMetaData*> tmp;
+  tmp.reserve(files_[0].size());
+  for (uint32_t i = 0; i < files_[0].size(); i++) {
+    FileMetaData* f = files_[0][i];
+    if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&
+        ucmp->Compare(user_key, f->largest.user_key()) <= 0) {
+      tmp.push_back(f);
+    }
+  }
+  if (!tmp.empty()) {
+    std::sort(tmp.begin(), tmp.end(), NewestFirst);
+    for (uint32_t i = 0; i < tmp.size(); i++) {
+      if (!(*func)(arg, 0, tmp[i])) {
+        return;
+      }
+    }
+  }
+
+  // Search other levels.
+  for (int level = 1; level < config::kNumLevels; level++) {
+    size_t num_files = files_[level].size();
+    if (num_files == 0) continue;
+
+    // Binary search to find earliest index whose largest key >= internal_key.
+    uint32_t index = FindFile(vset_->icmp_, files_[level], internal_key);
+    if (index < num_files) {
+      FileMetaData* f = files_[level][index];
+      if (ucmp->Compare(user_key, f->smallest.user_key()) < 0) {
+        // All of "f" is past any data for user_key
+      } else {
+        if (!(*func)(arg, level, f)) {
+          return;
+        }
+      }
+    }
+  }
+}
+
+Status Version::Get(const ReadOptions& options,
+                    const LookupKey& k,
+                    std::string* value,
+                    GetStats* stats) {
+  Slice ikey = k.internal_key();
+  Slice user_key = k.user_key();
+  const Comparator* ucmp = vset_->icmp_.user_comparator();
+  Status s;
+
+  stats->seek_file = NULL;
+  stats->seek_file_level = -1;
+  FileMetaData* last_file_read = NULL;
+  int last_file_read_level = -1;
+
+  // We can search level-by-level since entries never hop across
+  // levels.  Therefore we are guaranteed that if we find data
+  // in an smaller level, later levels are irrelevant.
+  std::vector<FileMetaData*> tmp;
+  FileMetaData* tmp2;
+  for (int level = 0; level < config::kNumLevels; level++) {
+    size_t num_files = files_[level].size();
+    if (num_files == 0) continue;
+
+    // Get the list of files to search in this level
+    FileMetaData* const* files = &files_[level][0];
+    if (level == 0) {
+      // Level-0 files may overlap each other.  Find all files that
+      // overlap user_key and process them in order from newest to oldest.
+      tmp.reserve(num_files);
+      for (uint32_t i = 0; i < num_files; i++) {
+        FileMetaData* f = files[i];
+        if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&
+            ucmp->Compare(user_key, f->largest.user_key()) <= 0) {
+          tmp.push_back(f);
+        }
+      }
+      if (tmp.empty()) continue;
+
+      std::sort(tmp.begin(), tmp.end(), NewestFirst);
+      files = &tmp[0];
+      num_files = tmp.size();
+    } else {
+      // Binary search to find earliest index whose largest key >= ikey.
+      uint32_t index = FindFile(vset_->icmp_, files_[level], ikey);
+      if (index >= num_files) {
+        files = NULL;
+        num_files = 0;
+      } else {
+        tmp2 = files[index];
+        if (ucmp->Compare(user_key, tmp2->smallest.user_key()) < 0) {
+          // All of "tmp2" is past any data for user_key
+          files = NULL;
+          num_files = 0;
+        } else {
+          files = &tmp2;
+          num_files = 1;
+        }
+      }
+    }
+
+    for (uint32_t i = 0; i < num_files; ++i) {
+      if (last_file_read != NULL && stats->seek_file == NULL) {
+        // We have had more than one seek for this read.  Charge the 1st file.
+        stats->seek_file = last_file_read;
+        stats->seek_file_level = last_file_read_level;
+      }
+
+      FileMetaData* f = files[i];
+      last_file_read = f;
+      last_file_read_level = level;
+
+      Saver saver;
+      saver.state = kNotFound;
+      saver.ucmp = ucmp;
+      saver.user_key = user_key;
+      saver.value = value;
+      s = vset_->table_cache_->Get(options, f->number, f->file_size,
+                                   ikey, &saver, SaveValue);
+      if (!s.ok()) {
+        return s;
+      }
+      switch (saver.state) {
+        case kNotFound:
+          break;      // Keep searching in other files
+        case kFound:
+          return s;
+        case kDeleted:
+          s = Status::NotFound(Slice());  // Use empty error message for speed
+          return s;
+        case kCorrupt:
+          s = Status::Corruption("corrupted key for ", user_key);
+          return s;
+      }
+    }
+  }
+
+  return Status::NotFound(Slice());  // Use an empty error message for speed
+}
+
+bool Version::UpdateStats(const GetStats& stats) {
+  FileMetaData* f = stats.seek_file;
+  if (f != NULL) {
+    f->allowed_seeks--;
+    if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {
+      file_to_compact_ = f;
+      file_to_compact_level_ = stats.seek_file_level;
+      return true;
+    }
+  }
+  return false;
+}
+
+bool Version::RecordReadSample(Slice internal_key) {
+  ParsedInternalKey ikey;
+  if (!ParseInternalKey(internal_key, &ikey)) {
+    return false;
+  }
+
+  struct State {
+    GetStats stats;  // Holds first matching file
+    int matches;
+
+    static bool Match(void* arg, int level, FileMetaData* f) {
+      State* state = reinterpret_cast<State*>(arg);
+      state->matches++;
+      if (state->matches == 1) {
+        // Remember first match.
+        state->stats.seek_file = f;
+        state->stats.seek_file_level = level;
+      }
+      // We can stop iterating once we have a second match.
+      return state->matches < 2;
+    }
+  };
+
+  State state;
+  state.matches = 0;
+  ForEachOverlapping(ikey.user_key, internal_key, &state, &State::Match);
+
+  // Must have at least two matches since we want to merge across
+  // files. But what if we have a single file that contains many
+  // overwrites and deletions?  Should we have another mechanism for
+  // finding such files?
+  if (state.matches >= 2) {
+    // 1MB cost is about 1 seek (see comment in Builder::Apply).
+    return UpdateStats(state.stats);
+  }
+  return false;
+}
+
+void Version::Ref() {
+  ++refs_;
+}
+
+void Version::Unref() {
+  assert(this != &vset_->dummy_versions_);
+  assert(refs_ >= 1);
+  --refs_;
+  if (refs_ == 0) {
+    delete this;
+  }
+}
+
+bool Version::OverlapInLevel(int level,
+                             const Slice* smallest_user_key,
+                             const Slice* largest_user_key) {
+  return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],
+                               smallest_user_key, largest_user_key);
+}
+
+int Version::PickLevelForMemTableOutput(
+    const Slice& smallest_user_key,
+    const Slice& largest_user_key) {
+  int level = 0;
+  if (!OverlapInLevel(0, &smallest_user_key, &largest_user_key)) {
+    // Push to next level if there is no overlap in next level,
+    // and the #bytes overlapping in the level after that are limited.
+    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);
+    InternalKey limit(largest_user_key, 0, static_cast<ValueType>(0));
+    std::vector<FileMetaData*> overlaps;
+    while (level < config::kMaxMemCompactLevel) {
+      if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {
+        break;
+      }
+      if (level + 2 < config::kNumLevels) {
+        // Check that file does not overlap too many grandparent bytes.
+        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);
+        const int64_t sum = TotalFileSize(overlaps);
+        if (sum > kMaxGrandParentOverlapBytes) {
+          break;
+        }
+      }
+      level++;
+    }
+  }
+  return level;
+}
+
+// Store in "*inputs" all files in "level" that overlap [begin,end]
+void Version::GetOverlappingInputs(
+    int level,
+    const InternalKey* begin,
+    const InternalKey* end,
+    std::vector<FileMetaData*>* inputs) {
+  assert(level >= 0);
+  assert(level < config::kNumLevels);
+  inputs->clear();
+  Slice user_begin, user_end;
+  if (begin != NULL) {
+    user_begin = begin->user_key();
+  }
+  if (end != NULL) {
+    user_end = end->user_key();
+  }
+  const Comparator* user_cmp = vset_->icmp_.user_comparator();
+  for (size_t i = 0; i < files_[level].size(); ) {
+    FileMetaData* f = files_[level][i++];
+    const Slice file_start = f->smallest.user_key();
+    const Slice file_limit = f->largest.user_key();
+    if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {
+      // "f" is completely before specified range; skip it
+    } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {
+      // "f" is completely after specified range; skip it
+    } else {
+      inputs->push_back(f);
+      if (level == 0) {
+        // Level-0 files may overlap each other.  So check if the newly
+        // added file has expanded the range.  If so, restart search.
+        if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {
+          user_begin = file_start;
+          inputs->clear();
+          i = 0;
+        } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {
+          user_end = file_limit;
+          inputs->clear();
+          i = 0;
+        }
+      }
+    }
+  }
+}
+
+std::string Version::DebugString() const {
+  std::string r;
+  for (int level = 0; level < config::kNumLevels; level++) {
+    // E.g.,
+    //   --- level 1 ---
+    //   17:123['a' .. 'd']
+    //   20:43['e' .. 'g']
+    r.append("--- level ");
+    AppendNumberTo(&r, level);
+    r.append(" ---\n");
+    const std::vector<FileMetaData*>& files = files_[level];
+    for (size_t i = 0; i < files.size(); i++) {
+      r.push_back(' ');
+      AppendNumberTo(&r, files[i]->number);
+      r.push_back(':');
+      AppendNumberTo(&r, files[i]->file_size);
+      r.append("[");
+      r.append(files[i]->smallest.DebugString());
+      r.append(" .. ");
+      r.append(files[i]->largest.DebugString());
+      r.append("]\n");
+    }
+  }
+  return r;
+}
+
+// A helper class so we can efficiently apply a whole sequence
+// of edits to a particular state without creating intermediate
+// Versions that contain full copies of the intermediate state.
+class VersionSet::Builder {
+ private:
+  // Helper to sort by v->files_[file_number].smallest
+  struct BySmallestKey {
+    const InternalKeyComparator* internal_comparator;
+
+    bool operator()(FileMetaData* f1, FileMetaData* f2) const {
+      int r = internal_comparator->Compare(f1->smallest, f2->smallest);
+      if (r != 0) {
+        return (r < 0);
+      } else {
+        // Break ties by file number
+        return (f1->number < f2->number);
+      }
+    }
+  };
+
+  typedef std::set<FileMetaData*, BySmallestKey> FileSet;
+  struct LevelState {
+    std::set<uint64_t> deleted_files;
+    FileSet* added_files;
+  };
+
+  VersionSet* vset_;
+  Version* base_;
+  LevelState levels_[config::kNumLevels];
+
+ public:
+  // Initialize a builder with the files from *base and other info from *vset
+  Builder(VersionSet* vset, Version* base)
+      : vset_(vset),
+        base_(base) {
+    base_->Ref();
+    BySmallestKey cmp;
+    cmp.internal_comparator = &vset_->icmp_;
+    for (int level = 0; level < config::kNumLevels; level++) {
+      levels_[level].added_files = new FileSet(cmp);
+    }
+  }
+
+  ~Builder() {
+    for (int level = 0; level < config::kNumLevels; level++) {
+      const FileSet* added = levels_[level].added_files;
+      std::vector<FileMetaData*> to_unref;
+      to_unref.reserve(added->size());
+      for (FileSet::const_iterator it = added->begin();
+          it != added->end(); ++it) {
+        to_unref.push_back(*it);
+      }
+      delete added;
+      for (uint32_t i = 0; i < to_unref.size(); i++) {
+        FileMetaData* f = to_unref[i];
+        f->refs--;
+        if (f->refs <= 0) {
+          delete f;
+        }
+      }
+    }
+    base_->Unref();
+  }
+
+  // Apply all of the edits in *edit to the current state.
+  void Apply(VersionEdit* edit) {
+    // Update compaction pointers
+    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {
+      const int level = edit->compact_pointers_[i].first;
+      vset_->compact_pointer_[level] =
+          edit->compact_pointers_[i].second.Encode().ToString();
+    }
+
+    // Delete files
+    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;
+    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();
+         iter != del.end();
+         ++iter) {
+      const int level = iter->first;
+      const uint64_t number = iter->second;
+      levels_[level].deleted_files.insert(number);
+    }
+
+    // Add new files
+    for (size_t i = 0; i < edit->new_files_.size(); i++) {
+      const int level = edit->new_files_[i].first;
+      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);
+      f->refs = 1;
+
+      // We arrange to automatically compact this file after
+      // a certain number of seeks.  Let's assume:
+      //   (1) One seek costs 10ms
+      //   (2) Writing or reading 1MB costs 10ms (100MB/s)
+      //   (3) A compaction of 1MB does 25MB of IO:
+      //         1MB read from this level
+      //         10-12MB read from next level (boundaries may be misaligned)
+      //         10-12MB written to next level
+      // This implies that 25 seeks cost the same as the compaction
+      // of 1MB of data.  I.e., one seek costs approximately the
+      // same as the compaction of 40KB of data.  We are a little
+      // conservative and allow approximately one seek for every 16KB
+      // of data before triggering a compaction.
+      f->allowed_seeks = (f->file_size / 16384);
+      if (f->allowed_seeks < 100) f->allowed_seeks = 100;
+
+      levels_[level].deleted_files.erase(f->number);
+      levels_[level].added_files->insert(f);
+    }
+  }
+
+  // Save the current state in *v.
+  void SaveTo(Version* v) {
+    BySmallestKey cmp;
+    cmp.internal_comparator = &vset_->icmp_;
+    for (int level = 0; level < config::kNumLevels; level++) {
+      // Merge the set of added files with the set of pre-existing files.
+      // Drop any deleted files.  Store the result in *v.
+      const std::vector<FileMetaData*>& base_files = base_->files_[level];
+      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();
+      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();
+      const FileSet* added = levels_[level].added_files;
+      v->files_[level].reserve(base_files.size() + added->size());
+      for (FileSet::const_iterator added_iter = added->begin();
+           added_iter != added->end();
+           ++added_iter) {
+        // Add all smaller files listed in base_
+        for (std::vector<FileMetaData*>::const_iterator bpos
+                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);
+             base_iter != bpos;
+             ++base_iter) {
+          MaybeAddFile(v, level, *base_iter);
+        }
+
+        MaybeAddFile(v, level, *added_iter);
+      }
+
+      // Add remaining base files
+      for (; base_iter != base_end; ++base_iter) {
+        MaybeAddFile(v, level, *base_iter);
+      }
+
+#ifndef NDEBUG
+      // Make sure there is no overlap in levels > 0
+      if (level > 0) {
+        for (uint32_t i = 1; i < v->files_[level].size(); i++) {
+          const InternalKey& prev_end = v->files_[level][i-1]->largest;
+          const InternalKey& this_begin = v->files_[level][i]->smallest;
+          if (vset_->icmp_.Compare(prev_end, this_begin) >= 0) {
+            fprintf(stderr, "overlapping ranges in same level %s vs. %s\n",
+                    prev_end.DebugString().c_str(),
+                    this_begin.DebugString().c_str());
+            abort();
+          }
+        }
+      }
+#endif
+    }
+  }
+
+  void MaybeAddFile(Version* v, int level, FileMetaData* f) {
+    if (levels_[level].deleted_files.count(f->number) > 0) {
+      // File is deleted: do nothing
+    } else {
+      std::vector<FileMetaData*>* files = &v->files_[level];
+      if (level > 0 && !files->empty()) {
+        // Must not overlap
+        assert(vset_->icmp_.Compare((*files)[files->size()-1]->largest,
+                                    f->smallest) < 0);
+      }
+      f->refs++;
+      files->push_back(f);
+    }
+  }
+};
+
+VersionSet::VersionSet(const std::string& dbname,
+                       const Options* options,
+                       TableCache* table_cache,
+                       const InternalKeyComparator* cmp)
+    : env_(options->env),
+      dbname_(dbname),
+      options_(options),
+      table_cache_(table_cache),
+      icmp_(*cmp),
+      next_file_number_(2),
+      manifest_file_number_(0),  // Filled by Recover()
+      last_sequence_(0),
+      log_number_(0),
+      prev_log_number_(0),
+      descriptor_file_(NULL),
+      descriptor_log_(NULL),
+      dummy_versions_(this),
+      current_(NULL) {
+  AppendVersion(new Version(this));
+}
+
+VersionSet::~VersionSet() {
+  current_->Unref();
+  assert(dummy_versions_.next_ == &dummy_versions_);  // List must be empty
+  delete descriptor_log_;
+  delete descriptor_file_;
+}
+
+void VersionSet::AppendVersion(Version* v) {
+  // Make "v" current
+  assert(v->refs_ == 0);
+  assert(v != current_);
+  if (current_ != NULL) {
+    current_->Unref();
+  }
+  current_ = v;
+  v->Ref();
+
+  // Append to linked list
+  v->prev_ = dummy_versions_.prev_;
+  v->next_ = &dummy_versions_;
+  v->prev_->next_ = v;
+  v->next_->prev_ = v;
+}
+
+Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {
+  if (edit->has_log_number_) {
+    assert(edit->log_number_ >= log_number_);
+    assert(edit->log_number_ < next_file_number_);
+  } else {
+    edit->SetLogNumber(log_number_);
+  }
+
+  if (!edit->has_prev_log_number_) {
+    edit->SetPrevLogNumber(prev_log_number_);
+  }
+
+  edit->SetNextFile(next_file_number_);
+  edit->SetLastSequence(last_sequence_);
+
+  Version* v = new Version(this);
+  {
+    Builder builder(this, current_);
+    builder.Apply(edit);
+    builder.SaveTo(v);
+  }
+  Finalize(v);
+
+  // Initialize new descriptor log file if necessary by creating
+  // a temporary file that contains a snapshot of the current version.
+  std::string new_manifest_file;
+  Status s;
+  if (descriptor_log_ == NULL) {
+    // No reason to unlock *mu here since we only hit this path in the
+    // first call to LogAndApply (when opening the database).
+    assert(descriptor_file_ == NULL);
+    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);
+    edit->SetNextFile(next_file_number_);
+    s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);
+    if (s.ok()) {
+      descriptor_log_ = new log::Writer(descriptor_file_);
+      s = WriteSnapshot(descriptor_log_);
+    }
+  }
+
+  // Unlock during expensive MANIFEST log write
+  {
+    mu->Unlock();
+
+    // Write new record to MANIFEST log
+    if (s.ok()) {
+      std::string record;
+      edit->EncodeTo(&record);
+      s = descriptor_log_->AddRecord(record);
+      if (s.ok()) {
+        s = descriptor_file_->Sync();
+      }
+      if (!s.ok()) {
+        Log(options_->info_log, "MANIFEST write: %s\n", s.ToString().c_str());
+      }
+    }
+
+    // If we just created a new descriptor file, install it by writing a
+    // new CURRENT file that points to it.
+    if (s.ok() && !new_manifest_file.empty()) {
+      s = SetCurrentFile(env_, dbname_, manifest_file_number_);
+    }
+
+    mu->Lock();
+  }
+
+  // Install the new version
+  if (s.ok()) {
+    AppendVersion(v);
+    log_number_ = edit->log_number_;
+    prev_log_number_ = edit->prev_log_number_;
+  } else {
+    delete v;
+    if (!new_manifest_file.empty()) {
+      delete descriptor_log_;
+      delete descriptor_file_;
+      descriptor_log_ = NULL;
+      descriptor_file_ = NULL;
+      env_->DeleteFile(new_manifest_file);
+    }
+  }
+
+  return s;
+}
+
+Status VersionSet::Recover() {
+  struct LogReporter : public log::Reader::Reporter {
+    Status* status;
+    virtual void Corruption(size_t bytes, const Status& s) {
+      if (this->status->ok()) *this->status = s;
+    }
+  };
+
+  // Read "CURRENT" file, which contains a pointer to the current manifest file
+  std::string current;
+  Status s = ReadFileToString(env_, CurrentFileName(dbname_), &current);
+  if (!s.ok()) {
+    return s;
+  }
+  if (current.empty() || current[current.size()-1] != '\n') {
+    return Status::Corruption("CURRENT file does not end with newline");
+  }
+  current.resize(current.size() - 1);
+
+  std::string dscname = dbname_ + "/" + current;
+  SequentialFile* file;
+  s = env_->NewSequentialFile(dscname, &file);
+  if (!s.ok()) {
+    return s;
+  }
+
+  bool have_log_number = false;
+  bool have_prev_log_number = false;
+  bool have_next_file = false;
+  bool have_last_sequence = false;
+  uint64_t next_file = 0;
+  uint64_t last_sequence = 0;
+  uint64_t log_number = 0;
+  uint64_t prev_log_number = 0;
+  Builder builder(this, current_);
+
+  {
+    LogReporter reporter;
+    reporter.status = &s;
+    log::Reader reader(file, &reporter, true/*checksum*/, 0/*initial_offset*/);
+    Slice record;
+    std::string scratch;
+    while (reader.ReadRecord(&record, &scratch) && s.ok()) {
+      VersionEdit edit;
+      s = edit.DecodeFrom(record);
+      if (s.ok()) {
+        if (edit.has_comparator_ &&
+            edit.comparator_ != icmp_.user_comparator()->Name()) {
+          s = Status::InvalidArgument(
+              edit.comparator_ + " does not match existing comparator ",
+              icmp_.user_comparator()->Name());
+        }
+      }
+
+      if (s.ok()) {
+        builder.Apply(&edit);
+      }
+
+      if (edit.has_log_number_) {
+        log_number = edit.log_number_;
+        have_log_number = true;
+      }
+
+      if (edit.has_prev_log_number_) {
+        prev_log_number = edit.prev_log_number_;
+        have_prev_log_number = true;
+      }
+
+      if (edit.has_next_file_number_) {
+        next_file = edit.next_file_number_;
+        have_next_file = true;
+      }
+
+      if (edit.has_last_sequence_) {
+        last_sequence = edit.last_sequence_;
+        have_last_sequence = true;
+      }
+    }
+  }
+  delete file;
+  file = NULL;
+
+  if (s.ok()) {
+    if (!have_next_file) {
+      s = Status::Corruption("no meta-nextfile entry in descriptor");
+    } else if (!have_log_number) {
+      s = Status::Corruption("no meta-lognumber entry in descriptor");
+    } else if (!have_last_sequence) {
+      s = Status::Corruption("no last-sequence-number entry in descriptor");
+    }
+
+    if (!have_prev_log_number) {
+      prev_log_number = 0;
+    }
+
+    MarkFileNumberUsed(prev_log_number);
+    MarkFileNumberUsed(log_number);
+  }
+
+  if (s.ok()) {
+    Version* v = new Version(this);
+    builder.SaveTo(v);
+    // Install recovered version
+    Finalize(v);
+    AppendVersion(v);
+    manifest_file_number_ = next_file;
+    next_file_number_ = next_file + 1;
+    last_sequence_ = last_sequence;
+    log_number_ = log_number;
+    prev_log_number_ = prev_log_number;
+  }
+
+  return s;
+}
+
+void VersionSet::MarkFileNumberUsed(uint64_t number) {
+  if (next_file_number_ <= number) {
+    next_file_number_ = number + 1;
+  }
+}
+
+void VersionSet::Finalize(Version* v) {
+  // Precomputed best level for next compaction
+  int best_level = -1;
+  double best_score = -1;
+
+  for (int level = 0; level < config::kNumLevels-1; level++) {
+    double score;
+    if (level == 0) {
+      // We treat level-0 specially by bounding the number of files
+      // instead of number of bytes for two reasons:
+      //
+      // (1) With larger write-buffer sizes, it is nice not to do too
+      // many level-0 compactions.
+      //
+      // (2) The files in level-0 are merged on every read and
+      // therefore we wish to avoid too many files when the individual
+      // file size is small (perhaps because of a small write-buffer
+      // setting, or very high compression ratios, or lots of
+      // overwrites/deletions).
+      score = v->files_[level].size() /
+          static_cast<double>(config::kL0_CompactionTrigger);
+    } else {
+      // Compute the ratio of current size to size limit.
+      const uint64_t level_bytes = TotalFileSize(v->files_[level]);
+      score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);
+    }
+
+    if (score > best_score) {
+      best_level = level;
+      best_score = score;
+    }
+  }
+
+  v->compaction_level_ = best_level;
+  v->compaction_score_ = best_score;
+}
+
+Status VersionSet::WriteSnapshot(log::Writer* log) {
+  // TODO: Break up into multiple records to reduce memory usage on recovery?
+
+  // Save metadata
+  VersionEdit edit;
+  edit.SetComparatorName(icmp_.user_comparator()->Name());
+
+  // Save compaction pointers
+  for (int level = 0; level < config::kNumLevels; level++) {
+    if (!compact_pointer_[level].empty()) {
+      InternalKey key;
+      key.DecodeFrom(compact_pointer_[level]);
+      edit.SetCompactPointer(level, key);
+    }
+  }
+
+  // Save files
+  for (int level = 0; level < config::kNumLevels; level++) {
+    const std::vector<FileMetaData*>& files = current_->files_[level];
+    for (size_t i = 0; i < files.size(); i++) {
+      const FileMetaData* f = files[i];
+      edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);
+    }
+  }
+
+  std::string record;
+  edit.EncodeTo(&record);
+  return log->AddRecord(record);
+}
+
+int VersionSet::NumLevelFiles(int level) const {
+  assert(level >= 0);
+  assert(level < config::kNumLevels);
+  return current_->files_[level].size();
+}
+
+const char* VersionSet::LevelSummary(LevelSummaryStorage* scratch) const {
+  // Update code if kNumLevels changes
+  assert(config::kNumLevels == 7);
+  snprintf(scratch->buffer, sizeof(scratch->buffer),
+           "files[ %d %d %d %d %d %d %d ]",
+           int(current_->files_[0].size()),
+           int(current_->files_[1].size()),
+           int(current_->files_[2].size()),
+           int(current_->files_[3].size()),
+           int(current_->files_[4].size()),
+           int(current_->files_[5].size()),
+           int(current_->files_[6].size()));
+  return scratch->buffer;
+}
+
+uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey& ikey) {
+  uint64_t result = 0;
+  for (int level = 0; level < config::kNumLevels; level++) {
+    const std::vector<FileMetaData*>& files = v->files_[level];
+    for (size_t i = 0; i < files.size(); i++) {
+      if (icmp_.Compare(files[i]->largest, ikey) <= 0) {
+        // Entire file is before "ikey", so just add the file size
+        result += files[i]->file_size;
+      } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {
+        // Entire file is after "ikey", so ignore
+        if (level > 0) {
+          // Files other than level 0 are sorted by meta->smallest, so
+          // no further files in this level will contain data for
+          // "ikey".
+          break;
+        }
+      } else {
+        // "ikey" falls in the range for this table.  Add the
+        // approximate offset of "ikey" within the table.
+        Table* tableptr;
+        Iterator* iter = table_cache_->NewIterator(
+            ReadOptions(), files[i]->number, files[i]->file_size, &tableptr);
+        if (tableptr != NULL) {
+          result += tableptr->ApproximateOffsetOf(ikey.Encode());
+        }
+        delete iter;
+      }
+    }
+  }
+  return result;
+}
+
+void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {
+  for (Version* v = dummy_versions_.next_;
+       v != &dummy_versions_;
+       v = v->next_) {
+    for (int level = 0; level < config::kNumLevels; level++) {
+      const std::vector<FileMetaData*>& files = v->files_[level];
+      for (size_t i = 0; i < files.size(); i++) {
+        live->insert(files[i]->number);
+      }
+    }
+  }
+}
+
+int64_t VersionSet::NumLevelBytes(int level) const {
+  assert(level >= 0);
+  assert(level < config::kNumLevels);
+  return TotalFileSize(current_->files_[level]);
+}
+
+int64_t VersionSet::MaxNextLevelOverlappingBytes() {
+  int64_t result = 0;
+  std::vector<FileMetaData*> overlaps;
+  for (int level = 1; level < config::kNumLevels - 1; level++) {
+    for (size_t i = 0; i < current_->files_[level].size(); i++) {
+      const FileMetaData* f = current_->files_[level][i];
+      current_->GetOverlappingInputs(level+1, &f->smallest, &f->largest,
+                                     &overlaps);
+      const int64_t sum = TotalFileSize(overlaps);
+      if (sum > result) {
+        result = sum;
+      }
+    }
+  }
+  return result;
+}
+
+// Stores the minimal range that covers all entries in inputs in
+// *smallest, *largest.
+// REQUIRES: inputs is not empty
+void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,
+                          InternalKey* smallest,
+                          InternalKey* largest) {
+  assert(!inputs.empty());
+  smallest->Clear();
+  largest->Clear();
+  for (size_t i = 0; i < inputs.size(); i++) {
+    FileMetaData* f = inputs[i];
+    if (i == 0) {
+      *smallest = f->smallest;
+      *largest = f->largest;
+    } else {
+      if (icmp_.Compare(f->smallest, *smallest) < 0) {
+        *smallest = f->smallest;
+      }
+      if (icmp_.Compare(f->largest, *largest) > 0) {
+        *largest = f->largest;
+      }
+    }
+  }
+}
+
+// Stores the minimal range that covers all entries in inputs1 and inputs2
+// in *smallest, *largest.
+// REQUIRES: inputs is not empty
+void VersionSet::GetRange2(const std::vector<FileMetaData*>& inputs1,
+                           const std::vector<FileMetaData*>& inputs2,
+                           InternalKey* smallest,
+                           InternalKey* largest) {
+  std::vector<FileMetaData*> all = inputs1;
+  all.insert(all.end(), inputs2.begin(), inputs2.end());
+  GetRange(all, smallest, largest);
+}
+
+Iterator* VersionSet::MakeInputIterator(Compaction* c) {
+  ReadOptions options;
+  options.verify_checksums = options_->paranoid_checks;
+  options.fill_cache = false;
+
+  // Level-0 files have to be merged together.  For other levels,
+  // we will make a concatenating iterator per level.
+  // TODO(opt): use concatenating iterator for level-0 if there is no overlap
+  const int space = (c->level() == 0 ? c->inputs_[0].size() + 1 : 2);
+  Iterator** list = new Iterator*[space];
+  int num = 0;
+  for (int which = 0; which < 2; which++) {
+    if (!c->inputs_[which].empty()) {
+      if (c->level() + which == 0) {
+        const std::vector<FileMetaData*>& files = c->inputs_[which];
+        for (size_t i = 0; i < files.size(); i++) {
+          list[num++] = table_cache_->NewIterator(
+              options, files[i]->number, files[i]->file_size);
+        }
+      } else {
+        // Create concatenating iterator for the files from this level
+        list[num++] = NewTwoLevelIterator(
+            new Version::LevelFileNumIterator(icmp_, &c->inputs_[which]),
+            &GetFileIterator, table_cache_, options);
+      }
+    }
+  }
+  assert(num <= space);
+  Iterator* result = NewMergingIterator(&icmp_, list, num);
+  delete[] list;
+  return result;
+}
+
+Compaction* VersionSet::PickCompaction() {
+  Compaction* c;
+  int level;
+
+  // We prefer compactions triggered by too much data in a level over
+  // the compactions triggered by seeks.
+  const bool size_compaction = (current_->compaction_score_ >= 1);
+  const bool seek_compaction = (current_->file_to_compact_ != NULL);
+  if (size_compaction) {
+    level = current_->compaction_level_;
+    assert(level >= 0);
+    assert(level+1 < config::kNumLevels);
+    c = new Compaction(level);
+
+    // Pick the first file that comes after compact_pointer_[level]
+    for (size_t i = 0; i < current_->files_[level].size(); i++) {
+      FileMetaData* f = current_->files_[level][i];
+      if (compact_pointer_[level].empty() ||
+          icmp_.Compare(f->largest.Encode(), compact_pointer_[level]) > 0) {
+        c->inputs_[0].push_back(f);
+        break;
+      }
+    }
+    if (c->inputs_[0].empty()) {
+      // Wrap-around to the beginning of the key space
+      c->inputs_[0].push_back(current_->files_[level][0]);
+    }
+  } else if (seek_compaction) {
+    level = current_->file_to_compact_level_;
+    c = new Compaction(level);
+    c->inputs_[0].push_back(current_->file_to_compact_);
+  } else {
+    return NULL;
+  }
+
+  c->input_version_ = current_;
+  c->input_version_->Ref();
+
+  // Files in level 0 may overlap each other, so pick up all overlapping ones
+  if (level == 0) {
+    InternalKey smallest, largest;
+    GetRange(c->inputs_[0], &smallest, &largest);
+    // Note that the next call will discard the file we placed in
+    // c->inputs_[0] earlier and replace it with an overlapping set
+    // which will include the picked file.
+    current_->GetOverlappingInputs(0, &smallest, &largest, &c->inputs_[0]);
+    assert(!c->inputs_[0].empty());
+  }
+
+  SetupOtherInputs(c);
+
+  return c;
+}
+
+void VersionSet::SetupOtherInputs(Compaction* c) {
+  const int level = c->level();
+  InternalKey smallest, largest;
+  GetRange(c->inputs_[0], &smallest, &largest);
+
+  current_->GetOverlappingInputs(level+1, &smallest, &largest, &c->inputs_[1]);
+
+  // Get entire range covered by compaction
+  InternalKey all_start, all_limit;
+  GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);
+
+  // See if we can grow the number of inputs in "level" without
+  // changing the number of "level+1" files we pick up.
+  if (!c->inputs_[1].empty()) {
+    std::vector<FileMetaData*> expanded0;
+    current_->GetOverlappingInputs(level, &all_start, &all_limit, &expanded0);
+    const int64_t inputs0_size = TotalFileSize(c->inputs_[0]);
+    const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);
+    const int64_t expanded0_size = TotalFileSize(expanded0);
+    if (expanded0.size() > c->inputs_[0].size() &&
+        inputs1_size + expanded0_size < kExpandedCompactionByteSizeLimit) {
+      InternalKey new_start, new_limit;
+      GetRange(expanded0, &new_start, &new_limit);
+      std::vector<FileMetaData*> expanded1;
+      current_->GetOverlappingInputs(level+1, &new_start, &new_limit,
+                                     &expanded1);
+      if (expanded1.size() == c->inputs_[1].size()) {
+        Log(options_->info_log,
+            "Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n",
+            level,
+            int(c->inputs_[0].size()),
+            int(c->inputs_[1].size()),
+            long(inputs0_size), long(inputs1_size),
+            int(expanded0.size()),
+            int(expanded1.size()),
+            long(expanded0_size), long(inputs1_size));
+        smallest = new_start;
+        largest = new_limit;
+        c->inputs_[0] = expanded0;
+        c->inputs_[1] = expanded1;
+        GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);
+      }
+    }
+  }
+
+  // Compute the set of grandparent files that overlap this compaction
+  // (parent == level+1; grandparent == level+2)
+  if (level + 2 < config::kNumLevels) {
+    current_->GetOverlappingInputs(level + 2, &all_start, &all_limit,
+                                   &c->grandparents_);
+  }
+
+  if (false) {
+    Log(options_->info_log, "Compacting %d '%s' .. '%s'",
+        level,
+        smallest.DebugString().c_str(),
+        largest.DebugString().c_str());
+  }
+
+  // Update the place where we will do the next compaction for this level.
+  // We update this immediately instead of waiting for the VersionEdit
+  // to be applied so that if the compaction fails, we will try a different
+  // key range next time.
+  compact_pointer_[level] = largest.Encode().ToString();
+  c->edit_.SetCompactPointer(level, largest);
+}
+
+Compaction* VersionSet::CompactRange(
+    int level,
+    const InternalKey* begin,
+    const InternalKey* end) {
+  std::vector<FileMetaData*> inputs;
+  current_->GetOverlappingInputs(level, begin, end, &inputs);
+  if (inputs.empty()) {
+    return NULL;
+  }
+
+  // Avoid compacting too much in one shot in case the range is large.
+  // But we cannot do this for level-0 since level-0 files can overlap
+  // and we must not pick one file and drop another older file if the
+  // two files overlap.
+  if (level > 0) {
+    const uint64_t limit = MaxFileSizeForLevel(level);
+    uint64_t total = 0;
+    for (size_t i = 0; i < inputs.size(); i++) {
+      uint64_t s = inputs[i]->file_size;
+      total += s;
+      if (total >= limit) {
+        inputs.resize(i + 1);
+        break;
+      }
+    }
+  }
+
+  Compaction* c = new Compaction(level);
+  c->input_version_ = current_;
+  c->input_version_->Ref();
+  c->inputs_[0] = inputs;
+  SetupOtherInputs(c);
+  return c;
+}
+
+Compaction::Compaction(int level)
+    : level_(level),
+      max_output_file_size_(MaxFileSizeForLevel(level)),
+      input_version_(NULL),
+      grandparent_index_(0),
+      seen_key_(false),
+      overlapped_bytes_(0) {
+  for (int i = 0; i < config::kNumLevels; i++) {
+    level_ptrs_[i] = 0;
+  }
+}
+
+Compaction::~Compaction() {
+  if (input_version_ != NULL) {
+    input_version_->Unref();
+  }
+}
+
+bool Compaction::IsTrivialMove() const {
+  // Avoid a move if there is lots of overlapping grandparent data.
+  // Otherwise, the move could create a parent file that will require
+  // a very expensive merge later on.
+  return (num_input_files(0) == 1 &&
+          num_input_files(1) == 0 &&
+          TotalFileSize(grandparents_) <= kMaxGrandParentOverlapBytes);
+}
+
+void Compaction::AddInputDeletions(VersionEdit* edit) {
+  for (int which = 0; which < 2; which++) {
+    for (size_t i = 0; i < inputs_[which].size(); i++) {
+      edit->DeleteFile(level_ + which, inputs_[which][i]->number);
+    }
+  }
+}
+
+bool Compaction::IsBaseLevelForKey(const Slice& user_key) {
+  // Maybe use binary search to find right entry instead of linear search?
+  const Comparator* user_cmp = input_version_->vset_->icmp_.user_comparator();
+  for (int lvl = level_ + 2; lvl < config::kNumLevels; lvl++) {
+    const std::vector<FileMetaData*>& files = input_version_->files_[lvl];
+    for (; level_ptrs_[lvl] < files.size(); ) {
+      FileMetaData* f = files[level_ptrs_[lvl]];
+      if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {
+        // We've advanced far enough
+        if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {
+          // Key falls in this file's range, so definitely not base level
+          return false;
+        }
+        break;
+      }
+      level_ptrs_[lvl]++;
+    }
+  }
+  return true;
+}
+
+bool Compaction::ShouldStopBefore(const Slice& internal_key) {
+  // Scan to find earliest grandparent file that contains key.
+  const InternalKeyComparator* icmp = &input_version_->vset_->icmp_;
+  while (grandparent_index_ < grandparents_.size() &&
+      icmp->Compare(internal_key,
+                    grandparents_[grandparent_index_]->largest.Encode()) > 0) {
+    if (seen_key_) {
+      overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;
+    }
+    grandparent_index_++;
+  }
+  seen_key_ = true;
+
+  if (overlapped_bytes_ > kMaxGrandParentOverlapBytes) {
+    // Too much overlap for current output; start new output
+    overlapped_bytes_ = 0;
+    return true;
+  } else {
+    return false;
+  }
+}
+
+void Compaction::ReleaseInputs() {
+  if (input_version_ != NULL) {
+    input_version_->Unref();
+    input_version_ = NULL;
+  }
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/version_set.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/version_set.h
new file mode 100644
index 0000000..8dc14b8
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/version_set.h
@@ -0,0 +1,396 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// The representation of a DBImpl consists of a set of Versions.  The
+// newest version is called "current".  Older versions may be kept
+// around to provide a consistent view to live iterators.
+//
+// Each Version keeps track of a set of Table files per level.  The
+// entire set of versions is maintained in a VersionSet.
+//
+// Version,VersionSet are thread-compatible, but require external
+// synchronization on all accesses.
+
+#ifndef STORAGE_LEVELDB_DB_VERSION_SET_H_
+#define STORAGE_LEVELDB_DB_VERSION_SET_H_
+
+#include <map>
+#include <set>
+#include <vector>
+#include "db/dbformat.h"
+#include "db/version_edit.h"
+#include "port/port.h"
+#include "port/thread_annotations.h"
+
+namespace leveldb {
+
+namespace log { class Writer; }
+
+class Compaction;
+class Iterator;
+class MemTable;
+class TableBuilder;
+class TableCache;
+class Version;
+class VersionSet;
+class WritableFile;
+
+// Return the smallest index i such that files[i]->largest >= key.
+// Return files.size() if there is no such file.
+// REQUIRES: "files" contains a sorted list of non-overlapping files.
+extern int FindFile(const InternalKeyComparator& icmp,
+                    const std::vector<FileMetaData*>& files,
+                    const Slice& key);
+
+// Returns true iff some file in "files" overlaps the user key range
+// [*smallest,*largest].
+// smallest==NULL represents a key smaller than all keys in the DB.
+// largest==NULL represents a key largest than all keys in the DB.
+// REQUIRES: If disjoint_sorted_files, files[] contains disjoint ranges
+//           in sorted order.
+extern bool SomeFileOverlapsRange(
+    const InternalKeyComparator& icmp,
+    bool disjoint_sorted_files,
+    const std::vector<FileMetaData*>& files,
+    const Slice* smallest_user_key,
+    const Slice* largest_user_key);
+
+class Version {
+ public:
+  // Append to *iters a sequence of iterators that will
+  // yield the contents of this Version when merged together.
+  // REQUIRES: This version has been saved (see VersionSet::SaveTo)
+  void AddIterators(const ReadOptions&, std::vector<Iterator*>* iters);
+
+  // Lookup the value for key.  If found, store it in *val and
+  // return OK.  Else return a non-OK status.  Fills *stats.
+  // REQUIRES: lock is not held
+  struct GetStats {
+    FileMetaData* seek_file;
+    int seek_file_level;
+  };
+  Status Get(const ReadOptions&, const LookupKey& key, std::string* val,
+             GetStats* stats);
+
+  // Adds "stats" into the current state.  Returns true if a new
+  // compaction may need to be triggered, false otherwise.
+  // REQUIRES: lock is held
+  bool UpdateStats(const GetStats& stats);
+
+  // Record a sample of bytes read at the specified internal key.
+  // Samples are taken approximately once every config::kReadBytesPeriod
+  // bytes.  Returns true if a new compaction may need to be triggered.
+  // REQUIRES: lock is held
+  bool RecordReadSample(Slice key);
+
+  // Reference count management (so Versions do not disappear out from
+  // under live iterators)
+  void Ref();
+  void Unref();
+
+  void GetOverlappingInputs(
+      int level,
+      const InternalKey* begin,         // NULL means before all keys
+      const InternalKey* end,           // NULL means after all keys
+      std::vector<FileMetaData*>* inputs);
+
+  // Returns true iff some file in the specified level overlaps
+  // some part of [*smallest_user_key,*largest_user_key].
+  // smallest_user_key==NULL represents a key smaller than all keys in the DB.
+  // largest_user_key==NULL represents a key largest than all keys in the DB.
+  bool OverlapInLevel(int level,
+                      const Slice* smallest_user_key,
+                      const Slice* largest_user_key);
+
+  // Return the level at which we should place a new memtable compaction
+  // result that covers the range [smallest_user_key,largest_user_key].
+  int PickLevelForMemTableOutput(const Slice& smallest_user_key,
+                                 const Slice& largest_user_key);
+
+  int NumFiles(int level) const { return files_[level].size(); }
+
+  // Return a human readable string that describes this version's contents.
+  std::string DebugString() const;
+
+ private:
+  friend class Compaction;
+  friend class VersionSet;
+
+  class LevelFileNumIterator;
+  Iterator* NewConcatenatingIterator(const ReadOptions&, int level) const;
+
+  // Call func(arg, level, f) for every file that overlaps user_key in
+  // order from newest to oldest.  If an invocation of func returns
+  // false, makes no more calls.
+  //
+  // REQUIRES: user portion of internal_key == user_key.
+  void ForEachOverlapping(Slice user_key, Slice internal_key,
+                          void* arg,
+                          bool (*func)(void*, int, FileMetaData*));
+
+  VersionSet* vset_;            // VersionSet to which this Version belongs
+  Version* next_;               // Next version in linked list
+  Version* prev_;               // Previous version in linked list
+  int refs_;                    // Number of live refs to this version
+
+  // List of files per level
+  std::vector<FileMetaData*> files_[config::kNumLevels];
+
+  // Next file to compact based on seek stats.
+  FileMetaData* file_to_compact_;
+  int file_to_compact_level_;
+
+  // Level that should be compacted next and its compaction score.
+  // Score < 1 means compaction is not strictly needed.  These fields
+  // are initialized by Finalize().
+  double compaction_score_;
+  int compaction_level_;
+
+  explicit Version(VersionSet* vset)
+      : vset_(vset), next_(this), prev_(this), refs_(0),
+        file_to_compact_(NULL),
+        file_to_compact_level_(-1),
+        compaction_score_(-1),
+        compaction_level_(-1) {
+  }
+
+  ~Version();
+
+  // No copying allowed
+  Version(const Version&);
+  void operator=(const Version&);
+};
+
+class VersionSet {
+ public:
+  VersionSet(const std::string& dbname,
+             const Options* options,
+             TableCache* table_cache,
+             const InternalKeyComparator*);
+  ~VersionSet();
+
+  // Apply *edit to the current version to form a new descriptor that
+  // is both saved to persistent state and installed as the new
+  // current version.  Will release *mu while actually writing to the file.
+  // REQUIRES: *mu is held on entry.
+  // REQUIRES: no other thread concurrently calls LogAndApply()
+  Status LogAndApply(VersionEdit* edit, port::Mutex* mu)
+      EXCLUSIVE_LOCKS_REQUIRED(mu);
+
+  // Recover the last saved descriptor from persistent storage.
+  Status Recover();
+
+  // Return the current version.
+  Version* current() const { return current_; }
+
+  // Return the current manifest file number
+  uint64_t ManifestFileNumber() const { return manifest_file_number_; }
+
+  // Allocate and return a new file number
+  uint64_t NewFileNumber() { return next_file_number_++; }
+
+  // Arrange to reuse "file_number" unless a newer file number has
+  // already been allocated.
+  // REQUIRES: "file_number" was returned by a call to NewFileNumber().
+  void ReuseFileNumber(uint64_t file_number) {
+    if (next_file_number_ == file_number + 1) {
+      next_file_number_ = file_number;
+    }
+  }
+
+  // Return the number of Table files at the specified level.
+  int NumLevelFiles(int level) const;
+
+  // Return the combined file size of all files at the specified level.
+  int64_t NumLevelBytes(int level) const;
+
+  // Return the last sequence number.
+  uint64_t LastSequence() const { return last_sequence_; }
+
+  // Set the last sequence number to s.
+  void SetLastSequence(uint64_t s) {
+    assert(s >= last_sequence_);
+    last_sequence_ = s;
+  }
+
+  // Mark the specified file number as used.
+  void MarkFileNumberUsed(uint64_t number);
+
+  // Return the current log file number.
+  uint64_t LogNumber() const { return log_number_; }
+
+  // Return the log file number for the log file that is currently
+  // being compacted, or zero if there is no such log file.
+  uint64_t PrevLogNumber() const { return prev_log_number_; }
+
+  // Pick level and inputs for a new compaction.
+  // Returns NULL if there is no compaction to be done.
+  // Otherwise returns a pointer to a heap-allocated object that
+  // describes the compaction.  Caller should delete the result.
+  Compaction* PickCompaction();
+
+  // Return a compaction object for compacting the range [begin,end] in
+  // the specified level.  Returns NULL if there is nothing in that
+  // level that overlaps the specified range.  Caller should delete
+  // the result.
+  Compaction* CompactRange(
+      int level,
+      const InternalKey* begin,
+      const InternalKey* end);
+
+  // Return the maximum overlapping data (in bytes) at next level for any
+  // file at a level >= 1.
+  int64_t MaxNextLevelOverlappingBytes();
+
+  // Create an iterator that reads over the compaction inputs for "*c".
+  // The caller should delete the iterator when no longer needed.
+  Iterator* MakeInputIterator(Compaction* c);
+
+  // Returns true iff some level needs a compaction.
+  bool NeedsCompaction() const {
+    Version* v = current_;
+    return (v->compaction_score_ >= 1) || (v->file_to_compact_ != NULL);
+  }
+
+  // Add all files listed in any live version to *live.
+  // May also mutate some internal state.
+  void AddLiveFiles(std::set<uint64_t>* live);
+
+  // Return the approximate offset in the database of the data for
+  // "key" as of version "v".
+  uint64_t ApproximateOffsetOf(Version* v, const InternalKey& key);
+
+  // Return a human-readable short (single-line) summary of the number
+  // of files per level.  Uses *scratch as backing store.
+  struct LevelSummaryStorage {
+    char buffer[100];
+  };
+  const char* LevelSummary(LevelSummaryStorage* scratch) const;
+
+ private:
+  class Builder;
+
+  friend class Compaction;
+  friend class Version;
+
+  void Finalize(Version* v);
+
+  void GetRange(const std::vector<FileMetaData*>& inputs,
+                InternalKey* smallest,
+                InternalKey* largest);
+
+  void GetRange2(const std::vector<FileMetaData*>& inputs1,
+                 const std::vector<FileMetaData*>& inputs2,
+                 InternalKey* smallest,
+                 InternalKey* largest);
+
+  void SetupOtherInputs(Compaction* c);
+
+  // Save current contents to *log
+  Status WriteSnapshot(log::Writer* log);
+
+  void AppendVersion(Version* v);
+
+  Env* const env_;
+  const std::string dbname_;
+  const Options* const options_;
+  TableCache* const table_cache_;
+  const InternalKeyComparator icmp_;
+  uint64_t next_file_number_;
+  uint64_t manifest_file_number_;
+  uint64_t last_sequence_;
+  uint64_t log_number_;
+  uint64_t prev_log_number_;  // 0 or backing store for memtable being compacted
+
+  // Opened lazily
+  WritableFile* descriptor_file_;
+  log::Writer* descriptor_log_;
+  Version dummy_versions_;  // Head of circular doubly-linked list of versions.
+  Version* current_;        // == dummy_versions_.prev_
+
+  // Per-level key at which the next compaction at that level should start.
+  // Either an empty string, or a valid InternalKey.
+  std::string compact_pointer_[config::kNumLevels];
+
+  // No copying allowed
+  VersionSet(const VersionSet&);
+  void operator=(const VersionSet&);
+};
+
+// A Compaction encapsulates information about a compaction.
+class Compaction {
+ public:
+  ~Compaction();
+
+  // Return the level that is being compacted.  Inputs from "level"
+  // and "level+1" will be merged to produce a set of "level+1" files.
+  int level() const { return level_; }
+
+  // Return the object that holds the edits to the descriptor done
+  // by this compaction.
+  VersionEdit* edit() { return &edit_; }
+
+  // "which" must be either 0 or 1
+  int num_input_files(int which) const { return inputs_[which].size(); }
+
+  // Return the ith input file at "level()+which" ("which" must be 0 or 1).
+  FileMetaData* input(int which, int i) const { return inputs_[which][i]; }
+
+  // Maximum size of files to build during this compaction.
+  uint64_t MaxOutputFileSize() const { return max_output_file_size_; }
+
+  // Is this a trivial compaction that can be implemented by just
+  // moving a single input file to the next level (no merging or splitting)
+  bool IsTrivialMove() const;
+
+  // Add all inputs to this compaction as delete operations to *edit.
+  void AddInputDeletions(VersionEdit* edit);
+
+  // Returns true if the information we have available guarantees that
+  // the compaction is producing data in "level+1" for which no data exists
+  // in levels greater than "level+1".
+  bool IsBaseLevelForKey(const Slice& user_key);
+
+  // Returns true iff we should stop building the current output
+  // before processing "internal_key".
+  bool ShouldStopBefore(const Slice& internal_key);
+
+  // Release the input version for the compaction, once the compaction
+  // is successful.
+  void ReleaseInputs();
+
+ private:
+  friend class Version;
+  friend class VersionSet;
+
+  explicit Compaction(int level);
+
+  int level_;
+  uint64_t max_output_file_size_;
+  Version* input_version_;
+  VersionEdit edit_;
+
+  // Each compaction reads inputs from "level_" and "level_+1"
+  std::vector<FileMetaData*> inputs_[2];      // The two sets of inputs
+
+  // State used to check for number of of overlapping grandparent files
+  // (parent == level_ + 1, grandparent == level_ + 2)
+  std::vector<FileMetaData*> grandparents_;
+  size_t grandparent_index_;  // Index in grandparent_starts_
+  bool seen_key_;             // Some output key has been seen
+  int64_t overlapped_bytes_;  // Bytes of overlap between current output
+                              // and grandparent files
+
+  // State for implementing IsBaseLevelForKey
+
+  // level_ptrs_ holds indices into input_version_->levels_: our state
+  // is that we are positioned at one of the file ranges for each
+  // higher level than the ones involved in this compaction (i.e. for
+  // all L >= level_ + 2).
+  size_t level_ptrs_[config::kNumLevels];
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_DB_VERSION_SET_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/write_batch.cc b/packages/LevelDB.1.16.0.5/lib/native/src/db/write_batch.cc
new file mode 100644
index 0000000..33f4a42
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/write_batch.cc
@@ -0,0 +1,147 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// WriteBatch::rep_ :=
+//    sequence: fixed64
+//    count: fixed32
+//    data: record[count]
+// record :=
+//    kTypeValue varstring varstring         |
+//    kTypeDeletion varstring
+// varstring :=
+//    len: varint32
+//    data: uint8[len]
+
+#include "leveldb/write_batch.h"
+
+#include "leveldb/db.h"
+#include "db/dbformat.h"
+#include "db/memtable.h"
+#include "db/write_batch_internal.h"
+#include "util/coding.h"
+
+namespace leveldb {
+
+// WriteBatch header has an 8-byte sequence number followed by a 4-byte count.
+static const size_t kHeader = 12;
+
+WriteBatch::WriteBatch() {
+  Clear();
+}
+
+WriteBatch::~WriteBatch() { }
+
+WriteBatch::Handler::~Handler() { }
+
+void WriteBatch::Clear() {
+  rep_.clear();
+  rep_.resize(kHeader);
+}
+
+Status WriteBatch::Iterate(Handler* handler) const {
+  Slice input(rep_);
+  if (input.size() < kHeader) {
+    return Status::Corruption("malformed WriteBatch (too small)");
+  }
+
+  input.remove_prefix(kHeader);
+  Slice key, value;
+  int found = 0;
+  while (!input.empty()) {
+    found++;
+    char tag = input[0];
+    input.remove_prefix(1);
+    switch (tag) {
+      case kTypeValue:
+        if (GetLengthPrefixedSlice(&input, &key) &&
+            GetLengthPrefixedSlice(&input, &value)) {
+          handler->Put(key, value);
+        } else {
+          return Status::Corruption("bad WriteBatch Put");
+        }
+        break;
+      case kTypeDeletion:
+        if (GetLengthPrefixedSlice(&input, &key)) {
+          handler->Delete(key);
+        } else {
+          return Status::Corruption("bad WriteBatch Delete");
+        }
+        break;
+      default:
+        return Status::Corruption("unknown WriteBatch tag");
+    }
+  }
+  if (found != WriteBatchInternal::Count(this)) {
+    return Status::Corruption("WriteBatch has wrong count");
+  } else {
+    return Status::OK();
+  }
+}
+
+int WriteBatchInternal::Count(const WriteBatch* b) {
+  return DecodeFixed32(b->rep_.data() + 8);
+}
+
+void WriteBatchInternal::SetCount(WriteBatch* b, int n) {
+  EncodeFixed32(&b->rep_[8], n);
+}
+
+SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {
+  return SequenceNumber(DecodeFixed64(b->rep_.data()));
+}
+
+void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {
+  EncodeFixed64(&b->rep_[0], seq);
+}
+
+void WriteBatch::Put(const Slice& key, const Slice& value) {
+  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
+  rep_.push_back(static_cast<char>(kTypeValue));
+  PutLengthPrefixedSlice(&rep_, key);
+  PutLengthPrefixedSlice(&rep_, value);
+}
+
+void WriteBatch::Delete(const Slice& key) {
+  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
+  rep_.push_back(static_cast<char>(kTypeDeletion));
+  PutLengthPrefixedSlice(&rep_, key);
+}
+
+namespace {
+class MemTableInserter : public WriteBatch::Handler {
+ public:
+  SequenceNumber sequence_;
+  MemTable* mem_;
+
+  virtual void Put(const Slice& key, const Slice& value) {
+    mem_->Add(sequence_, kTypeValue, key, value);
+    sequence_++;
+  }
+  virtual void Delete(const Slice& key) {
+    mem_->Add(sequence_, kTypeDeletion, key, Slice());
+    sequence_++;
+  }
+};
+}  // namespace
+
+Status WriteBatchInternal::InsertInto(const WriteBatch* b,
+                                      MemTable* memtable) {
+  MemTableInserter inserter;
+  inserter.sequence_ = WriteBatchInternal::Sequence(b);
+  inserter.mem_ = memtable;
+  return b->Iterate(&inserter);
+}
+
+void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {
+  assert(contents.size() >= kHeader);
+  b->rep_.assign(contents.data(), contents.size());
+}
+
+void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) {
+  SetCount(dst, Count(dst) + Count(src));
+  assert(src->rep_.size() >= kHeader);
+  dst->rep_.append(src->rep_.data() + kHeader, src->rep_.size() - kHeader);
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/db/write_batch_internal.h b/packages/LevelDB.1.16.0.5/lib/native/src/db/write_batch_internal.h
new file mode 100644
index 0000000..4423a7f
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/db/write_batch_internal.h
@@ -0,0 +1,49 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_DB_WRITE_BATCH_INTERNAL_H_
+#define STORAGE_LEVELDB_DB_WRITE_BATCH_INTERNAL_H_
+
+#include "leveldb/write_batch.h"
+
+namespace leveldb {
+
+class MemTable;
+
+// WriteBatchInternal provides static methods for manipulating a
+// WriteBatch that we don't want in the public WriteBatch interface.
+class WriteBatchInternal {
+ public:
+  // Return the number of entries in the batch.
+  static int Count(const WriteBatch* batch);
+
+  // Set the count for the number of entries in the batch.
+  static void SetCount(WriteBatch* batch, int n);
+
+  // Return the seqeunce number for the start of this batch.
+  static SequenceNumber Sequence(const WriteBatch* batch);
+
+  // Store the specified number as the seqeunce number for the start of
+  // this batch.
+  static void SetSequence(WriteBatch* batch, SequenceNumber seq);
+
+  static Slice Contents(const WriteBatch* batch) {
+    return Slice(batch->rep_);
+  }
+
+  static size_t ByteSize(const WriteBatch* batch) {
+    return batch->rep_.size();
+  }
+
+  static void SetContents(WriteBatch* batch, const Slice& contents);
+
+  static Status InsertInto(const WriteBatch* batch, MemTable* memtable);
+
+  static void Append(WriteBatch* dst, const WriteBatch* src);
+};
+
+}  // namespace leveldb
+
+
+#endif  // STORAGE_LEVELDB_DB_WRITE_BATCH_INTERNAL_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/helpers/memenv/memenv.cc b/packages/LevelDB.1.16.0.5/lib/native/src/helpers/memenv/memenv.cc
new file mode 100644
index 0000000..5879de1
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/helpers/memenv/memenv.cc
@@ -0,0 +1,384 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "helpers/memenv/memenv.h"
+
+#include "leveldb/env.h"
+#include "leveldb/status.h"
+#include "port/port.h"
+#include "util/mutexlock.h"
+#include <map>
+#include <string.h>
+#include <string>
+#include <vector>
+
+namespace leveldb {
+
+namespace {
+
+class FileState {
+ public:
+  // FileStates are reference counted. The initial reference count is zero
+  // and the caller must call Ref() at least once.
+  FileState() : refs_(0), size_(0) {}
+
+  // Increase the reference count.
+  void Ref() {
+    MutexLock lock(&refs_mutex_);
+    ++refs_;
+  }
+
+  // Decrease the reference count. Delete if this is the last reference.
+  void Unref() {
+    bool do_delete = false;
+
+    {
+      MutexLock lock(&refs_mutex_);
+      --refs_;
+      assert(refs_ >= 0);
+      if (refs_ <= 0) {
+        do_delete = true;
+      }
+    }
+
+    if (do_delete) {
+      delete this;
+    }
+  }
+
+  uint64_t Size() const { return size_; }
+
+  Status Read(uint64_t offset, size_t n, Slice* result, char* scratch) const {
+    if (offset > size_) {
+      return Status::IOError("Offset greater than file size.");
+    }
+    const uint64_t available = size_ - offset;
+    if (n > available) {
+      n = available;
+    }
+    if (n == 0) {
+      *result = Slice();
+      return Status::OK();
+    }
+
+    size_t block = offset / kBlockSize;
+    size_t block_offset = offset % kBlockSize;
+
+    if (n <= kBlockSize - block_offset) {
+      // The requested bytes are all in the first block.
+      *result = Slice(blocks_[block] + block_offset, n);
+      return Status::OK();
+    }
+
+    size_t bytes_to_copy = n;
+    char* dst = scratch;
+
+    while (bytes_to_copy > 0) {
+      size_t avail = kBlockSize - block_offset;
+      if (avail > bytes_to_copy) {
+        avail = bytes_to_copy;
+      }
+      memcpy(dst, blocks_[block] + block_offset, avail);
+
+      bytes_to_copy -= avail;
+      dst += avail;
+      block++;
+      block_offset = 0;
+    }
+
+    *result = Slice(scratch, n);
+    return Status::OK();
+  }
+
+  Status Append(const Slice& data) {
+    const char* src = data.data();
+    size_t src_len = data.size();
+
+    while (src_len > 0) {
+      size_t avail;
+      size_t offset = size_ % kBlockSize;
+
+      if (offset != 0) {
+        // There is some room in the last block.
+        avail = kBlockSize - offset;
+      } else {
+        // No room in the last block; push new one.
+        blocks_.push_back(new char[kBlockSize]);
+        avail = kBlockSize;
+      }
+
+      if (avail > src_len) {
+        avail = src_len;
+      }
+      memcpy(blocks_.back() + offset, src, avail);
+      src_len -= avail;
+      src += avail;
+      size_ += avail;
+    }
+
+    return Status::OK();
+  }
+
+ private:
+  // Private since only Unref() should be used to delete it.
+  ~FileState() {
+    for (std::vector<char*>::iterator i = blocks_.begin(); i != blocks_.end();
+         ++i) {
+      delete [] *i;
+    }
+  }
+
+  // No copying allowed.
+  FileState(const FileState&);
+  void operator=(const FileState&);
+
+  port::Mutex refs_mutex_;
+  int refs_;  // Protected by refs_mutex_;
+
+  // The following fields are not protected by any mutex. They are only mutable
+  // while the file is being written, and concurrent access is not allowed
+  // to writable files.
+  std::vector<char*> blocks_;
+  uint64_t size_;
+
+  enum { kBlockSize = 8 * 1024 };
+};
+
+class SequentialFileImpl : public SequentialFile {
+ public:
+  explicit SequentialFileImpl(FileState* file) : file_(file), pos_(0) {
+    file_->Ref();
+  }
+
+  ~SequentialFileImpl() {
+    file_->Unref();
+  }
+
+  virtual Status Read(size_t n, Slice* result, char* scratch) {
+    Status s = file_->Read(pos_, n, result, scratch);
+    if (s.ok()) {
+      pos_ += result->size();
+    }
+    return s;
+  }
+
+  virtual Status Skip(uint64_t n) {
+    if (pos_ > file_->Size()) {
+      return Status::IOError("pos_ > file_->Size()");
+    }
+    const size_t available = file_->Size() - pos_;
+    if (n > available) {
+      n = available;
+    }
+    pos_ += n;
+    return Status::OK();
+  }
+
+ private:
+  FileState* file_;
+  size_t pos_;
+};
+
+class RandomAccessFileImpl : public RandomAccessFile {
+ public:
+  explicit RandomAccessFileImpl(FileState* file) : file_(file) {
+    file_->Ref();
+  }
+
+  ~RandomAccessFileImpl() {
+    file_->Unref();
+  }
+
+  virtual Status Read(uint64_t offset, size_t n, Slice* result,
+                      char* scratch) const {
+    return file_->Read(offset, n, result, scratch);
+  }
+
+ private:
+  FileState* file_;
+};
+
+class WritableFileImpl : public WritableFile {
+ public:
+  WritableFileImpl(FileState* file) : file_(file) {
+    file_->Ref();
+  }
+
+  ~WritableFileImpl() {
+    file_->Unref();
+  }
+
+  virtual Status Append(const Slice& data) {
+    return file_->Append(data);
+  }
+
+  virtual Status Close() { return Status::OK(); }
+  virtual Status Flush() { return Status::OK(); }
+  virtual Status Sync() { return Status::OK(); }
+
+ private:
+  FileState* file_;
+};
+
+class NoOpLogger : public Logger {
+ public:
+  virtual void Logv(const char* format, va_list ap) { }
+};
+
+class InMemoryEnv : public EnvWrapper {
+ public:
+  explicit InMemoryEnv(Env* base_env) : EnvWrapper(base_env) { }
+
+  virtual ~InMemoryEnv() {
+    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){
+      i->second->Unref();
+    }
+  }
+
+  // Partial implementation of the Env interface.
+  virtual Status NewSequentialFile(const std::string& fname,
+                                   SequentialFile** result) {
+    MutexLock lock(&mutex_);
+    if (file_map_.find(fname) == file_map_.end()) {
+      *result = NULL;
+      return Status::IOError(fname, "File not found");
+    }
+
+    *result = new SequentialFileImpl(file_map_[fname]);
+    return Status::OK();
+  }
+
+  virtual Status NewRandomAccessFile(const std::string& fname,
+                                     RandomAccessFile** result) {
+    MutexLock lock(&mutex_);
+    if (file_map_.find(fname) == file_map_.end()) {
+      *result = NULL;
+      return Status::IOError(fname, "File not found");
+    }
+
+    *result = new RandomAccessFileImpl(file_map_[fname]);
+    return Status::OK();
+  }
+
+  virtual Status NewWritableFile(const std::string& fname,
+                                 WritableFile** result) {
+    MutexLock lock(&mutex_);
+    if (file_map_.find(fname) != file_map_.end()) {
+      DeleteFileInternal(fname);
+    }
+
+    FileState* file = new FileState();
+    file->Ref();
+    file_map_[fname] = file;
+
+    *result = new WritableFileImpl(file);
+    return Status::OK();
+  }
+
+  virtual bool FileExists(const std::string& fname) {
+    MutexLock lock(&mutex_);
+    return file_map_.find(fname) != file_map_.end();
+  }
+
+  virtual Status GetChildren(const std::string& dir,
+                             std::vector<std::string>* result) {
+    MutexLock lock(&mutex_);
+    result->clear();
+
+    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){
+      const std::string& filename = i->first;
+
+      if (filename.size() >= dir.size() + 1 && filename[dir.size()] == '/' &&
+          Slice(filename).starts_with(Slice(dir))) {
+        result->push_back(filename.substr(dir.size() + 1));
+      }
+    }
+
+    return Status::OK();
+  }
+
+  void DeleteFileInternal(const std::string& fname) {
+    if (file_map_.find(fname) == file_map_.end()) {
+      return;
+    }
+
+    file_map_[fname]->Unref();
+    file_map_.erase(fname);
+  }
+
+  virtual Status DeleteFile(const std::string& fname) {
+    MutexLock lock(&mutex_);
+    if (file_map_.find(fname) == file_map_.end()) {
+      return Status::IOError(fname, "File not found");
+    }
+
+    DeleteFileInternal(fname);
+    return Status::OK();
+  }
+
+  virtual Status CreateDir(const std::string& dirname) {
+    return Status::OK();
+  }
+
+  virtual Status DeleteDir(const std::string& dirname) {
+    return Status::OK();
+  }
+
+  virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) {
+    MutexLock lock(&mutex_);
+    if (file_map_.find(fname) == file_map_.end()) {
+      return Status::IOError(fname, "File not found");
+    }
+
+    *file_size = file_map_[fname]->Size();
+    return Status::OK();
+  }
+
+  virtual Status RenameFile(const std::string& src,
+                            const std::string& target) {
+    MutexLock lock(&mutex_);
+    if (file_map_.find(src) == file_map_.end()) {
+      return Status::IOError(src, "File not found");
+    }
+
+    DeleteFileInternal(target);
+    file_map_[target] = file_map_[src];
+    file_map_.erase(src);
+    return Status::OK();
+  }
+
+  virtual Status LockFile(const std::string& fname, FileLock** lock) {
+    *lock = new FileLock;
+    return Status::OK();
+  }
+
+  virtual Status UnlockFile(FileLock* lock) {
+    delete lock;
+    return Status::OK();
+  }
+
+  virtual Status GetTestDirectory(std::string* path) {
+    *path = "/test";
+    return Status::OK();
+  }
+
+  virtual Status NewLogger(const std::string& fname, Logger** result) {
+    *result = new NoOpLogger;
+    return Status::OK();
+  }
+
+ private:
+  // Map from filenames to FileState objects, representing a simple file system.
+  typedef std::map<std::string, FileState*> FileSystem;
+  port::Mutex mutex_;
+  FileSystem file_map_;  // Protected by mutex_.
+};
+
+}  // namespace
+
+Env* NewMemEnv(Env* base_env) {
+  return new InMemoryEnv(base_env);
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/helpers/memenv/memenv.h b/packages/LevelDB.1.16.0.5/lib/native/src/helpers/memenv/memenv.h
new file mode 100644
index 0000000..03b88de
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/helpers/memenv/memenv.h
@@ -0,0 +1,20 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_HELPERS_MEMENV_MEMENV_H_
+#define STORAGE_LEVELDB_HELPERS_MEMENV_MEMENV_H_
+
+namespace leveldb {
+
+class Env;
+
+// Returns a new environment that stores its data in memory and delegates
+// all non-file-storage tasks to base_env. The caller must delete the result
+// when it is no longer needed.
+// *base_env must remain live while the result is in use.
+Env* NewMemEnv(Env* base_env);
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_HELPERS_MEMENV_MEMENV_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/leveldb-single-file.cpp b/packages/LevelDB.1.16.0.5/lib/native/src/leveldb-single-file.cpp
new file mode 100644
index 0000000..b7c1893
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/leveldb-single-file.cpp
@@ -0,0 +1,52 @@
+#ifndef _CRT_SECURE_NO_WARNINGS
+#define _CRT_SECURE_NO_WARNINGS
+#endif
+
+#ifndef _CRT_NONSTDC_NO_DEPRECATE
+#define _CRT_NONSTDC_NO_DEPRECATE
+#endif
+
+#pragma warning(disable: 4005 4018 4244 4267 4309 4715 4722 4800)
+
+#include "db/builder.cc"
+#include "db/c.cc"
+#include "db/db_bench.cc"
+#include "db/db_impl.cc"
+#include "db/db_iter.cc"
+#include "db/dbformat.cc"
+#include "db/filename.cc"
+#include "db/log_reader.cc"
+#include "db/log_writer.cc"
+#include "db/memtable.cc"
+#include "db/repair.cc"
+#include "db/table_cache.cc"
+#include "db/version_edit.cc"
+#include "db/version_set.cc"
+#include "db/write_batch.cc"
+#include "helpers/memenv/memenv.cc"
+#include "port/win/crc32c_win.cc"
+#include "port/port_win.cc"
+#include "table/block.cc"
+#include "table/block_builder.cc"
+#include "table/filter_block.cc"
+#include "table/format.cc"
+#include "table/iterator.cc"
+#include "table/merger.cc"
+#include "table/table.cc"
+#include "table/table_builder.cc"
+#include "table/two_level_iterator.cc"
+#include "util/arena.cc"
+#include "util/bloom.cc"
+#include "util/cache.cc"
+#include "util/coding.cc"
+#include "util/comparator.cc"
+#include "util/env.cc"
+#include "util/env_win.cc"
+#include "util/filter_policy.cc"
+#include "util/hash.cc"
+#include "util/histogram.cc"
+#include "util/logging.cc"
+#include "util/options.cc"
+#include "util/status.cc"
+#include "util/testharness.cc"
+#include "util/testutil.cc"
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/port/atomic_pointer.h b/packages/LevelDB.1.16.0.5/lib/native/src/port/atomic_pointer.h
new file mode 100644
index 0000000..a9866b2
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/port/atomic_pointer.h
@@ -0,0 +1,224 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+// AtomicPointer provides storage for a lock-free pointer.
+// Platform-dependent implementation of AtomicPointer:
+// - If the platform provides a cheap barrier, we use it with raw pointers
+// - If cstdatomic is present (on newer versions of gcc, it is), we use
+//   a cstdatomic-based AtomicPointer.  However we prefer the memory
+//   barrier based version, because at least on a gcc 4.4 32-bit build
+//   on linux, we have encountered a buggy <cstdatomic>
+//   implementation.  Also, some <cstdatomic> implementations are much
+//   slower than a memory-barrier based implementation (~16ns for
+//   <cstdatomic> based acquire-load vs. ~1ns for a barrier based
+//   acquire-load).
+// This code is based on atomicops-internals-* in Google's perftools:
+// http://code.google.com/p/google-perftools/source/browse/#svn%2Ftrunk%2Fsrc%2Fbase
+
+#ifndef PORT_ATOMIC_POINTER_H_
+#define PORT_ATOMIC_POINTER_H_
+
+#include <stdint.h>
+#ifdef LEVELDB_CSTDATOMIC_PRESENT
+#include <cstdatomic>
+#endif
+#ifdef OS_WIN
+#include <windows.h>
+#endif
+#ifdef OS_MACOSX
+#include <libkern/OSAtomic.h>
+#endif
+
+#if defined(_M_X64) || defined(__x86_64__)
+#define ARCH_CPU_X86_FAMILY 1
+#elif defined(_M_IX86) || defined(__i386__) || defined(__i386)
+#define ARCH_CPU_X86_FAMILY 1
+#elif defined(__ARMEL__)
+#define ARCH_CPU_ARM_FAMILY 1
+#elif defined(__ppc__) || defined(__powerpc__) || defined(__powerpc64__)
+#define ARCH_CPU_PPC_FAMILY 1
+#endif
+
+namespace leveldb {
+namespace port {
+
+// Define MemoryBarrier() if available
+// Windows on x86
+#if defined(OS_WIN) && defined(COMPILER_MSVC) && defined(ARCH_CPU_X86_FAMILY)
+// windows.h already provides a MemoryBarrier(void) macro
+// http://msdn.microsoft.com/en-us/library/ms684208(v=vs.85).aspx
+#define LEVELDB_HAVE_MEMORY_BARRIER
+
+// Mac OS
+#elif defined(OS_MACOSX)
+inline void MemoryBarrier() {
+  OSMemoryBarrier();
+}
+#define LEVELDB_HAVE_MEMORY_BARRIER
+
+// Gcc on x86
+#elif defined(ARCH_CPU_X86_FAMILY) && defined(__GNUC__)
+inline void MemoryBarrier() {
+  // See http://gcc.gnu.org/ml/gcc/2003-04/msg01180.html for a discussion on
+  // this idiom. Also see http://en.wikipedia.org/wiki/Memory_ordering.
+  __asm__ __volatile__("" : : : "memory");
+}
+#define LEVELDB_HAVE_MEMORY_BARRIER
+
+// Sun Studio
+#elif defined(ARCH_CPU_X86_FAMILY) && defined(__SUNPRO_CC)
+inline void MemoryBarrier() {
+  // See http://gcc.gnu.org/ml/gcc/2003-04/msg01180.html for a discussion on
+  // this idiom. Also see http://en.wikipedia.org/wiki/Memory_ordering.
+  asm volatile("" : : : "memory");
+}
+#define LEVELDB_HAVE_MEMORY_BARRIER
+
+// ARM Linux
+#elif defined(ARCH_CPU_ARM_FAMILY) && defined(__linux__)
+typedef void (*LinuxKernelMemoryBarrierFunc)(void);
+// The Linux ARM kernel provides a highly optimized device-specific memory
+// barrier function at a fixed memory address that is mapped in every
+// user-level process.
+//
+// This beats using CPU-specific instructions which are, on single-core
+// devices, un-necessary and very costly (e.g. ARMv7-A "dmb" takes more
+// than 180ns on a Cortex-A8 like the one on a Nexus One). Benchmarking
+// shows that the extra function call cost is completely negligible on
+// multi-core devices.
+//
+inline void MemoryBarrier() {
+  (*(LinuxKernelMemoryBarrierFunc)0xffff0fa0)();
+}
+#define LEVELDB_HAVE_MEMORY_BARRIER
+
+// PPC
+#elif defined(ARCH_CPU_PPC_FAMILY) && defined(__GNUC__)
+inline void MemoryBarrier() {
+  // TODO for some powerpc expert: is there a cheaper suitable variant?
+  // Perhaps by having separate barriers for acquire and release ops.
+  asm volatile("sync" : : : "memory");
+}
+#define LEVELDB_HAVE_MEMORY_BARRIER
+
+#endif
+
+// AtomicPointer built using platform-specific MemoryBarrier()
+#if defined(LEVELDB_HAVE_MEMORY_BARRIER)
+class AtomicPointer {
+ private:
+  void* rep_;
+ public:
+  AtomicPointer() { }
+  explicit AtomicPointer(void* p) : rep_(p) {}
+  inline void* NoBarrier_Load() const { return rep_; }
+  inline void NoBarrier_Store(void* v) { rep_ = v; }
+  inline void* Acquire_Load() const {
+    void* result = rep_;
+    MemoryBarrier();
+    return result;
+  }
+  inline void Release_Store(void* v) {
+    MemoryBarrier();
+    rep_ = v;
+  }
+};
+
+// AtomicPointer based on <cstdatomic>
+#elif defined(LEVELDB_CSTDATOMIC_PRESENT)
+class AtomicPointer {
+ private:
+  std::atomic<void*> rep_;
+ public:
+  AtomicPointer() { }
+  explicit AtomicPointer(void* v) : rep_(v) { }
+  inline void* Acquire_Load() const {
+    return rep_.load(std::memory_order_acquire);
+  }
+  inline void Release_Store(void* v) {
+    rep_.store(v, std::memory_order_release);
+  }
+  inline void* NoBarrier_Load() const {
+    return rep_.load(std::memory_order_relaxed);
+  }
+  inline void NoBarrier_Store(void* v) {
+    rep_.store(v, std::memory_order_relaxed);
+  }
+};
+
+// Atomic pointer based on sparc memory barriers
+#elif defined(__sparcv9) && defined(__GNUC__)
+class AtomicPointer {
+ private:
+  void* rep_;
+ public:
+  AtomicPointer() { }
+  explicit AtomicPointer(void* v) : rep_(v) { }
+  inline void* Acquire_Load() const {
+    void* val;
+    __asm__ __volatile__ (
+        "ldx [%[rep_]], %[val] \n\t"
+         "membar #LoadLoad|#LoadStore \n\t"
+        : [val] "=r" (val)
+        : [rep_] "r" (&rep_)
+        : "memory");
+    return val;
+  }
+  inline void Release_Store(void* v) {
+    __asm__ __volatile__ (
+        "membar #LoadStore|#StoreStore \n\t"
+        "stx %[v], [%[rep_]] \n\t"
+        :
+        : [rep_] "r" (&rep_), [v] "r" (v)
+        : "memory");
+  }
+  inline void* NoBarrier_Load() const { return rep_; }
+  inline void NoBarrier_Store(void* v) { rep_ = v; }
+};
+
+// Atomic pointer based on ia64 acq/rel
+#elif defined(__ia64) && defined(__GNUC__)
+class AtomicPointer {
+ private:
+  void* rep_;
+ public:
+  AtomicPointer() { }
+  explicit AtomicPointer(void* v) : rep_(v) { }
+  inline void* Acquire_Load() const {
+    void* val    ;
+    __asm__ __volatile__ (
+        "ld8.acq %[val] = [%[rep_]] \n\t"
+        : [val] "=r" (val)
+        : [rep_] "r" (&rep_)
+        : "memory"
+        );
+    return val;
+  }
+  inline void Release_Store(void* v) {
+    __asm__ __volatile__ (
+        "st8.rel [%[rep_]] = %[v]  \n\t"
+        :
+        : [rep_] "r" (&rep_), [v] "r" (v)
+        : "memory"
+        );
+  }
+  inline void* NoBarrier_Load() const { return rep_; }
+  inline void NoBarrier_Store(void* v) { rep_ = v; }
+};
+
+// We have neither MemoryBarrier(), nor <cstdatomic>
+#else
+#error Please implement AtomicPointer for this platform.
+
+#endif
+
+#undef LEVELDB_HAVE_MEMORY_BARRIER
+#undef ARCH_CPU_X86_FAMILY
+#undef ARCH_CPU_ARM_FAMILY
+#undef ARCH_CPU_PPC_FAMILY
+
+}  // namespace port
+}  // namespace leveldb
+
+#endif  // PORT_ATOMIC_POINTER_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/port/port.h b/packages/LevelDB.1.16.0.5/lib/native/src/port/port.h
new file mode 100644
index 0000000..4baafa8
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/port/port.h
@@ -0,0 +1,21 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_PORT_PORT_H_
+#define STORAGE_LEVELDB_PORT_PORT_H_
+
+#include <string.h>
+
+// Include the appropriate platform specific file below.  If you are
+// porting to a new platform, see "port_example.h" for documentation
+// of what the new port_<platform>.h file must provide.
+#if defined(LEVELDB_PLATFORM_POSIX)
+#  include "port/port_posix.h"
+#elif defined(LEVELDB_PLATFORM_CHROMIUM)
+#  include "port/port_chromium.h"
+#elif defined(LEVELDB_PLATFORM_WINDOWS)
+#  include "port/port_win.h"
+#endif
+
+#endif  // STORAGE_LEVELDB_PORT_PORT_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/port/port_example.h b/packages/LevelDB.1.16.0.5/lib/native/src/port/port_example.h
new file mode 100644
index 0000000..ab9e489
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/port/port_example.h
@@ -0,0 +1,135 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// This file contains the specification, but not the implementations,
+// of the types/operations/etc. that should be defined by a platform
+// specific port_<platform>.h file.  Use this file as a reference for
+// how to port this package to a new platform.
+
+#ifndef STORAGE_LEVELDB_PORT_PORT_EXAMPLE_H_
+#define STORAGE_LEVELDB_PORT_PORT_EXAMPLE_H_
+
+namespace leveldb {
+namespace port {
+
+// TODO(jorlow): Many of these belong more in the environment class rather than
+//               here. We should try moving them and see if it affects perf.
+
+// The following boolean constant must be true on a little-endian machine
+// and false otherwise.
+static const bool kLittleEndian = true /* or some other expression */;
+
+// ------------------ Threading -------------------
+
+// A Mutex represents an exclusive lock.
+class Mutex {
+ public:
+  Mutex();
+  ~Mutex();
+
+  // Lock the mutex.  Waits until other lockers have exited.
+  // Will deadlock if the mutex is already locked by this thread.
+  void Lock();
+
+  // Unlock the mutex.
+  // REQUIRES: This mutex was locked by this thread.
+  void Unlock();
+
+  // Optionally crash if this thread does not hold this mutex.
+  // The implementation must be fast, especially if NDEBUG is
+  // defined.  The implementation is allowed to skip all checks.
+  void AssertHeld();
+};
+
+class CondVar {
+ public:
+  explicit CondVar(Mutex* mu);
+  ~CondVar();
+
+  // Atomically release *mu and block on this condition variable until
+  // either a call to SignalAll(), or a call to Signal() that picks
+  // this thread to wakeup.
+  // REQUIRES: this thread holds *mu
+  void Wait();
+
+  // If there are some threads waiting, wake up at least one of them.
+  void Signal();
+
+  // Wake up all waiting threads.
+  void SignallAll();
+};
+
+// Thread-safe initialization.
+// Used as follows:
+//      static port::OnceType init_control = LEVELDB_ONCE_INIT;
+//      static void Initializer() { ... do something ...; }
+//      ...
+//      port::InitOnce(&init_control, &Initializer);
+typedef intptr_t OnceType;
+#define LEVELDB_ONCE_INIT 0
+extern void InitOnce(port::OnceType*, void (*initializer)());
+
+// A type that holds a pointer that can be read or written atomically
+// (i.e., without word-tearing.)
+class AtomicPointer {
+ private:
+  intptr_t rep_;
+ public:
+  // Initialize to arbitrary value
+  AtomicPointer();
+
+  // Initialize to hold v
+  explicit AtomicPointer(void* v) : rep_(v) { }
+
+  // Read and return the stored pointer with the guarantee that no
+  // later memory access (read or write) by this thread can be
+  // reordered ahead of this read.
+  void* Acquire_Load() const;
+
+  // Set v as the stored pointer with the guarantee that no earlier
+  // memory access (read or write) by this thread can be reordered
+  // after this store.
+  void Release_Store(void* v);
+
+  // Read the stored pointer with no ordering guarantees.
+  void* NoBarrier_Load() const;
+
+  // Set va as the stored pointer with no ordering guarantees.
+  void NoBarrier_Store(void* v);
+};
+
+// ------------------ Compression -------------------
+
+// Store the snappy compression of "input[0,input_length-1]" in *output.
+// Returns false if snappy is not supported by this port.
+extern bool Snappy_Compress(const char* input, size_t input_length,
+                            std::string* output);
+
+// If input[0,input_length-1] looks like a valid snappy compressed
+// buffer, store the size of the uncompressed data in *result and
+// return true.  Else return false.
+extern bool Snappy_GetUncompressedLength(const char* input, size_t length,
+                                         size_t* result);
+
+// Attempt to snappy uncompress input[0,input_length-1] into *output.
+// Returns true if successful, false if the input is invalid lightweight
+// compressed data.
+//
+// REQUIRES: at least the first "n" bytes of output[] must be writable
+// where "n" is the result of a successful call to
+// Snappy_GetUncompressedLength.
+extern bool Snappy_Uncompress(const char* input_data, size_t input_length,
+                              char* output);
+
+// ------------------ Miscellaneous -------------------
+
+// If heap profiling is not supported, returns false.
+// Else repeatedly calls (*func)(arg, data, n) and then returns true.
+// The concatenation of all "data[0,n-1]" fragments is the heap profile.
+extern bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg);
+
+}  // namespace port
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_PORT_PORT_EXAMPLE_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/port/port_posix.cc b/packages/LevelDB.1.16.0.5/lib/native/src/port/port_posix.cc
new file mode 100644
index 0000000..5ba127a
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/port/port_posix.cc
@@ -0,0 +1,54 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "port/port_posix.h"
+
+#include <cstdlib>
+#include <stdio.h>
+#include <string.h>
+#include "util/logging.h"
+
+namespace leveldb {
+namespace port {
+
+static void PthreadCall(const char* label, int result) {
+  if (result != 0) {
+    fprintf(stderr, "pthread %s: %s\n", label, strerror(result));
+    abort();
+  }
+}
+
+Mutex::Mutex() { PthreadCall("init mutex", pthread_mutex_init(&mu_, NULL)); }
+
+Mutex::~Mutex() { PthreadCall("destroy mutex", pthread_mutex_destroy(&mu_)); }
+
+void Mutex::Lock() { PthreadCall("lock", pthread_mutex_lock(&mu_)); }
+
+void Mutex::Unlock() { PthreadCall("unlock", pthread_mutex_unlock(&mu_)); }
+
+CondVar::CondVar(Mutex* mu)
+    : mu_(mu) {
+    PthreadCall("init cv", pthread_cond_init(&cv_, NULL));
+}
+
+CondVar::~CondVar() { PthreadCall("destroy cv", pthread_cond_destroy(&cv_)); }
+
+void CondVar::Wait() {
+  PthreadCall("wait", pthread_cond_wait(&cv_, &mu_->mu_));
+}
+
+void CondVar::Signal() {
+  PthreadCall("signal", pthread_cond_signal(&cv_));
+}
+
+void CondVar::SignalAll() {
+  PthreadCall("broadcast", pthread_cond_broadcast(&cv_));
+}
+
+void InitOnce(OnceType* once, void (*initializer)()) {
+  PthreadCall("once", pthread_once(once, initializer));
+}
+
+}  // namespace port
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/port/port_posix.h b/packages/LevelDB.1.16.0.5/lib/native/src/port/port_posix.h
new file mode 100644
index 0000000..f2b89bf
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/port/port_posix.h
@@ -0,0 +1,157 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// See port_example.h for documentation for the following types/functions.
+
+#ifndef STORAGE_LEVELDB_PORT_PORT_POSIX_H_
+#define STORAGE_LEVELDB_PORT_PORT_POSIX_H_
+
+#undef PLATFORM_IS_LITTLE_ENDIAN
+#if defined(OS_MACOSX)
+  #include <machine/endian.h>
+  #if defined(__DARWIN_LITTLE_ENDIAN) && defined(__DARWIN_BYTE_ORDER)
+    #define PLATFORM_IS_LITTLE_ENDIAN \
+        (__DARWIN_BYTE_ORDER == __DARWIN_LITTLE_ENDIAN)
+  #endif
+#elif defined(OS_SOLARIS)
+  #include <sys/isa_defs.h>
+  #ifdef _LITTLE_ENDIAN
+    #define PLATFORM_IS_LITTLE_ENDIAN true
+  #else
+    #define PLATFORM_IS_LITTLE_ENDIAN false
+  #endif
+#elif defined(OS_FREEBSD)
+  #include <sys/types.h>
+  #include <sys/endian.h>
+  #define PLATFORM_IS_LITTLE_ENDIAN (_BYTE_ORDER == _LITTLE_ENDIAN)
+#elif defined(OS_OPENBSD) || defined(OS_NETBSD) ||\
+      defined(OS_DRAGONFLYBSD)
+  #include <sys/types.h>
+  #include <sys/endian.h>
+#elif defined(OS_HPUX)
+  #define PLATFORM_IS_LITTLE_ENDIAN false
+#elif defined(OS_ANDROID)
+  // Due to a bug in the NDK x86 <sys/endian.h> definition,
+  // _BYTE_ORDER must be used instead of __BYTE_ORDER on Android.
+  // See http://code.google.com/p/android/issues/detail?id=39824
+  #include <endian.h>
+  #define PLATFORM_IS_LITTLE_ENDIAN  (_BYTE_ORDER == _LITTLE_ENDIAN)
+#else
+  #include <endian.h>
+#endif
+
+#include <pthread.h>
+#ifdef SNAPPY
+#include <snappy.h>
+#endif
+#include <stdint.h>
+#include <string>
+#include "port/atomic_pointer.h"
+
+#ifndef PLATFORM_IS_LITTLE_ENDIAN
+#define PLATFORM_IS_LITTLE_ENDIAN (__BYTE_ORDER == __LITTLE_ENDIAN)
+#endif
+
+#if defined(OS_MACOSX) || defined(OS_SOLARIS) || defined(OS_FREEBSD) ||\
+    defined(OS_NETBSD) || defined(OS_OPENBSD) || defined(OS_DRAGONFLYBSD) ||\
+    defined(OS_ANDROID) || defined(OS_HPUX)
+// Use fread/fwrite/fflush on platforms without _unlocked variants
+#define fread_unlocked fread
+#define fwrite_unlocked fwrite
+#define fflush_unlocked fflush
+#endif
+
+#if defined(OS_MACOSX) || defined(OS_FREEBSD) ||\
+    defined(OS_OPENBSD) || defined(OS_DRAGONFLYBSD)
+// Use fsync() on platforms without fdatasync()
+#define fdatasync fsync
+#endif
+
+#if defined(OS_ANDROID) && __ANDROID_API__ < 9
+// fdatasync() was only introduced in API level 9 on Android. Use fsync()
+// when targetting older platforms.
+#define fdatasync fsync
+#endif
+
+namespace leveldb {
+namespace port {
+
+static const bool kLittleEndian = PLATFORM_IS_LITTLE_ENDIAN;
+#undef PLATFORM_IS_LITTLE_ENDIAN
+
+class CondVar;
+
+class Mutex {
+ public:
+  Mutex();
+  ~Mutex();
+
+  void Lock();
+  void Unlock();
+  void AssertHeld() { }
+
+ private:
+  friend class CondVar;
+  pthread_mutex_t mu_;
+
+  // No copying
+  Mutex(const Mutex&);
+  void operator=(const Mutex&);
+};
+
+class CondVar {
+ public:
+  explicit CondVar(Mutex* mu);
+  ~CondVar();
+  void Wait();
+  void Signal();
+  void SignalAll();
+ private:
+  pthread_cond_t cv_;
+  Mutex* mu_;
+};
+
+typedef pthread_once_t OnceType;
+#define LEVELDB_ONCE_INIT PTHREAD_ONCE_INIT
+extern void InitOnce(OnceType* once, void (*initializer)());
+
+inline bool Snappy_Compress(const char* input, size_t length,
+                            ::std::string* output) {
+#ifdef SNAPPY
+  output->resize(snappy::MaxCompressedLength(length));
+  size_t outlen;
+  snappy::RawCompress(input, length, &(*output)[0], &outlen);
+  output->resize(outlen);
+  return true;
+#endif
+
+  return false;
+}
+
+inline bool Snappy_GetUncompressedLength(const char* input, size_t length,
+                                         size_t* result) {
+#ifdef SNAPPY
+  return snappy::GetUncompressedLength(input, length, result);
+#else
+  return false;
+#endif
+}
+
+inline bool Snappy_Uncompress(const char* input, size_t length,
+                              char* output) {
+#ifdef SNAPPY
+  return snappy::RawUncompress(input, length, output);
+#else
+  return false;
+#endif
+}
+
+inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {
+  return false;
+}
+
+} // namespace port
+} // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_PORT_PORT_POSIX_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/port/port_win.cc b/packages/LevelDB.1.16.0.5/lib/native/src/port/port_win.cc
new file mode 100644
index 0000000..6caf822
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/port/port_win.cc
@@ -0,0 +1,134 @@
+// LevelDB Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// See port_example.h for documentation for the following types/functions.
+
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//  * Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+//  * Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+//  * Neither the name of the University of California, Berkeley nor the
+//    names of its contributors may be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
+// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+
+#include "port/port_win.h"
+
+#define NOMINMAX
+#include <windows.h>
+#undef DeleteFile
+#include <cassert>
+
+namespace leveldb {
+namespace port {
+
+Mutex::Mutex() :
+    cs_(nullptr) {
+  assert(!cs_);
+  cs_ = static_cast<void *>(new CRITICAL_SECTION());
+  ::InitializeCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));
+  assert(cs_);
+}
+
+Mutex::~Mutex() {
+  assert(cs_);
+  ::DeleteCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));
+  delete static_cast<CRITICAL_SECTION *>(cs_);
+  cs_ = nullptr;
+  assert(!cs_);
+}
+
+void Mutex::Lock() {
+  assert(cs_);
+  ::EnterCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));
+}
+
+void Mutex::Unlock() {
+  assert(cs_);
+  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));
+}
+
+void Mutex::AssertHeld() {
+  assert(cs_);
+  assert(1);
+}
+
+CondVar::CondVar(Mutex* mu) :
+    waiting_(0), 
+    mu_(mu), 
+    sem1_(::CreateSemaphore(NULL, 0, 10000, NULL)), 
+    sem2_(::CreateSemaphore(NULL, 0, 10000, NULL)) {
+  assert(mu_);
+}
+
+CondVar::~CondVar() {
+  ::CloseHandle(sem1_);
+  ::CloseHandle(sem2_);
+}
+
+void CondVar::Wait() {
+  mu_->AssertHeld();
+
+  wait_mtx_.Lock();
+  ++waiting_;
+  wait_mtx_.Unlock();
+
+  mu_->Unlock();
+
+  // initiate handshake
+  ::WaitForSingleObject(sem1_, INFINITE);
+  ::ReleaseSemaphore(sem2_, 1, NULL);
+  mu_->Lock();
+}
+
+void CondVar::Signal() {
+  wait_mtx_.Lock();
+  if (waiting_ > 0) {
+    --waiting_;
+
+    // finalize handshake
+    ::ReleaseSemaphore(sem1_, 1, NULL);
+    ::WaitForSingleObject(sem2_, INFINITE);
+  }
+  wait_mtx_.Unlock();
+}
+
+void CondVar::SignalAll() {
+  wait_mtx_.Lock();
+  for(long i = 0; i < waiting_; ++i) {
+    ::ReleaseSemaphore(sem1_, 1, NULL);
+    while(waiting_ > 0) {
+      --waiting_;
+      ::WaitForSingleObject(sem2_, INFINITE);
+    }
+  }
+  wait_mtx_.Unlock();
+}
+
+BOOL CALLBACK InitHandleFunction (PINIT_ONCE InitOnce, PVOID func, PVOID *lpContext) {
+  ((void (*)())func)();
+  return true;
+}
+
+void InitOnce(OnceType* once, void (*initializer)()) {
+  InitOnceExecuteOnce((PINIT_ONCE)once, InitHandleFunction, initializer, NULL);
+}
+
+}
+}
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/port/port_win.h b/packages/LevelDB.1.16.0.5/lib/native/src/port/port_win.h
new file mode 100644
index 0000000..0e2ba53
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/port/port_win.h
@@ -0,0 +1,162 @@
+// LevelDB Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// See port_example.h for documentation for the following types/functions.
+
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 
+//  * Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+//  * Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+//  * Neither the name of the University of California, Berkeley nor the
+//    names of its contributors may be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
+// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+// DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY
+// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+
+#ifndef STORAGE_LEVELDB_PORT_PORT_WIN_H_
+#define STORAGE_LEVELDB_PORT_PORT_WIN_H_
+
+#define snprintf _snprintf
+#define close _close
+#define fread_unlocked _fread_nolock
+
+#include <string>
+#include <stdint.h>
+#include <atomic>
+#ifdef LEVELDB_WITH_SNAPPY
+#include <snappy.h>
+#endif
+
+typedef ptrdiff_t ssize_t;
+
+namespace leveldb {
+namespace port {
+
+// Windows is little endian (for now :p)
+static const bool kLittleEndian = true;
+
+class CondVar;
+
+class Mutex {
+ public:
+  Mutex();
+  ~Mutex();
+
+  void Lock();
+  void Unlock();
+  void AssertHeld();
+
+ private:
+  friend class CondVar;
+  // critical sections are more efficient than mutexes
+  // but they are not recursive and can only be used to synchronize threads within the same process
+  // we use opaque void * to avoid including windows.h in port_win.h
+  void * cs_;
+
+  // No copying
+  Mutex(const Mutex&);
+  void operator=(const Mutex&);
+};
+
+// the Win32 API offers a dependable condition variable mechanism, but only starting with
+// Windows 2008 and Vista
+// no matter what we will implement our own condition variable with a semaphore
+// implementation as described in a paper written by Andrew D. Birrell in 2003
+class CondVar {
+ public:
+  explicit CondVar(Mutex* mu);
+  ~CondVar();
+  void Wait();
+  void Signal();
+  void SignalAll();
+ private:
+  Mutex* mu_;
+  
+  Mutex wait_mtx_;
+  long waiting_;
+  
+  void * sem1_;
+  void * sem2_;
+  
+  
+};
+
+typedef void* OnceType;
+#define LEVELDB_ONCE_INIT 0
+extern void InitOnce(port::OnceType*, void (*initializer)());
+
+// Storage for a lock-free pointer
+class AtomicPointer {
+ private:
+  std::atomic<void *> rep_;
+ public:
+  AtomicPointer() { }
+  explicit AtomicPointer(void* v) : rep_(v) { }
+  inline void* Acquire_Load() const {
+    return rep_.load(std::memory_order_acquire);
+  }
+  inline void Release_Store(void* v) {
+    rep_.store(v, std::memory_order_release);
+  }
+  inline void* NoBarrier_Load() const {
+    return rep_.load(std::memory_order_relaxed);
+  }
+  inline void NoBarrier_Store(void* v) {
+    rep_.store(v, std::memory_order_relaxed);
+  }
+};
+
+inline bool Snappy_Compress(const char* input, size_t length,
+                            ::std::string* output) {
+#ifdef LEVELDB_WITH_SNAPPY
+  output->resize(snappy::MaxCompressedLength(length));
+  size_t outlen;
+  snappy::RawCompress(input, length, &(*output)[0], &outlen);
+  output->resize(outlen);
+  return true;
+#endif
+
+  return false;
+}
+
+inline bool Snappy_GetUncompressedLength(const char* input, size_t length,
+                                         size_t* result) {
+#ifdef LEVELDB_WITH_SNAPPY
+  return snappy::GetUncompressedLength(input, length, result);
+#else
+  return false;
+#endif
+}
+
+inline bool Snappy_Uncompress(const char* input, size_t length,
+                              char* output) {
+#ifdef LEVELDB_WITH_SNAPPY
+  return snappy::RawUncompress(input, length, output);
+#else
+  return false;
+#endif
+}
+
+inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {
+  return false;
+}
+
+}
+}
+
+#endif  // STORAGE_LEVELDB_PORT_PORT_WIN_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/port/thread_annotations.h b/packages/LevelDB.1.16.0.5/lib/native/src/port/thread_annotations.h
new file mode 100644
index 0000000..6f9b6a7
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/port/thread_annotations.h
@@ -0,0 +1,59 @@
+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_PORT_THREAD_ANNOTATIONS_H
+
+// Some environments provide custom macros to aid in static thread-safety
+// analysis.  Provide empty definitions of such macros unless they are already
+// defined.
+
+#ifndef EXCLUSIVE_LOCKS_REQUIRED
+#define EXCLUSIVE_LOCKS_REQUIRED(...)
+#endif
+
+#ifndef SHARED_LOCKS_REQUIRED
+#define SHARED_LOCKS_REQUIRED(...)
+#endif
+
+#ifndef LOCKS_EXCLUDED
+#define LOCKS_EXCLUDED(...)
+#endif
+
+#ifndef LOCK_RETURNED
+#define LOCK_RETURNED(x)
+#endif
+
+#ifndef LOCKABLE
+#define LOCKABLE
+#endif
+
+#ifndef SCOPED_LOCKABLE
+#define SCOPED_LOCKABLE
+#endif
+
+#ifndef EXCLUSIVE_LOCK_FUNCTION
+#define EXCLUSIVE_LOCK_FUNCTION(...)
+#endif
+
+#ifndef SHARED_LOCK_FUNCTION
+#define SHARED_LOCK_FUNCTION(...)
+#endif
+
+#ifndef EXCLUSIVE_TRYLOCK_FUNCTION
+#define EXCLUSIVE_TRYLOCK_FUNCTION(...)
+#endif
+
+#ifndef SHARED_TRYLOCK_FUNCTION
+#define SHARED_TRYLOCK_FUNCTION(...)
+#endif
+
+#ifndef UNLOCK_FUNCTION
+#define UNLOCK_FUNCTION(...)
+#endif
+
+#ifndef NO_THREAD_SAFETY_ANALYSIS
+#define NO_THREAD_SAFETY_ANALYSIS
+#endif
+
+#endif  // STORAGE_LEVELDB_PORT_THREAD_ANNOTATIONS_H
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/port/win/crc32c_win.cc b/packages/LevelDB.1.16.0.5/lib/native/src/port/win/crc32c_win.cc
new file mode 100644
index 0000000..5d88e96
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/port/win/crc32c_win.cc
@@ -0,0 +1,13 @@
+#include <stdint.h>
+#include "crc32c.h"
+
+namespace leveldb {
+namespace crc32c {
+
+uint32_t Extend(uint32_t init_crc, const char* data, size_t n)
+{
+    return crc32c_append(init_crc, (const unsigned char *)data, n);
+}
+
+}  // namespace crc32c
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/port/win/unistd.h b/packages/LevelDB.1.16.0.5/lib/native/src/port/win/unistd.h
new file mode 100644
index 0000000..e69de29
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/block.cc b/packages/LevelDB.1.16.0.5/lib/native/src/table/block.cc
new file mode 100644
index 0000000..79ea9d9
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/block.cc
@@ -0,0 +1,268 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// Decodes the blocks generated by block_builder.cc.
+
+#include "table/block.h"
+
+#include <vector>
+#include <algorithm>
+#include "leveldb/comparator.h"
+#include "table/format.h"
+#include "util/coding.h"
+#include "util/logging.h"
+
+namespace leveldb {
+
+inline uint32_t Block::NumRestarts() const {
+  assert(size_ >= sizeof(uint32_t));
+  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
+}
+
+Block::Block(const BlockContents& contents)
+    : data_(contents.data.data()),
+      size_(contents.data.size()),
+      owned_(contents.heap_allocated) {
+  if (size_ < sizeof(uint32_t)) {
+    size_ = 0;  // Error marker
+  } else {
+    size_t max_restarts_allowed = (size_-sizeof(uint32_t)) / sizeof(uint32_t);
+    if (NumRestarts() > max_restarts_allowed) {
+      // The size is too small for NumRestarts()
+      size_ = 0;
+    } else {
+      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
+    }
+  }
+}
+
+Block::~Block() {
+  if (owned_) {
+    delete[] data_;
+  }
+}
+
+// Helper routine: decode the next block entry starting at "p",
+// storing the number of shared key bytes, non_shared key bytes,
+// and the length of the value in "*shared", "*non_shared", and
+// "*value_length", respectively.  Will not derefence past "limit".
+//
+// If any errors are detected, returns NULL.  Otherwise, returns a
+// pointer to the key delta (just past the three decoded values).
+static inline const char* DecodeEntry(const char* p, const char* limit,
+                                      uint32_t* shared,
+                                      uint32_t* non_shared,
+                                      uint32_t* value_length) {
+  if (limit - p < 3) return NULL;
+  *shared = reinterpret_cast<const unsigned char*>(p)[0];
+  *non_shared = reinterpret_cast<const unsigned char*>(p)[1];
+  *value_length = reinterpret_cast<const unsigned char*>(p)[2];
+  if ((*shared | *non_shared | *value_length) < 128) {
+    // Fast path: all three values are encoded in one byte each
+    p += 3;
+  } else {
+    if ((p = GetVarint32Ptr(p, limit, shared)) == NULL) return NULL;
+    if ((p = GetVarint32Ptr(p, limit, non_shared)) == NULL) return NULL;
+    if ((p = GetVarint32Ptr(p, limit, value_length)) == NULL) return NULL;
+  }
+
+  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
+    return NULL;
+  }
+  return p;
+}
+
+class Block::Iter : public Iterator {
+ private:
+  const Comparator* const comparator_;
+  const char* const data_;      // underlying block contents
+  uint32_t const restarts_;     // Offset of restart array (list of fixed32)
+  uint32_t const num_restarts_; // Number of uint32_t entries in restart array
+
+  // current_ is offset in data_ of current entry.  >= restarts_ if !Valid
+  uint32_t current_;
+  uint32_t restart_index_;  // Index of restart block in which current_ falls
+  std::string key_;
+  Slice value_;
+  Status status_;
+
+  inline int Compare(const Slice& a, const Slice& b) const {
+    return comparator_->Compare(a, b);
+  }
+
+  // Return the offset in data_ just past the end of the current entry.
+  inline uint32_t NextEntryOffset() const {
+    return (value_.data() + value_.size()) - data_;
+  }
+
+  uint32_t GetRestartPoint(uint32_t index) {
+    assert(index < num_restarts_);
+    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
+  }
+
+  void SeekToRestartPoint(uint32_t index) {
+    key_.clear();
+    restart_index_ = index;
+    // current_ will be fixed by ParseNextKey();
+
+    // ParseNextKey() starts at the end of value_, so set value_ accordingly
+    uint32_t offset = GetRestartPoint(index);
+    value_ = Slice(data_ + offset, 0);
+  }
+
+ public:
+  Iter(const Comparator* comparator,
+       const char* data,
+       uint32_t restarts,
+       uint32_t num_restarts)
+      : comparator_(comparator),
+        data_(data),
+        restarts_(restarts),
+        num_restarts_(num_restarts),
+        current_(restarts_),
+        restart_index_(num_restarts_) {
+    assert(num_restarts_ > 0);
+  }
+
+  virtual bool Valid() const { return current_ < restarts_; }
+  virtual Status status() const { return status_; }
+  virtual Slice key() const {
+    assert(Valid());
+    return key_;
+  }
+  virtual Slice value() const {
+    assert(Valid());
+    return value_;
+  }
+
+  virtual void Next() {
+    assert(Valid());
+    ParseNextKey();
+  }
+
+  virtual void Prev() {
+    assert(Valid());
+
+    // Scan backwards to a restart point before current_
+    const uint32_t original = current_;
+    while (GetRestartPoint(restart_index_) >= original) {
+      if (restart_index_ == 0) {
+        // No more entries
+        current_ = restarts_;
+        restart_index_ = num_restarts_;
+        return;
+      }
+      restart_index_--;
+    }
+
+    SeekToRestartPoint(restart_index_);
+    do {
+      // Loop until end of current entry hits the start of original entry
+    } while (ParseNextKey() && NextEntryOffset() < original);
+  }
+
+  virtual void Seek(const Slice& target) {
+    // Binary search in restart array to find the last restart point
+    // with a key < target
+    uint32_t left = 0;
+    uint32_t right = num_restarts_ - 1;
+    while (left < right) {
+      uint32_t mid = (left + right + 1) / 2;
+      uint32_t region_offset = GetRestartPoint(mid);
+      uint32_t shared, non_shared, value_length;
+      const char* key_ptr = DecodeEntry(data_ + region_offset,
+                                        data_ + restarts_,
+                                        &shared, &non_shared, &value_length);
+      if (key_ptr == NULL || (shared != 0)) {
+        CorruptionError();
+        return;
+      }
+      Slice mid_key(key_ptr, non_shared);
+      if (Compare(mid_key, target) < 0) {
+        // Key at "mid" is smaller than "target".  Therefore all
+        // blocks before "mid" are uninteresting.
+        left = mid;
+      } else {
+        // Key at "mid" is >= "target".  Therefore all blocks at or
+        // after "mid" are uninteresting.
+        right = mid - 1;
+      }
+    }
+
+    // Linear search (within restart block) for first key >= target
+    SeekToRestartPoint(left);
+    while (true) {
+      if (!ParseNextKey()) {
+        return;
+      }
+      if (Compare(key_, target) >= 0) {
+        return;
+      }
+    }
+  }
+
+  virtual void SeekToFirst() {
+    SeekToRestartPoint(0);
+    ParseNextKey();
+  }
+
+  virtual void SeekToLast() {
+    SeekToRestartPoint(num_restarts_ - 1);
+    while (ParseNextKey() && NextEntryOffset() < restarts_) {
+      // Keep skipping
+    }
+  }
+
+ private:
+  void CorruptionError() {
+    current_ = restarts_;
+    restart_index_ = num_restarts_;
+    status_ = Status::Corruption("bad entry in block");
+    key_.clear();
+    value_.clear();
+  }
+
+  bool ParseNextKey() {
+    current_ = NextEntryOffset();
+    const char* p = data_ + current_;
+    const char* limit = data_ + restarts_;  // Restarts come right after data
+    if (p >= limit) {
+      // No more entries to return.  Mark as invalid.
+      current_ = restarts_;
+      restart_index_ = num_restarts_;
+      return false;
+    }
+
+    // Decode next entry
+    uint32_t shared, non_shared, value_length;
+    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
+    if (p == NULL || key_.size() < shared) {
+      CorruptionError();
+      return false;
+    } else {
+      key_.resize(shared);
+      key_.append(p, non_shared);
+      value_ = Slice(p + non_shared, value_length);
+      while (restart_index_ + 1 < num_restarts_ &&
+             GetRestartPoint(restart_index_ + 1) < current_) {
+        ++restart_index_;
+      }
+      return true;
+    }
+  }
+};
+
+Iterator* Block::NewIterator(const Comparator* cmp) {
+  if (size_ < sizeof(uint32_t)) {
+    return NewErrorIterator(Status::Corruption("bad block contents"));
+  }
+  const uint32_t num_restarts = NumRestarts();
+  if (num_restarts == 0) {
+    return NewEmptyIterator();
+  } else {
+    return new Iter(cmp, data_, restart_offset_, num_restarts);
+  }
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/block.h b/packages/LevelDB.1.16.0.5/lib/native/src/table/block.h
new file mode 100644
index 0000000..2493eb9
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/block.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_TABLE_BLOCK_H_
+#define STORAGE_LEVELDB_TABLE_BLOCK_H_
+
+#include <stddef.h>
+#include <stdint.h>
+#include "leveldb/iterator.h"
+
+namespace leveldb {
+
+struct BlockContents;
+class Comparator;
+
+class Block {
+ public:
+  // Initialize the block with the specified contents.
+  explicit Block(const BlockContents& contents);
+
+  ~Block();
+
+  size_t size() const { return size_; }
+  Iterator* NewIterator(const Comparator* comparator);
+
+ private:
+  uint32_t NumRestarts() const;
+
+  const char* data_;
+  size_t size_;
+  uint32_t restart_offset_;     // Offset in data_ of restart array
+  bool owned_;                  // Block owns data_[]
+
+  // No copying allowed
+  Block(const Block&);
+  void operator=(const Block&);
+
+  class Iter;
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_TABLE_BLOCK_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/block_builder.cc b/packages/LevelDB.1.16.0.5/lib/native/src/table/block_builder.cc
new file mode 100644
index 0000000..db660cd
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/block_builder.cc
@@ -0,0 +1,109 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// BlockBuilder generates blocks where keys are prefix-compressed:
+//
+// When we store a key, we drop the prefix shared with the previous
+// string.  This helps reduce the space requirement significantly.
+// Furthermore, once every K keys, we do not apply the prefix
+// compression and store the entire key.  We call this a "restart
+// point".  The tail end of the block stores the offsets of all of the
+// restart points, and can be used to do a binary search when looking
+// for a particular key.  Values are stored as-is (without compression)
+// immediately following the corresponding key.
+//
+// An entry for a particular key-value pair has the form:
+//     shared_bytes: varint32
+//     unshared_bytes: varint32
+//     value_length: varint32
+//     key_delta: char[unshared_bytes]
+//     value: char[value_length]
+// shared_bytes == 0 for restart points.
+//
+// The trailer of the block has the form:
+//     restarts: uint32[num_restarts]
+//     num_restarts: uint32
+// restarts[i] contains the offset within the block of the ith restart point.
+
+#include "table/block_builder.h"
+
+#include <algorithm>
+#include <assert.h>
+#include "leveldb/comparator.h"
+#include "leveldb/table_builder.h"
+#include "util/coding.h"
+
+namespace leveldb {
+
+BlockBuilder::BlockBuilder(const Options* options)
+    : options_(options),
+      restarts_(),
+      counter_(0),
+      finished_(false) {
+  assert(options->block_restart_interval >= 1);
+  restarts_.push_back(0);       // First restart point is at offset 0
+}
+
+void BlockBuilder::Reset() {
+  buffer_.clear();
+  restarts_.clear();
+  restarts_.push_back(0);       // First restart point is at offset 0
+  counter_ = 0;
+  finished_ = false;
+  last_key_.clear();
+}
+
+size_t BlockBuilder::CurrentSizeEstimate() const {
+  return (buffer_.size() +                        // Raw data buffer
+          restarts_.size() * sizeof(uint32_t) +   // Restart array
+          sizeof(uint32_t));                      // Restart array length
+}
+
+Slice BlockBuilder::Finish() {
+  // Append restart array
+  for (size_t i = 0; i < restarts_.size(); i++) {
+    PutFixed32(&buffer_, restarts_[i]);
+  }
+  PutFixed32(&buffer_, restarts_.size());
+  finished_ = true;
+  return Slice(buffer_);
+}
+
+void BlockBuilder::Add(const Slice& key, const Slice& value) {
+  Slice last_key_piece(last_key_);
+  assert(!finished_);
+  assert(counter_ <= options_->block_restart_interval);
+  assert(buffer_.empty() // No values yet?
+         || options_->comparator->Compare(key, last_key_piece) > 0);
+  size_t shared = 0;
+  if (counter_ < options_->block_restart_interval) {
+    // See how much sharing to do with previous string
+    const size_t min_length = std::min(last_key_piece.size(), key.size());
+    while ((shared < min_length) && (last_key_piece[shared] == key[shared])) {
+      shared++;
+    }
+  } else {
+    // Restart compression
+    restarts_.push_back(buffer_.size());
+    counter_ = 0;
+  }
+  const size_t non_shared = key.size() - shared;
+
+  // Add "<shared><non_shared><value_size>" to buffer_
+  PutVarint32(&buffer_, shared);
+  PutVarint32(&buffer_, non_shared);
+  PutVarint32(&buffer_, value.size());
+
+  // Add string delta to buffer_ followed by value
+  buffer_.append(key.data() + shared, non_shared);
+  buffer_.append(value.data(), value.size());
+
+  // Update state
+  last_key_.resize(shared);
+  last_key_.append(key.data() + shared, non_shared);
+  assert(Slice(last_key_) == key);
+  counter_++;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/block_builder.h b/packages/LevelDB.1.16.0.5/lib/native/src/table/block_builder.h
new file mode 100644
index 0000000..5b545bd
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/block_builder.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_TABLE_BLOCK_BUILDER_H_
+#define STORAGE_LEVELDB_TABLE_BLOCK_BUILDER_H_
+
+#include <vector>
+
+#include <stdint.h>
+#include "leveldb/slice.h"
+
+namespace leveldb {
+
+struct Options;
+
+class BlockBuilder {
+ public:
+  explicit BlockBuilder(const Options* options);
+
+  // Reset the contents as if the BlockBuilder was just constructed.
+  void Reset();
+
+  // REQUIRES: Finish() has not been callled since the last call to Reset().
+  // REQUIRES: key is larger than any previously added key
+  void Add(const Slice& key, const Slice& value);
+
+  // Finish building the block and return a slice that refers to the
+  // block contents.  The returned slice will remain valid for the
+  // lifetime of this builder or until Reset() is called.
+  Slice Finish();
+
+  // Returns an estimate of the current (uncompressed) size of the block
+  // we are building.
+  size_t CurrentSizeEstimate() const;
+
+  // Return true iff no entries have been added since the last Reset()
+  bool empty() const {
+    return buffer_.empty();
+  }
+
+ private:
+  const Options*        options_;
+  std::string           buffer_;      // Destination buffer
+  std::vector<uint32_t> restarts_;    // Restart points
+  int                   counter_;     // Number of entries emitted since restart
+  bool                  finished_;    // Has Finish() been called?
+  std::string           last_key_;
+
+  // No copying allowed
+  BlockBuilder(const BlockBuilder&);
+  void operator=(const BlockBuilder&);
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_TABLE_BLOCK_BUILDER_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/filter_block.cc b/packages/LevelDB.1.16.0.5/lib/native/src/table/filter_block.cc
new file mode 100644
index 0000000..203e15c
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/filter_block.cc
@@ -0,0 +1,111 @@
+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "table/filter_block.h"
+
+#include "leveldb/filter_policy.h"
+#include "util/coding.h"
+
+namespace leveldb {
+
+// See doc/table_format.txt for an explanation of the filter block format.
+
+// Generate new filter every 2KB of data
+static const size_t kFilterBaseLg = 11;
+static const size_t kFilterBase = 1 << kFilterBaseLg;
+
+FilterBlockBuilder::FilterBlockBuilder(const FilterPolicy* policy)
+    : policy_(policy) {
+}
+
+void FilterBlockBuilder::StartBlock(uint64_t block_offset) {
+  uint64_t filter_index = (block_offset / kFilterBase);
+  assert(filter_index >= filter_offsets_.size());
+  while (filter_index > filter_offsets_.size()) {
+    GenerateFilter();
+  }
+}
+
+void FilterBlockBuilder::AddKey(const Slice& key) {
+  Slice k = key;
+  start_.push_back(keys_.size());
+  keys_.append(k.data(), k.size());
+}
+
+Slice FilterBlockBuilder::Finish() {
+  if (!start_.empty()) {
+    GenerateFilter();
+  }
+
+  // Append array of per-filter offsets
+  const uint32_t array_offset = result_.size();
+  for (size_t i = 0; i < filter_offsets_.size(); i++) {
+    PutFixed32(&result_, filter_offsets_[i]);
+  }
+
+  PutFixed32(&result_, array_offset);
+  result_.push_back(kFilterBaseLg);  // Save encoding parameter in result
+  return Slice(result_);
+}
+
+void FilterBlockBuilder::GenerateFilter() {
+  const size_t num_keys = start_.size();
+  if (num_keys == 0) {
+    // Fast path if there are no keys for this filter
+    filter_offsets_.push_back(result_.size());
+    return;
+  }
+
+  // Make list of keys from flattened key structure
+  start_.push_back(keys_.size());  // Simplify length computation
+  tmp_keys_.resize(num_keys);
+  for (size_t i = 0; i < num_keys; i++) {
+    const char* base = keys_.data() + start_[i];
+    size_t length = start_[i+1] - start_[i];
+    tmp_keys_[i] = Slice(base, length);
+  }
+
+  // Generate filter for current set of keys and append to result_.
+  filter_offsets_.push_back(result_.size());
+  policy_->CreateFilter(&tmp_keys_[0], num_keys, &result_);
+
+  tmp_keys_.clear();
+  keys_.clear();
+  start_.clear();
+}
+
+FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,
+                                     const Slice& contents)
+    : policy_(policy),
+      data_(NULL),
+      offset_(NULL),
+      num_(0),
+      base_lg_(0) {
+  size_t n = contents.size();
+  if (n < 5) return;  // 1 byte for base_lg_ and 4 for start of offset array
+  base_lg_ = contents[n-1];
+  uint32_t last_word = DecodeFixed32(contents.data() + n - 5);
+  if (last_word > n - 5) return;
+  data_ = contents.data();
+  offset_ = data_ + last_word;
+  num_ = (n - 5 - last_word) / 4;
+}
+
+bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice& key) {
+  uint64_t index = block_offset >> base_lg_;
+  if (index < num_) {
+    uint32_t start = DecodeFixed32(offset_ + index*4);
+    uint32_t limit = DecodeFixed32(offset_ + index*4 + 4);
+    if (start <= limit && limit <= (offset_ - data_)) {
+      Slice filter = Slice(data_ + start, limit - start);
+      return policy_->KeyMayMatch(key, filter);
+    } else if (start == limit) {
+      // Empty filters do not match any keys
+      return false;
+    }
+  }
+  return true;  // Errors are treated as potential matches
+}
+
+}
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/filter_block.h b/packages/LevelDB.1.16.0.5/lib/native/src/table/filter_block.h
new file mode 100644
index 0000000..c67d010
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/filter_block.h
@@ -0,0 +1,68 @@
+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// A filter block is stored near the end of a Table file.  It contains
+// filters (e.g., bloom filters) for all data blocks in the table combined
+// into a single filter block.
+
+#ifndef STORAGE_LEVELDB_TABLE_FILTER_BLOCK_H_
+#define STORAGE_LEVELDB_TABLE_FILTER_BLOCK_H_
+
+#include <stddef.h>
+#include <stdint.h>
+#include <string>
+#include <vector>
+#include "leveldb/slice.h"
+#include "util/hash.h"
+
+namespace leveldb {
+
+class FilterPolicy;
+
+// A FilterBlockBuilder is used to construct all of the filters for a
+// particular Table.  It generates a single string which is stored as
+// a special block in the Table.
+//
+// The sequence of calls to FilterBlockBuilder must match the regexp:
+//      (StartBlock AddKey*)* Finish
+class FilterBlockBuilder {
+ public:
+  explicit FilterBlockBuilder(const FilterPolicy*);
+
+  void StartBlock(uint64_t block_offset);
+  void AddKey(const Slice& key);
+  Slice Finish();
+
+ private:
+  void GenerateFilter();
+
+  const FilterPolicy* policy_;
+  std::string keys_;              // Flattened key contents
+  std::vector<size_t> start_;     // Starting index in keys_ of each key
+  std::string result_;            // Filter data computed so far
+  std::vector<Slice> tmp_keys_;   // policy_->CreateFilter() argument
+  std::vector<uint32_t> filter_offsets_;
+
+  // No copying allowed
+  FilterBlockBuilder(const FilterBlockBuilder&);
+  void operator=(const FilterBlockBuilder&);
+};
+
+class FilterBlockReader {
+ public:
+ // REQUIRES: "contents" and *policy must stay live while *this is live.
+  FilterBlockReader(const FilterPolicy* policy, const Slice& contents);
+  bool KeyMayMatch(uint64_t block_offset, const Slice& key);
+
+ private:
+  const FilterPolicy* policy_;
+  const char* data_;    // Pointer to filter data (at block-start)
+  const char* offset_;  // Pointer to beginning of offset array (at block-end)
+  size_t num_;          // Number of entries in offset array
+  size_t base_lg_;      // Encoding parameter (see kFilterBaseLg in .cc file)
+};
+
+}
+
+#endif  // STORAGE_LEVELDB_TABLE_FILTER_BLOCK_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/format.cc b/packages/LevelDB.1.16.0.5/lib/native/src/table/format.cc
new file mode 100644
index 0000000..cda1dec
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/format.cc
@@ -0,0 +1,145 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "table/format.h"
+
+#include "leveldb/env.h"
+#include "port/port.h"
+#include "table/block.h"
+#include "util/coding.h"
+#include "util/crc32c.h"
+
+namespace leveldb {
+
+void BlockHandle::EncodeTo(std::string* dst) const {
+  // Sanity check that all fields have been set
+  assert(offset_ != ~static_cast<uint64_t>(0));
+  assert(size_ != ~static_cast<uint64_t>(0));
+  PutVarint64(dst, offset_);
+  PutVarint64(dst, size_);
+}
+
+Status BlockHandle::DecodeFrom(Slice* input) {
+  if (GetVarint64(input, &offset_) &&
+      GetVarint64(input, &size_)) {
+    return Status::OK();
+  } else {
+    return Status::Corruption("bad block handle");
+  }
+}
+
+void Footer::EncodeTo(std::string* dst) const {
+#ifndef NDEBUG
+  const size_t original_size = dst->size();
+#endif
+  metaindex_handle_.EncodeTo(dst);
+  index_handle_.EncodeTo(dst);
+  dst->resize(2 * BlockHandle::kMaxEncodedLength);  // Padding
+  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber & 0xffffffffu));
+  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber >> 32));
+  assert(dst->size() == original_size + kEncodedLength);
+}
+
+Status Footer::DecodeFrom(Slice* input) {
+  const char* magic_ptr = input->data() + kEncodedLength - 8;
+  const uint32_t magic_lo = DecodeFixed32(magic_ptr);
+  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);
+  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |
+                          (static_cast<uint64_t>(magic_lo)));
+  if (magic != kTableMagicNumber) {
+    return Status::InvalidArgument("not an sstable (bad magic number)");
+  }
+
+  Status result = metaindex_handle_.DecodeFrom(input);
+  if (result.ok()) {
+    result = index_handle_.DecodeFrom(input);
+  }
+  if (result.ok()) {
+    // We skip over any leftover data (just padding for now) in "input"
+    const char* end = magic_ptr + 8;
+    *input = Slice(end, input->data() + input->size() - end);
+  }
+  return result;
+}
+
+Status ReadBlock(RandomAccessFile* file,
+                 const ReadOptions& options,
+                 const BlockHandle& handle,
+                 BlockContents* result) {
+  result->data = Slice();
+  result->cachable = false;
+  result->heap_allocated = false;
+
+  // Read the block contents as well as the type/crc footer.
+  // See table_builder.cc for the code that built this structure.
+  size_t n = static_cast<size_t>(handle.size());
+  char* buf = new char[n + kBlockTrailerSize];
+  Slice contents;
+  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);
+  if (!s.ok()) {
+    delete[] buf;
+    return s;
+  }
+  if (contents.size() != n + kBlockTrailerSize) {
+    delete[] buf;
+    return Status::Corruption("truncated block read");
+  }
+
+  // Check the crc of the type and the block contents
+  const char* data = contents.data();    // Pointer to where Read put the data
+  if (options.verify_checksums) {
+    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));
+    const uint32_t actual = crc32c::Value(data, n + 1);
+    if (actual != crc) {
+      delete[] buf;
+      s = Status::Corruption("block checksum mismatch");
+      return s;
+    }
+  }
+
+  switch (data[n]) {
+    case kNoCompression:
+      if (data != buf) {
+        // File implementation gave us pointer to some other data.
+        // Use it directly under the assumption that it will be live
+        // while the file is open.
+        delete[] buf;
+        result->data = Slice(data, n);
+        result->heap_allocated = false;
+        result->cachable = false;  // Do not double-cache
+      } else {
+        result->data = Slice(buf, n);
+        result->heap_allocated = true;
+        result->cachable = true;
+      }
+
+      // Ok
+      break;
+    case kSnappyCompression: {
+      size_t ulength = 0;
+      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {
+        delete[] buf;
+        return Status::Corruption("corrupted compressed block contents");
+      }
+      char* ubuf = new char[ulength];
+      if (!port::Snappy_Uncompress(data, n, ubuf)) {
+        delete[] buf;
+        delete[] ubuf;
+        return Status::Corruption("corrupted compressed block contents");
+      }
+      delete[] buf;
+      result->data = Slice(ubuf, ulength);
+      result->heap_allocated = true;
+      result->cachable = true;
+      break;
+    }
+    default:
+      delete[] buf;
+      return Status::Corruption("bad block type");
+  }
+
+  return Status::OK();
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/format.h b/packages/LevelDB.1.16.0.5/lib/native/src/table/format.h
new file mode 100644
index 0000000..6c0b80c
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/format.h
@@ -0,0 +1,108 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_TABLE_FORMAT_H_
+#define STORAGE_LEVELDB_TABLE_FORMAT_H_
+
+#include <string>
+#include <stdint.h>
+#include "leveldb/slice.h"
+#include "leveldb/status.h"
+#include "leveldb/table_builder.h"
+
+namespace leveldb {
+
+class Block;
+class RandomAccessFile;
+struct ReadOptions;
+
+// BlockHandle is a pointer to the extent of a file that stores a data
+// block or a meta block.
+class BlockHandle {
+ public:
+  BlockHandle();
+
+  // The offset of the block in the file.
+  uint64_t offset() const { return offset_; }
+  void set_offset(uint64_t offset) { offset_ = offset; }
+
+  // The size of the stored block
+  uint64_t size() const { return size_; }
+  void set_size(uint64_t size) { size_ = size; }
+
+  void EncodeTo(std::string* dst) const;
+  Status DecodeFrom(Slice* input);
+
+  // Maximum encoding length of a BlockHandle
+  enum { kMaxEncodedLength = 10 + 10 };
+
+ private:
+  uint64_t offset_;
+  uint64_t size_;
+};
+
+// Footer encapsulates the fixed information stored at the tail
+// end of every table file.
+class Footer {
+ public:
+  Footer() { }
+
+  // The block handle for the metaindex block of the table
+  const BlockHandle& metaindex_handle() const { return metaindex_handle_; }
+  void set_metaindex_handle(const BlockHandle& h) { metaindex_handle_ = h; }
+
+  // The block handle for the index block of the table
+  const BlockHandle& index_handle() const {
+    return index_handle_;
+  }
+  void set_index_handle(const BlockHandle& h) {
+    index_handle_ = h;
+  }
+
+  void EncodeTo(std::string* dst) const;
+  Status DecodeFrom(Slice* input);
+
+  // Encoded length of a Footer.  Note that the serialization of a
+  // Footer will always occupy exactly this many bytes.  It consists
+  // of two block handles and a magic number.
+  enum {
+    kEncodedLength = 2*BlockHandle::kMaxEncodedLength + 8
+  };
+
+ private:
+  BlockHandle metaindex_handle_;
+  BlockHandle index_handle_;
+};
+
+// kTableMagicNumber was picked by running
+//    echo http://code.google.com/p/leveldb/ | sha1sum
+// and taking the leading 64 bits.
+static const uint64_t kTableMagicNumber = 0xdb4775248b80fb57ull;
+
+// 1-byte type + 32-bit crc
+static const size_t kBlockTrailerSize = 5;
+
+struct BlockContents {
+  Slice data;           // Actual contents of data
+  bool cachable;        // True iff data can be cached
+  bool heap_allocated;  // True iff caller should delete[] data.data()
+};
+
+// Read the block identified by "handle" from "file".  On failure
+// return non-OK.  On success fill *result and return OK.
+extern Status ReadBlock(RandomAccessFile* file,
+                        const ReadOptions& options,
+                        const BlockHandle& handle,
+                        BlockContents* result);
+
+// Implementation details follow.  Clients should ignore,
+
+inline BlockHandle::BlockHandle()
+    : offset_(~static_cast<uint64_t>(0)),
+      size_(~static_cast<uint64_t>(0)) {
+}
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_TABLE_FORMAT_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/iterator.cc b/packages/LevelDB.1.16.0.5/lib/native/src/table/iterator.cc
new file mode 100644
index 0000000..3d1c87f
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/iterator.cc
@@ -0,0 +1,67 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "leveldb/iterator.h"
+
+namespace leveldb {
+
+Iterator::Iterator() {
+  cleanup_.function = NULL;
+  cleanup_.next = NULL;
+}
+
+Iterator::~Iterator() {
+  if (cleanup_.function != NULL) {
+    (*cleanup_.function)(cleanup_.arg1, cleanup_.arg2);
+    for (Cleanup* c = cleanup_.next; c != NULL; ) {
+      (*c->function)(c->arg1, c->arg2);
+      Cleanup* next = c->next;
+      delete c;
+      c = next;
+    }
+  }
+}
+
+void Iterator::RegisterCleanup(CleanupFunction func, void* arg1, void* arg2) {
+  assert(func != NULL);
+  Cleanup* c;
+  if (cleanup_.function == NULL) {
+    c = &cleanup_;
+  } else {
+    c = new Cleanup;
+    c->next = cleanup_.next;
+    cleanup_.next = c;
+  }
+  c->function = func;
+  c->arg1 = arg1;
+  c->arg2 = arg2;
+}
+
+namespace {
+class EmptyIterator : public Iterator {
+ public:
+  EmptyIterator(const Status& s) : status_(s) { }
+  virtual bool Valid() const { return false; }
+  virtual void Seek(const Slice& target) { }
+  virtual void SeekToFirst() { }
+  virtual void SeekToLast() { }
+  virtual void Next() { assert(false); }
+  virtual void Prev() { assert(false); }
+  Slice key() const { assert(false); return Slice(); }
+  Slice value() const { assert(false); return Slice(); }
+  virtual Status status() const { return status_; }
+ private:
+  Status status_;
+};
+}  // namespace
+
+Iterator* NewEmptyIterator() {
+  return new EmptyIterator(Status::OK());
+}
+
+Iterator* NewErrorIterator(const Status& status) {
+  return new EmptyIterator(status);
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/iterator_wrapper.h b/packages/LevelDB.1.16.0.5/lib/native/src/table/iterator_wrapper.h
new file mode 100644
index 0000000..9e16b3d
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/iterator_wrapper.h
@@ -0,0 +1,63 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_TABLE_ITERATOR_WRAPPER_H_
+#define STORAGE_LEVELDB_TABLE_ITERATOR_WRAPPER_H_
+
+namespace leveldb {
+
+// A internal wrapper class with an interface similar to Iterator that
+// caches the valid() and key() results for an underlying iterator.
+// This can help avoid virtual function calls and also gives better
+// cache locality.
+class IteratorWrapper {
+ public:
+  IteratorWrapper(): iter_(NULL), valid_(false) { }
+  explicit IteratorWrapper(Iterator* iter): iter_(NULL) {
+    Set(iter);
+  }
+  ~IteratorWrapper() { delete iter_; }
+  Iterator* iter() const { return iter_; }
+
+  // Takes ownership of "iter" and will delete it when destroyed, or
+  // when Set() is invoked again.
+  void Set(Iterator* iter) {
+    delete iter_;
+    iter_ = iter;
+    if (iter_ == NULL) {
+      valid_ = false;
+    } else {
+      Update();
+    }
+  }
+
+
+  // Iterator interface methods
+  bool Valid() const        { return valid_; }
+  Slice key() const         { assert(Valid()); return key_; }
+  Slice value() const       { assert(Valid()); return iter_->value(); }
+  // Methods below require iter() != NULL
+  Status status() const     { assert(iter_); return iter_->status(); }
+  void Next()               { assert(iter_); iter_->Next();        Update(); }
+  void Prev()               { assert(iter_); iter_->Prev();        Update(); }
+  void Seek(const Slice& k) { assert(iter_); iter_->Seek(k);       Update(); }
+  void SeekToFirst()        { assert(iter_); iter_->SeekToFirst(); Update(); }
+  void SeekToLast()         { assert(iter_); iter_->SeekToLast();  Update(); }
+
+ private:
+  void Update() {
+    valid_ = iter_->Valid();
+    if (valid_) {
+      key_ = iter_->key();
+    }
+  }
+
+  Iterator* iter_;
+  bool valid_;
+  Slice key_;
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_TABLE_ITERATOR_WRAPPER_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/merger.cc b/packages/LevelDB.1.16.0.5/lib/native/src/table/merger.cc
new file mode 100644
index 0000000..2dde4dc
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/merger.cc
@@ -0,0 +1,197 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "table/merger.h"
+
+#include "leveldb/comparator.h"
+#include "leveldb/iterator.h"
+#include "table/iterator_wrapper.h"
+
+namespace leveldb {
+
+namespace {
+class MergingIterator : public Iterator {
+ public:
+  MergingIterator(const Comparator* comparator, Iterator** children, int n)
+      : comparator_(comparator),
+        children_(new IteratorWrapper[n]),
+        n_(n),
+        current_(NULL),
+        direction_(kForward) {
+    for (int i = 0; i < n; i++) {
+      children_[i].Set(children[i]);
+    }
+  }
+
+  virtual ~MergingIterator() {
+    delete[] children_;
+  }
+
+  virtual bool Valid() const {
+    return (current_ != NULL);
+  }
+
+  virtual void SeekToFirst() {
+    for (int i = 0; i < n_; i++) {
+      children_[i].SeekToFirst();
+    }
+    FindSmallest();
+    direction_ = kForward;
+  }
+
+  virtual void SeekToLast() {
+    for (int i = 0; i < n_; i++) {
+      children_[i].SeekToLast();
+    }
+    FindLargest();
+    direction_ = kReverse;
+  }
+
+  virtual void Seek(const Slice& target) {
+    for (int i = 0; i < n_; i++) {
+      children_[i].Seek(target);
+    }
+    FindSmallest();
+    direction_ = kForward;
+  }
+
+  virtual void Next() {
+    assert(Valid());
+
+    // Ensure that all children are positioned after key().
+    // If we are moving in the forward direction, it is already
+    // true for all of the non-current_ children since current_ is
+    // the smallest child and key() == current_->key().  Otherwise,
+    // we explicitly position the non-current_ children.
+    if (direction_ != kForward) {
+      for (int i = 0; i < n_; i++) {
+        IteratorWrapper* child = &children_[i];
+        if (child != current_) {
+          child->Seek(key());
+          if (child->Valid() &&
+              comparator_->Compare(key(), child->key()) == 0) {
+            child->Next();
+          }
+        }
+      }
+      direction_ = kForward;
+    }
+
+    current_->Next();
+    FindSmallest();
+  }
+
+  virtual void Prev() {
+    assert(Valid());
+
+    // Ensure that all children are positioned before key().
+    // If we are moving in the reverse direction, it is already
+    // true for all of the non-current_ children since current_ is
+    // the largest child and key() == current_->key().  Otherwise,
+    // we explicitly position the non-current_ children.
+    if (direction_ != kReverse) {
+      for (int i = 0; i < n_; i++) {
+        IteratorWrapper* child = &children_[i];
+        if (child != current_) {
+          child->Seek(key());
+          if (child->Valid()) {
+            // Child is at first entry >= key().  Step back one to be < key()
+            child->Prev();
+          } else {
+            // Child has no entries >= key().  Position at last entry.
+            child->SeekToLast();
+          }
+        }
+      }
+      direction_ = kReverse;
+    }
+
+    current_->Prev();
+    FindLargest();
+  }
+
+  virtual Slice key() const {
+    assert(Valid());
+    return current_->key();
+  }
+
+  virtual Slice value() const {
+    assert(Valid());
+    return current_->value();
+  }
+
+  virtual Status status() const {
+    Status status;
+    for (int i = 0; i < n_; i++) {
+      status = children_[i].status();
+      if (!status.ok()) {
+        break;
+      }
+    }
+    return status;
+  }
+
+ private:
+  void FindSmallest();
+  void FindLargest();
+
+  // We might want to use a heap in case there are lots of children.
+  // For now we use a simple array since we expect a very small number
+  // of children in leveldb.
+  const Comparator* comparator_;
+  IteratorWrapper* children_;
+  int n_;
+  IteratorWrapper* current_;
+
+  // Which direction is the iterator moving?
+  enum Direction {
+    kForward,
+    kReverse
+  };
+  Direction direction_;
+};
+
+void MergingIterator::FindSmallest() {
+  IteratorWrapper* smallest = NULL;
+  for (int i = 0; i < n_; i++) {
+    IteratorWrapper* child = &children_[i];
+    if (child->Valid()) {
+      if (smallest == NULL) {
+        smallest = child;
+      } else if (comparator_->Compare(child->key(), smallest->key()) < 0) {
+        smallest = child;
+      }
+    }
+  }
+  current_ = smallest;
+}
+
+void MergingIterator::FindLargest() {
+  IteratorWrapper* largest = NULL;
+  for (int i = n_-1; i >= 0; i--) {
+    IteratorWrapper* child = &children_[i];
+    if (child->Valid()) {
+      if (largest == NULL) {
+        largest = child;
+      } else if (comparator_->Compare(child->key(), largest->key()) > 0) {
+        largest = child;
+      }
+    }
+  }
+  current_ = largest;
+}
+}  // namespace
+
+Iterator* NewMergingIterator(const Comparator* cmp, Iterator** list, int n) {
+  assert(n >= 0);
+  if (n == 0) {
+    return NewEmptyIterator();
+  } else if (n == 1) {
+    return list[0];
+  } else {
+    return new MergingIterator(cmp, list, n);
+  }
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/merger.h b/packages/LevelDB.1.16.0.5/lib/native/src/table/merger.h
new file mode 100644
index 0000000..91ddd80
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/merger.h
@@ -0,0 +1,26 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_TABLE_MERGER_H_
+#define STORAGE_LEVELDB_TABLE_MERGER_H_
+
+namespace leveldb {
+
+class Comparator;
+class Iterator;
+
+// Return an iterator that provided the union of the data in
+// children[0,n-1].  Takes ownership of the child iterators and
+// will delete them when the result iterator is deleted.
+//
+// The result does no duplicate suppression.  I.e., if a particular
+// key is present in K child iterators, it will be yielded K times.
+//
+// REQUIRES: n >= 0
+extern Iterator* NewMergingIterator(
+    const Comparator* comparator, Iterator** children, int n);
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_TABLE_MERGER_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/table.cc b/packages/LevelDB.1.16.0.5/lib/native/src/table/table.cc
new file mode 100644
index 0000000..71c1756
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/table.cc
@@ -0,0 +1,275 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "leveldb/table.h"
+
+#include "leveldb/cache.h"
+#include "leveldb/comparator.h"
+#include "leveldb/env.h"
+#include "leveldb/filter_policy.h"
+#include "leveldb/options.h"
+#include "table/block.h"
+#include "table/filter_block.h"
+#include "table/format.h"
+#include "table/two_level_iterator.h"
+#include "util/coding.h"
+
+namespace leveldb {
+
+struct Table::Rep {
+  ~Rep() {
+    delete filter;
+    delete [] filter_data;
+    delete index_block;
+  }
+
+  Options options;
+  Status status;
+  RandomAccessFile* file;
+  uint64_t cache_id;
+  FilterBlockReader* filter;
+  const char* filter_data;
+
+  BlockHandle metaindex_handle;  // Handle to metaindex_block: saved from footer
+  Block* index_block;
+};
+
+Status Table::Open(const Options& options,
+                   RandomAccessFile* file,
+                   uint64_t size,
+                   Table** table) {
+  *table = NULL;
+  if (size < Footer::kEncodedLength) {
+    return Status::InvalidArgument("file is too short to be an sstable");
+  }
+
+  char footer_space[Footer::kEncodedLength];
+  Slice footer_input;
+  Status s = file->Read(size - Footer::kEncodedLength, Footer::kEncodedLength,
+                        &footer_input, footer_space);
+  if (!s.ok()) return s;
+
+  Footer footer;
+  s = footer.DecodeFrom(&footer_input);
+  if (!s.ok()) return s;
+
+  // Read the index block
+  BlockContents contents;
+  Block* index_block = NULL;
+  if (s.ok()) {
+    s = ReadBlock(file, ReadOptions(), footer.index_handle(), &contents);
+    if (s.ok()) {
+      index_block = new Block(contents);
+    }
+  }
+
+  if (s.ok()) {
+    // We've successfully read the footer and the index block: we're
+    // ready to serve requests.
+    Rep* rep = new Table::Rep;
+    rep->options = options;
+    rep->file = file;
+    rep->metaindex_handle = footer.metaindex_handle();
+    rep->index_block = index_block;
+    rep->cache_id = (options.block_cache ? options.block_cache->NewId() : 0);
+    rep->filter_data = NULL;
+    rep->filter = NULL;
+    *table = new Table(rep);
+    (*table)->ReadMeta(footer);
+  } else {
+    if (index_block) delete index_block;
+  }
+
+  return s;
+}
+
+void Table::ReadMeta(const Footer& footer) {
+  if (rep_->options.filter_policy == NULL) {
+    return;  // Do not need any metadata
+  }
+
+  // TODO(sanjay): Skip this if footer.metaindex_handle() size indicates
+  // it is an empty block.
+  ReadOptions opt;
+  BlockContents contents;
+  if (!ReadBlock(rep_->file, opt, footer.metaindex_handle(), &contents).ok()) {
+    // Do not propagate errors since meta info is not needed for operation
+    return;
+  }
+  Block* meta = new Block(contents);
+
+  Iterator* iter = meta->NewIterator(BytewiseComparator());
+  std::string key = "filter.";
+  key.append(rep_->options.filter_policy->Name());
+  iter->Seek(key);
+  if (iter->Valid() && iter->key() == Slice(key)) {
+    ReadFilter(iter->value());
+  }
+  delete iter;
+  delete meta;
+}
+
+void Table::ReadFilter(const Slice& filter_handle_value) {
+  Slice v = filter_handle_value;
+  BlockHandle filter_handle;
+  if (!filter_handle.DecodeFrom(&v).ok()) {
+    return;
+  }
+
+  // We might want to unify with ReadBlock() if we start
+  // requiring checksum verification in Table::Open.
+  ReadOptions opt;
+  BlockContents block;
+  if (!ReadBlock(rep_->file, opt, filter_handle, &block).ok()) {
+    return;
+  }
+  if (block.heap_allocated) {
+    rep_->filter_data = block.data.data();     // Will need to delete later
+  }
+  rep_->filter = new FilterBlockReader(rep_->options.filter_policy, block.data);
+}
+
+Table::~Table() {
+  delete rep_;
+}
+
+static void DeleteBlock(void* arg, void* ignored) {
+  delete reinterpret_cast<Block*>(arg);
+}
+
+static void DeleteCachedBlock(const Slice& key, void* value) {
+  Block* block = reinterpret_cast<Block*>(value);
+  delete block;
+}
+
+static void ReleaseBlock(void* arg, void* h) {
+  Cache* cache = reinterpret_cast<Cache*>(arg);
+  Cache::Handle* handle = reinterpret_cast<Cache::Handle*>(h);
+  cache->Release(handle);
+}
+
+// Convert an index iterator value (i.e., an encoded BlockHandle)
+// into an iterator over the contents of the corresponding block.
+Iterator* Table::BlockReader(void* arg,
+                             const ReadOptions& options,
+                             const Slice& index_value) {
+  Table* table = reinterpret_cast<Table*>(arg);
+  Cache* block_cache = table->rep_->options.block_cache;
+  Block* block = NULL;
+  Cache::Handle* cache_handle = NULL;
+
+  BlockHandle handle;
+  Slice input = index_value;
+  Status s = handle.DecodeFrom(&input);
+  // We intentionally allow extra stuff in index_value so that we
+  // can add more features in the future.
+
+  if (s.ok()) {
+    BlockContents contents;
+    if (block_cache != NULL) {
+      char cache_key_buffer[16];
+      EncodeFixed64(cache_key_buffer, table->rep_->cache_id);
+      EncodeFixed64(cache_key_buffer+8, handle.offset());
+      Slice key(cache_key_buffer, sizeof(cache_key_buffer));
+      cache_handle = block_cache->Lookup(key);
+      if (cache_handle != NULL) {
+        block = reinterpret_cast<Block*>(block_cache->Value(cache_handle));
+      } else {
+        s = ReadBlock(table->rep_->file, options, handle, &contents);
+        if (s.ok()) {
+          block = new Block(contents);
+          if (contents.cachable && options.fill_cache) {
+            cache_handle = block_cache->Insert(
+                key, block, block->size(), &DeleteCachedBlock);
+          }
+        }
+      }
+    } else {
+      s = ReadBlock(table->rep_->file, options, handle, &contents);
+      if (s.ok()) {
+        block = new Block(contents);
+      }
+    }
+  }
+
+  Iterator* iter;
+  if (block != NULL) {
+    iter = block->NewIterator(table->rep_->options.comparator);
+    if (cache_handle == NULL) {
+      iter->RegisterCleanup(&DeleteBlock, block, NULL);
+    } else {
+      iter->RegisterCleanup(&ReleaseBlock, block_cache, cache_handle);
+    }
+  } else {
+    iter = NewErrorIterator(s);
+  }
+  return iter;
+}
+
+Iterator* Table::NewIterator(const ReadOptions& options) const {
+  return NewTwoLevelIterator(
+      rep_->index_block->NewIterator(rep_->options.comparator),
+      &Table::BlockReader, const_cast<Table*>(this), options);
+}
+
+Status Table::InternalGet(const ReadOptions& options, const Slice& k,
+                          void* arg,
+                          void (*saver)(void*, const Slice&, const Slice&)) {
+  Status s;
+  Iterator* iiter = rep_->index_block->NewIterator(rep_->options.comparator);
+  iiter->Seek(k);
+  if (iiter->Valid()) {
+    Slice handle_value = iiter->value();
+    FilterBlockReader* filter = rep_->filter;
+    BlockHandle handle;
+    if (filter != NULL &&
+        handle.DecodeFrom(&handle_value).ok() &&
+        !filter->KeyMayMatch(handle.offset(), k)) {
+      // Not found
+    } else {
+      Iterator* block_iter = BlockReader(this, options, iiter->value());
+      block_iter->Seek(k);
+      if (block_iter->Valid()) {
+        (*saver)(arg, block_iter->key(), block_iter->value());
+      }
+      s = block_iter->status();
+      delete block_iter;
+    }
+  }
+  if (s.ok()) {
+    s = iiter->status();
+  }
+  delete iiter;
+  return s;
+}
+
+
+uint64_t Table::ApproximateOffsetOf(const Slice& key) const {
+  Iterator* index_iter =
+      rep_->index_block->NewIterator(rep_->options.comparator);
+  index_iter->Seek(key);
+  uint64_t result;
+  if (index_iter->Valid()) {
+    BlockHandle handle;
+    Slice input = index_iter->value();
+    Status s = handle.DecodeFrom(&input);
+    if (s.ok()) {
+      result = handle.offset();
+    } else {
+      // Strange: we can't decode the block handle in the index block.
+      // We'll just return the offset of the metaindex block, which is
+      // close to the whole file size for this case.
+      result = rep_->metaindex_handle.offset();
+    }
+  } else {
+    // key is past the last key in the file.  Approximate the offset
+    // by returning the offset of the metaindex block (which is
+    // right near the end of the file).
+    result = rep_->metaindex_handle.offset();
+  }
+  delete index_iter;
+  return result;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/table_builder.cc b/packages/LevelDB.1.16.0.5/lib/native/src/table/table_builder.cc
new file mode 100644
index 0000000..62002c8
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/table_builder.cc
@@ -0,0 +1,270 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "leveldb/table_builder.h"
+
+#include <assert.h>
+#include "leveldb/comparator.h"
+#include "leveldb/env.h"
+#include "leveldb/filter_policy.h"
+#include "leveldb/options.h"
+#include "table/block_builder.h"
+#include "table/filter_block.h"
+#include "table/format.h"
+#include "util/coding.h"
+#include "util/crc32c.h"
+
+namespace leveldb {
+
+struct TableBuilder::Rep {
+  Options options;
+  Options index_block_options;
+  WritableFile* file;
+  uint64_t offset;
+  Status status;
+  BlockBuilder data_block;
+  BlockBuilder index_block;
+  std::string last_key;
+  int64_t num_entries;
+  bool closed;          // Either Finish() or Abandon() has been called.
+  FilterBlockBuilder* filter_block;
+
+  // We do not emit the index entry for a block until we have seen the
+  // first key for the next data block.  This allows us to use shorter
+  // keys in the index block.  For example, consider a block boundary
+  // between the keys "the quick brown fox" and "the who".  We can use
+  // "the r" as the key for the index block entry since it is >= all
+  // entries in the first block and < all entries in subsequent
+  // blocks.
+  //
+  // Invariant: r->pending_index_entry is true only if data_block is empty.
+  bool pending_index_entry;
+  BlockHandle pending_handle;  // Handle to add to index block
+
+  std::string compressed_output;
+
+  Rep(const Options& opt, WritableFile* f)
+      : options(opt),
+        index_block_options(opt),
+        file(f),
+        offset(0),
+        data_block(&options),
+        index_block(&index_block_options),
+        num_entries(0),
+        closed(false),
+        filter_block(opt.filter_policy == NULL ? NULL
+                     : new FilterBlockBuilder(opt.filter_policy)),
+        pending_index_entry(false) {
+    index_block_options.block_restart_interval = 1;
+  }
+};
+
+TableBuilder::TableBuilder(const Options& options, WritableFile* file)
+    : rep_(new Rep(options, file)) {
+  if (rep_->filter_block != NULL) {
+    rep_->filter_block->StartBlock(0);
+  }
+}
+
+TableBuilder::~TableBuilder() {
+  assert(rep_->closed);  // Catch errors where caller forgot to call Finish()
+  delete rep_->filter_block;
+  delete rep_;
+}
+
+Status TableBuilder::ChangeOptions(const Options& options) {
+  // Note: if more fields are added to Options, update
+  // this function to catch changes that should not be allowed to
+  // change in the middle of building a Table.
+  if (options.comparator != rep_->options.comparator) {
+    return Status::InvalidArgument("changing comparator while building table");
+  }
+
+  // Note that any live BlockBuilders point to rep_->options and therefore
+  // will automatically pick up the updated options.
+  rep_->options = options;
+  rep_->index_block_options = options;
+  rep_->index_block_options.block_restart_interval = 1;
+  return Status::OK();
+}
+
+void TableBuilder::Add(const Slice& key, const Slice& value) {
+  Rep* r = rep_;
+  assert(!r->closed);
+  if (!ok()) return;
+  if (r->num_entries > 0) {
+    assert(r->options.comparator->Compare(key, Slice(r->last_key)) > 0);
+  }
+
+  if (r->pending_index_entry) {
+    assert(r->data_block.empty());
+    r->options.comparator->FindShortestSeparator(&r->last_key, key);
+    std::string handle_encoding;
+    r->pending_handle.EncodeTo(&handle_encoding);
+    r->index_block.Add(r->last_key, Slice(handle_encoding));
+    r->pending_index_entry = false;
+  }
+
+  if (r->filter_block != NULL) {
+    r->filter_block->AddKey(key);
+  }
+
+  r->last_key.assign(key.data(), key.size());
+  r->num_entries++;
+  r->data_block.Add(key, value);
+
+  const size_t estimated_block_size = r->data_block.CurrentSizeEstimate();
+  if (estimated_block_size >= r->options.block_size) {
+    Flush();
+  }
+}
+
+void TableBuilder::Flush() {
+  Rep* r = rep_;
+  assert(!r->closed);
+  if (!ok()) return;
+  if (r->data_block.empty()) return;
+  assert(!r->pending_index_entry);
+  WriteBlock(&r->data_block, &r->pending_handle);
+  if (ok()) {
+    r->pending_index_entry = true;
+    r->status = r->file->Flush();
+  }
+  if (r->filter_block != NULL) {
+    r->filter_block->StartBlock(r->offset);
+  }
+}
+
+void TableBuilder::WriteBlock(BlockBuilder* block, BlockHandle* handle) {
+  // File format contains a sequence of blocks where each block has:
+  //    block_data: uint8[n]
+  //    type: uint8
+  //    crc: uint32
+  assert(ok());
+  Rep* r = rep_;
+  Slice raw = block->Finish();
+
+  Slice block_contents;
+  CompressionType type = r->options.compression;
+  // TODO(postrelease): Support more compression options: zlib?
+  switch (type) {
+    case kNoCompression:
+      block_contents = raw;
+      break;
+
+    case kSnappyCompression: {
+      std::string* compressed = &r->compressed_output;
+      if (port::Snappy_Compress(raw.data(), raw.size(), compressed) &&
+          compressed->size() < raw.size() - (raw.size() / 8u)) {
+        block_contents = *compressed;
+      } else {
+        // Snappy not supported, or compressed less than 12.5%, so just
+        // store uncompressed form
+        block_contents = raw;
+        type = kNoCompression;
+      }
+      break;
+    }
+  }
+  WriteRawBlock(block_contents, type, handle);
+  r->compressed_output.clear();
+  block->Reset();
+}
+
+void TableBuilder::WriteRawBlock(const Slice& block_contents,
+                                 CompressionType type,
+                                 BlockHandle* handle) {
+  Rep* r = rep_;
+  handle->set_offset(r->offset);
+  handle->set_size(block_contents.size());
+  r->status = r->file->Append(block_contents);
+  if (r->status.ok()) {
+    char trailer[kBlockTrailerSize];
+    trailer[0] = type;
+    uint32_t crc = crc32c::Value(block_contents.data(), block_contents.size());
+    crc = crc32c::Extend(crc, trailer, 1);  // Extend crc to cover block type
+    EncodeFixed32(trailer+1, crc32c::Mask(crc));
+    r->status = r->file->Append(Slice(trailer, kBlockTrailerSize));
+    if (r->status.ok()) {
+      r->offset += block_contents.size() + kBlockTrailerSize;
+    }
+  }
+}
+
+Status TableBuilder::status() const {
+  return rep_->status;
+}
+
+Status TableBuilder::Finish() {
+  Rep* r = rep_;
+  Flush();
+  assert(!r->closed);
+  r->closed = true;
+
+  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;
+
+  // Write filter block
+  if (ok() && r->filter_block != NULL) {
+    WriteRawBlock(r->filter_block->Finish(), kNoCompression,
+                  &filter_block_handle);
+  }
+
+  // Write metaindex block
+  if (ok()) {
+    BlockBuilder meta_index_block(&r->options);
+    if (r->filter_block != NULL) {
+      // Add mapping from "filter.Name" to location of filter data
+      std::string key = "filter.";
+      key.append(r->options.filter_policy->Name());
+      std::string handle_encoding;
+      filter_block_handle.EncodeTo(&handle_encoding);
+      meta_index_block.Add(key, handle_encoding);
+    }
+
+    // TODO(postrelease): Add stats and other meta blocks
+    WriteBlock(&meta_index_block, &metaindex_block_handle);
+  }
+
+  // Write index block
+  if (ok()) {
+    if (r->pending_index_entry) {
+      r->options.comparator->FindShortSuccessor(&r->last_key);
+      std::string handle_encoding;
+      r->pending_handle.EncodeTo(&handle_encoding);
+      r->index_block.Add(r->last_key, Slice(handle_encoding));
+      r->pending_index_entry = false;
+    }
+    WriteBlock(&r->index_block, &index_block_handle);
+  }
+
+  // Write footer
+  if (ok()) {
+    Footer footer;
+    footer.set_metaindex_handle(metaindex_block_handle);
+    footer.set_index_handle(index_block_handle);
+    std::string footer_encoding;
+    footer.EncodeTo(&footer_encoding);
+    r->status = r->file->Append(footer_encoding);
+    if (r->status.ok()) {
+      r->offset += footer_encoding.size();
+    }
+  }
+  return r->status;
+}
+
+void TableBuilder::Abandon() {
+  Rep* r = rep_;
+  assert(!r->closed);
+  r->closed = true;
+}
+
+uint64_t TableBuilder::NumEntries() const {
+  return rep_->num_entries;
+}
+
+uint64_t TableBuilder::FileSize() const {
+  return rep_->offset;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/two_level_iterator.cc b/packages/LevelDB.1.16.0.5/lib/native/src/table/two_level_iterator.cc
new file mode 100644
index 0000000..7822eba
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/two_level_iterator.cc
@@ -0,0 +1,182 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "table/two_level_iterator.h"
+
+#include "leveldb/table.h"
+#include "table/block.h"
+#include "table/format.h"
+#include "table/iterator_wrapper.h"
+
+namespace leveldb {
+
+namespace {
+
+typedef Iterator* (*BlockFunction)(void*, const ReadOptions&, const Slice&);
+
+class TwoLevelIterator: public Iterator {
+ public:
+  TwoLevelIterator(
+    Iterator* index_iter,
+    BlockFunction block_function,
+    void* arg,
+    const ReadOptions& options);
+
+  virtual ~TwoLevelIterator();
+
+  virtual void Seek(const Slice& target);
+  virtual void SeekToFirst();
+  virtual void SeekToLast();
+  virtual void Next();
+  virtual void Prev();
+
+  virtual bool Valid() const {
+    return data_iter_.Valid();
+  }
+  virtual Slice key() const {
+    assert(Valid());
+    return data_iter_.key();
+  }
+  virtual Slice value() const {
+    assert(Valid());
+    return data_iter_.value();
+  }
+  virtual Status status() const {
+    // It'd be nice if status() returned a const Status& instead of a Status
+    if (!index_iter_.status().ok()) {
+      return index_iter_.status();
+    } else if (data_iter_.iter() != NULL && !data_iter_.status().ok()) {
+      return data_iter_.status();
+    } else {
+      return status_;
+    }
+  }
+
+ private:
+  void SaveError(const Status& s) {
+    if (status_.ok() && !s.ok()) status_ = s;
+  }
+  void SkipEmptyDataBlocksForward();
+  void SkipEmptyDataBlocksBackward();
+  void SetDataIterator(Iterator* data_iter);
+  void InitDataBlock();
+
+  BlockFunction block_function_;
+  void* arg_;
+  const ReadOptions options_;
+  Status status_;
+  IteratorWrapper index_iter_;
+  IteratorWrapper data_iter_; // May be NULL
+  // If data_iter_ is non-NULL, then "data_block_handle_" holds the
+  // "index_value" passed to block_function_ to create the data_iter_.
+  std::string data_block_handle_;
+};
+
+TwoLevelIterator::TwoLevelIterator(
+    Iterator* index_iter,
+    BlockFunction block_function,
+    void* arg,
+    const ReadOptions& options)
+    : block_function_(block_function),
+      arg_(arg),
+      options_(options),
+      index_iter_(index_iter),
+      data_iter_(NULL) {
+}
+
+TwoLevelIterator::~TwoLevelIterator() {
+}
+
+void TwoLevelIterator::Seek(const Slice& target) {
+  index_iter_.Seek(target);
+  InitDataBlock();
+  if (data_iter_.iter() != NULL) data_iter_.Seek(target);
+  SkipEmptyDataBlocksForward();
+}
+
+void TwoLevelIterator::SeekToFirst() {
+  index_iter_.SeekToFirst();
+  InitDataBlock();
+  if (data_iter_.iter() != NULL) data_iter_.SeekToFirst();
+  SkipEmptyDataBlocksForward();
+}
+
+void TwoLevelIterator::SeekToLast() {
+  index_iter_.SeekToLast();
+  InitDataBlock();
+  if (data_iter_.iter() != NULL) data_iter_.SeekToLast();
+  SkipEmptyDataBlocksBackward();
+}
+
+void TwoLevelIterator::Next() {
+  assert(Valid());
+  data_iter_.Next();
+  SkipEmptyDataBlocksForward();
+}
+
+void TwoLevelIterator::Prev() {
+  assert(Valid());
+  data_iter_.Prev();
+  SkipEmptyDataBlocksBackward();
+}
+
+
+void TwoLevelIterator::SkipEmptyDataBlocksForward() {
+  while (data_iter_.iter() == NULL || !data_iter_.Valid()) {
+    // Move to next block
+    if (!index_iter_.Valid()) {
+      SetDataIterator(NULL);
+      return;
+    }
+    index_iter_.Next();
+    InitDataBlock();
+    if (data_iter_.iter() != NULL) data_iter_.SeekToFirst();
+  }
+}
+
+void TwoLevelIterator::SkipEmptyDataBlocksBackward() {
+  while (data_iter_.iter() == NULL || !data_iter_.Valid()) {
+    // Move to next block
+    if (!index_iter_.Valid()) {
+      SetDataIterator(NULL);
+      return;
+    }
+    index_iter_.Prev();
+    InitDataBlock();
+    if (data_iter_.iter() != NULL) data_iter_.SeekToLast();
+  }
+}
+
+void TwoLevelIterator::SetDataIterator(Iterator* data_iter) {
+  if (data_iter_.iter() != NULL) SaveError(data_iter_.status());
+  data_iter_.Set(data_iter);
+}
+
+void TwoLevelIterator::InitDataBlock() {
+  if (!index_iter_.Valid()) {
+    SetDataIterator(NULL);
+  } else {
+    Slice handle = index_iter_.value();
+    if (data_iter_.iter() != NULL && handle.compare(data_block_handle_) == 0) {
+      // data_iter_ is already constructed with this iterator, so
+      // no need to change anything
+    } else {
+      Iterator* iter = (*block_function_)(arg_, options_, handle);
+      data_block_handle_.assign(handle.data(), handle.size());
+      SetDataIterator(iter);
+    }
+  }
+}
+
+}  // namespace
+
+Iterator* NewTwoLevelIterator(
+    Iterator* index_iter,
+    BlockFunction block_function,
+    void* arg,
+    const ReadOptions& options) {
+  return new TwoLevelIterator(index_iter, block_function, arg, options);
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/table/two_level_iterator.h b/packages/LevelDB.1.16.0.5/lib/native/src/table/two_level_iterator.h
new file mode 100644
index 0000000..629ca34
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/table/two_level_iterator.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_TABLE_TWO_LEVEL_ITERATOR_H_
+#define STORAGE_LEVELDB_TABLE_TWO_LEVEL_ITERATOR_H_
+
+#include "leveldb/iterator.h"
+
+namespace leveldb {
+
+struct ReadOptions;
+
+// Return a new two level iterator.  A two-level iterator contains an
+// index iterator whose values point to a sequence of blocks where
+// each block is itself a sequence of key,value pairs.  The returned
+// two-level iterator yields the concatenation of all key/value pairs
+// in the sequence of blocks.  Takes ownership of "index_iter" and
+// will delete it when no longer needed.
+//
+// Uses a supplied function to convert an index_iter value into
+// an iterator over the contents of the corresponding block.
+extern Iterator* NewTwoLevelIterator(
+    Iterator* index_iter,
+    Iterator* (*block_function)(
+        void* arg,
+        const ReadOptions& options,
+        const Slice& index_value),
+    void* arg,
+    const ReadOptions& options);
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_TABLE_TWO_LEVEL_ITERATOR_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/arena.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/arena.cc
new file mode 100644
index 0000000..9367f71
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/arena.cc
@@ -0,0 +1,68 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "util/arena.h"
+#include <assert.h>
+
+namespace leveldb {
+
+static const int kBlockSize = 4096;
+
+Arena::Arena() {
+  blocks_memory_ = 0;
+  alloc_ptr_ = NULL;  // First allocation will allocate a block
+  alloc_bytes_remaining_ = 0;
+}
+
+Arena::~Arena() {
+  for (size_t i = 0; i < blocks_.size(); i++) {
+    delete[] blocks_[i];
+  }
+}
+
+char* Arena::AllocateFallback(size_t bytes) {
+  if (bytes > kBlockSize / 4) {
+    // Object is more than a quarter of our block size.  Allocate it separately
+    // to avoid wasting too much space in leftover bytes.
+    char* result = AllocateNewBlock(bytes);
+    return result;
+  }
+
+  // We waste the remaining space in the current block.
+  alloc_ptr_ = AllocateNewBlock(kBlockSize);
+  alloc_bytes_remaining_ = kBlockSize;
+
+  char* result = alloc_ptr_;
+  alloc_ptr_ += bytes;
+  alloc_bytes_remaining_ -= bytes;
+  return result;
+}
+
+char* Arena::AllocateAligned(size_t bytes) {
+  const int align = (sizeof(void*) > 8) ? sizeof(void*) : 8;
+  assert((align & (align-1)) == 0);   // Pointer size should be a power of 2
+  size_t current_mod = reinterpret_cast<uintptr_t>(alloc_ptr_) & (align-1);
+  size_t slop = (current_mod == 0 ? 0 : align - current_mod);
+  size_t needed = bytes + slop;
+  char* result;
+  if (needed <= alloc_bytes_remaining_) {
+    result = alloc_ptr_ + slop;
+    alloc_ptr_ += needed;
+    alloc_bytes_remaining_ -= needed;
+  } else {
+    // AllocateFallback always returned aligned memory
+    result = AllocateFallback(bytes);
+  }
+  assert((reinterpret_cast<uintptr_t>(result) & (align-1)) == 0);
+  return result;
+}
+
+char* Arena::AllocateNewBlock(size_t block_bytes) {
+  char* result = new char[block_bytes];
+  blocks_memory_ += block_bytes;
+  blocks_.push_back(result);
+  return result;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/arena.h b/packages/LevelDB.1.16.0.5/lib/native/src/util/arena.h
new file mode 100644
index 0000000..73bbf1c
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/arena.h
@@ -0,0 +1,68 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_UTIL_ARENA_H_
+#define STORAGE_LEVELDB_UTIL_ARENA_H_
+
+#include <vector>
+#include <assert.h>
+#include <stddef.h>
+#include <stdint.h>
+
+namespace leveldb {
+
+class Arena {
+ public:
+  Arena();
+  ~Arena();
+
+  // Return a pointer to a newly allocated memory block of "bytes" bytes.
+  char* Allocate(size_t bytes);
+
+  // Allocate memory with the normal alignment guarantees provided by malloc
+  char* AllocateAligned(size_t bytes);
+
+  // Returns an estimate of the total memory usage of data allocated
+  // by the arena (including space allocated but not yet used for user
+  // allocations).
+  size_t MemoryUsage() const {
+    return blocks_memory_ + blocks_.capacity() * sizeof(char*);
+  }
+
+ private:
+  char* AllocateFallback(size_t bytes);
+  char* AllocateNewBlock(size_t block_bytes);
+
+  // Allocation state
+  char* alloc_ptr_;
+  size_t alloc_bytes_remaining_;
+
+  // Array of new[] allocated memory blocks
+  std::vector<char*> blocks_;
+
+  // Bytes of memory in blocks allocated so far
+  size_t blocks_memory_;
+
+  // No copying allowed
+  Arena(const Arena&);
+  void operator=(const Arena&);
+};
+
+inline char* Arena::Allocate(size_t bytes) {
+  // The semantics of what to return are a bit messy if we allow
+  // 0-byte allocations, so we disallow them here (we don't need
+  // them for our internal use).
+  assert(bytes > 0);
+  if (bytes <= alloc_bytes_remaining_) {
+    char* result = alloc_ptr_;
+    alloc_ptr_ += bytes;
+    alloc_bytes_remaining_ -= bytes;
+    return result;
+  }
+  return AllocateFallback(bytes);
+}
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_UTIL_ARENA_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/bloom.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/bloom.cc
new file mode 100644
index 0000000..d7941cd
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/bloom.cc
@@ -0,0 +1,95 @@
+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "leveldb/filter_policy.h"
+
+#include "leveldb/slice.h"
+#include "util/hash.h"
+
+namespace leveldb {
+
+namespace {
+static uint32_t BloomHash(const Slice& key) {
+  return Hash(key.data(), key.size(), 0xbc9f1d34);
+}
+
+class BloomFilterPolicy : public FilterPolicy {
+ private:
+  size_t bits_per_key_;
+  size_t k_;
+
+ public:
+  explicit BloomFilterPolicy(int bits_per_key)
+      : bits_per_key_(bits_per_key) {
+    // We intentionally round down to reduce probing cost a little bit
+    k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
+    if (k_ < 1) k_ = 1;
+    if (k_ > 30) k_ = 30;
+  }
+
+  virtual const char* Name() const {
+    return "leveldb.BuiltinBloomFilter";
+  }
+
+  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
+    // Compute bloom filter size (in both bits and bytes)
+    size_t bits = n * bits_per_key_;
+
+    // For small n, we can see a very high false positive rate.  Fix it
+    // by enforcing a minimum bloom filter length.
+    if (bits < 64) bits = 64;
+
+    size_t bytes = (bits + 7) / 8;
+    bits = bytes * 8;
+
+    const size_t init_size = dst->size();
+    dst->resize(init_size + bytes, 0);
+    dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter
+    char* array = &(*dst)[init_size];
+    for (size_t i = 0; i < n; i++) {
+      // Use double-hashing to generate a sequence of hash values.
+      // See analysis in [Kirsch,Mitzenmacher 2006].
+      uint32_t h = BloomHash(keys[i]);
+      const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
+      for (size_t j = 0; j < k_; j++) {
+        const uint32_t bitpos = h % bits;
+        array[bitpos/8] |= (1 << (bitpos % 8));
+        h += delta;
+      }
+    }
+  }
+
+  virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const {
+    const size_t len = bloom_filter.size();
+    if (len < 2) return false;
+
+    const char* array = bloom_filter.data();
+    const size_t bits = (len - 1) * 8;
+
+    // Use the encoded k so that we can read filters generated by
+    // bloom filters created using different parameters.
+    const size_t k = array[len-1];
+    if (k > 30) {
+      // Reserved for potentially new encodings for short bloom filters.
+      // Consider it a match.
+      return true;
+    }
+
+    uint32_t h = BloomHash(key);
+    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
+    for (size_t j = 0; j < k; j++) {
+      const uint32_t bitpos = h % bits;
+      if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;
+      h += delta;
+    }
+    return true;
+  }
+};
+}
+
+const FilterPolicy* NewBloomFilterPolicy(int bits_per_key) {
+  return new BloomFilterPolicy(bits_per_key);
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/cache.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/cache.cc
new file mode 100644
index 0000000..8b197bc
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/cache.cc
@@ -0,0 +1,325 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "leveldb/cache.h"
+#include "port/port.h"
+#include "util/hash.h"
+#include "util/mutexlock.h"
+
+namespace leveldb {
+
+Cache::~Cache() {
+}
+
+namespace {
+
+// LRU cache implementation
+
+// An entry is a variable length heap-allocated structure.  Entries
+// are kept in a circular doubly linked list ordered by access time.
+struct LRUHandle {
+  void* value;
+  void (*deleter)(const Slice&, void* value);
+  LRUHandle* next_hash;
+  LRUHandle* next;
+  LRUHandle* prev;
+  size_t charge;      // TODO(opt): Only allow uint32_t?
+  size_t key_length;
+  uint32_t refs;
+  uint32_t hash;      // Hash of key(); used for fast sharding and comparisons
+  char key_data[1];   // Beginning of key
+
+  Slice key() const {
+    // For cheaper lookups, we allow a temporary Handle object
+    // to store a pointer to a key in "value".
+    if (next == this) {
+      return *(reinterpret_cast<Slice*>(value));
+    } else {
+      return Slice(key_data, key_length);
+    }
+  }
+};
+
+// We provide our own simple hash table since it removes a whole bunch
+// of porting hacks and is also faster than some of the built-in hash
+// table implementations in some of the compiler/runtime combinations
+// we have tested.  E.g., readrandom speeds up by ~5% over the g++
+// 4.4.3's builtin hashtable.
+class HandleTable {
+ public:
+  HandleTable() : length_(0), elems_(0), list_(NULL) { Resize(); }
+  ~HandleTable() { delete[] list_; }
+
+  LRUHandle* Lookup(const Slice& key, uint32_t hash) {
+    return *FindPointer(key, hash);
+  }
+
+  LRUHandle* Insert(LRUHandle* h) {
+    LRUHandle** ptr = FindPointer(h->key(), h->hash);
+    LRUHandle* old = *ptr;
+    h->next_hash = (old == NULL ? NULL : old->next_hash);
+    *ptr = h;
+    if (old == NULL) {
+      ++elems_;
+      if (elems_ > length_) {
+        // Since each cache entry is fairly large, we aim for a small
+        // average linked list length (<= 1).
+        Resize();
+      }
+    }
+    return old;
+  }
+
+  LRUHandle* Remove(const Slice& key, uint32_t hash) {
+    LRUHandle** ptr = FindPointer(key, hash);
+    LRUHandle* result = *ptr;
+    if (result != NULL) {
+      *ptr = result->next_hash;
+      --elems_;
+    }
+    return result;
+  }
+
+ private:
+  // The table consists of an array of buckets where each bucket is
+  // a linked list of cache entries that hash into the bucket.
+  uint32_t length_;
+  uint32_t elems_;
+  LRUHandle** list_;
+
+  // Return a pointer to slot that points to a cache entry that
+  // matches key/hash.  If there is no such cache entry, return a
+  // pointer to the trailing slot in the corresponding linked list.
+  LRUHandle** FindPointer(const Slice& key, uint32_t hash) {
+    LRUHandle** ptr = &list_[hash & (length_ - 1)];
+    while (*ptr != NULL &&
+           ((*ptr)->hash != hash || key != (*ptr)->key())) {
+      ptr = &(*ptr)->next_hash;
+    }
+    return ptr;
+  }
+
+  void Resize() {
+    uint32_t new_length = 4;
+    while (new_length < elems_) {
+      new_length *= 2;
+    }
+    LRUHandle** new_list = new LRUHandle*[new_length];
+    memset(new_list, 0, sizeof(new_list[0]) * new_length);
+    uint32_t count = 0;
+    for (uint32_t i = 0; i < length_; i++) {
+      LRUHandle* h = list_[i];
+      while (h != NULL) {
+        LRUHandle* next = h->next_hash;
+        uint32_t hash = h->hash;
+        LRUHandle** ptr = &new_list[hash & (new_length - 1)];
+        h->next_hash = *ptr;
+        *ptr = h;
+        h = next;
+        count++;
+      }
+    }
+    assert(elems_ == count);
+    delete[] list_;
+    list_ = new_list;
+    length_ = new_length;
+  }
+};
+
+// A single shard of sharded cache.
+class LRUCache {
+ public:
+  LRUCache();
+  ~LRUCache();
+
+  // Separate from constructor so caller can easily make an array of LRUCache
+  void SetCapacity(size_t capacity) { capacity_ = capacity; }
+
+  // Like Cache methods, but with an extra "hash" parameter.
+  Cache::Handle* Insert(const Slice& key, uint32_t hash,
+                        void* value, size_t charge,
+                        void (*deleter)(const Slice& key, void* value));
+  Cache::Handle* Lookup(const Slice& key, uint32_t hash);
+  void Release(Cache::Handle* handle);
+  void Erase(const Slice& key, uint32_t hash);
+
+ private:
+  void LRU_Remove(LRUHandle* e);
+  void LRU_Append(LRUHandle* e);
+  void Unref(LRUHandle* e);
+
+  // Initialized before use.
+  size_t capacity_;
+
+  // mutex_ protects the following state.
+  port::Mutex mutex_;
+  size_t usage_;
+
+  // Dummy head of LRU list.
+  // lru.prev is newest entry, lru.next is oldest entry.
+  LRUHandle lru_;
+
+  HandleTable table_;
+};
+
+LRUCache::LRUCache()
+    : usage_(0) {
+  // Make empty circular linked list
+  lru_.next = &lru_;
+  lru_.prev = &lru_;
+}
+
+LRUCache::~LRUCache() {
+  for (LRUHandle* e = lru_.next; e != &lru_; ) {
+    LRUHandle* next = e->next;
+    assert(e->refs == 1);  // Error if caller has an unreleased handle
+    Unref(e);
+    e = next;
+  }
+}
+
+void LRUCache::Unref(LRUHandle* e) {
+  assert(e->refs > 0);
+  e->refs--;
+  if (e->refs <= 0) {
+    usage_ -= e->charge;
+    (*e->deleter)(e->key(), e->value);
+    free(e);
+  }
+}
+
+void LRUCache::LRU_Remove(LRUHandle* e) {
+  e->next->prev = e->prev;
+  e->prev->next = e->next;
+}
+
+void LRUCache::LRU_Append(LRUHandle* e) {
+  // Make "e" newest entry by inserting just before lru_
+  e->next = &lru_;
+  e->prev = lru_.prev;
+  e->prev->next = e;
+  e->next->prev = e;
+}
+
+Cache::Handle* LRUCache::Lookup(const Slice& key, uint32_t hash) {
+  MutexLock l(&mutex_);
+  LRUHandle* e = table_.Lookup(key, hash);
+  if (e != NULL) {
+    e->refs++;
+    LRU_Remove(e);
+    LRU_Append(e);
+  }
+  return reinterpret_cast<Cache::Handle*>(e);
+}
+
+void LRUCache::Release(Cache::Handle* handle) {
+  MutexLock l(&mutex_);
+  Unref(reinterpret_cast<LRUHandle*>(handle));
+}
+
+Cache::Handle* LRUCache::Insert(
+    const Slice& key, uint32_t hash, void* value, size_t charge,
+    void (*deleter)(const Slice& key, void* value)) {
+  MutexLock l(&mutex_);
+
+  LRUHandle* e = reinterpret_cast<LRUHandle*>(
+      malloc(sizeof(LRUHandle)-1 + key.size()));
+  e->value = value;
+  e->deleter = deleter;
+  e->charge = charge;
+  e->key_length = key.size();
+  e->hash = hash;
+  e->refs = 2;  // One from LRUCache, one for the returned handle
+  memcpy(e->key_data, key.data(), key.size());
+  LRU_Append(e);
+  usage_ += charge;
+
+  LRUHandle* old = table_.Insert(e);
+  if (old != NULL) {
+    LRU_Remove(old);
+    Unref(old);
+  }
+
+  while (usage_ > capacity_ && lru_.next != &lru_) {
+    LRUHandle* old = lru_.next;
+    LRU_Remove(old);
+    table_.Remove(old->key(), old->hash);
+    Unref(old);
+  }
+
+  return reinterpret_cast<Cache::Handle*>(e);
+}
+
+void LRUCache::Erase(const Slice& key, uint32_t hash) {
+  MutexLock l(&mutex_);
+  LRUHandle* e = table_.Remove(key, hash);
+  if (e != NULL) {
+    LRU_Remove(e);
+    Unref(e);
+  }
+}
+
+static const int kNumShardBits = 4;
+static const int kNumShards = 1 << kNumShardBits;
+
+class ShardedLRUCache : public Cache {
+ private:
+  LRUCache shard_[kNumShards];
+  port::Mutex id_mutex_;
+  uint64_t last_id_;
+
+  static inline uint32_t HashSlice(const Slice& s) {
+    return Hash(s.data(), s.size(), 0);
+  }
+
+  static uint32_t Shard(uint32_t hash) {
+    return hash >> (32 - kNumShardBits);
+  }
+
+ public:
+  explicit ShardedLRUCache(size_t capacity)
+      : last_id_(0) {
+    const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards;
+    for (int s = 0; s < kNumShards; s++) {
+      shard_[s].SetCapacity(per_shard);
+    }
+  }
+  virtual ~ShardedLRUCache() { }
+  virtual Handle* Insert(const Slice& key, void* value, size_t charge,
+                         void (*deleter)(const Slice& key, void* value)) {
+    const uint32_t hash = HashSlice(key);
+    return shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);
+  }
+  virtual Handle* Lookup(const Slice& key) {
+    const uint32_t hash = HashSlice(key);
+    return shard_[Shard(hash)].Lookup(key, hash);
+  }
+  virtual void Release(Handle* handle) {
+    LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);
+    shard_[Shard(h->hash)].Release(handle);
+  }
+  virtual void Erase(const Slice& key) {
+    const uint32_t hash = HashSlice(key);
+    shard_[Shard(hash)].Erase(key, hash);
+  }
+  virtual void* Value(Handle* handle) {
+    return reinterpret_cast<LRUHandle*>(handle)->value;
+  }
+  virtual uint64_t NewId() {
+    MutexLock l(&id_mutex_);
+    return ++(last_id_);
+  }
+};
+
+}  // end anonymous namespace
+
+Cache* NewLRUCache(size_t capacity) {
+  return new ShardedLRUCache(capacity);
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/coding.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/coding.cc
new file mode 100644
index 0000000..21e3186
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/coding.cc
@@ -0,0 +1,194 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "util/coding.h"
+
+namespace leveldb {
+
+void EncodeFixed32(char* buf, uint32_t value) {
+  if (port::kLittleEndian) {
+    memcpy(buf, &value, sizeof(value));
+  } else {
+    buf[0] = value & 0xff;
+    buf[1] = (value >> 8) & 0xff;
+    buf[2] = (value >> 16) & 0xff;
+    buf[3] = (value >> 24) & 0xff;
+  }
+}
+
+void EncodeFixed64(char* buf, uint64_t value) {
+  if (port::kLittleEndian) {
+    memcpy(buf, &value, sizeof(value));
+  } else {
+    buf[0] = value & 0xff;
+    buf[1] = (value >> 8) & 0xff;
+    buf[2] = (value >> 16) & 0xff;
+    buf[3] = (value >> 24) & 0xff;
+    buf[4] = (value >> 32) & 0xff;
+    buf[5] = (value >> 40) & 0xff;
+    buf[6] = (value >> 48) & 0xff;
+    buf[7] = (value >> 56) & 0xff;
+  }
+}
+
+void PutFixed32(std::string* dst, uint32_t value) {
+  char buf[sizeof(value)];
+  EncodeFixed32(buf, value);
+  dst->append(buf, sizeof(buf));
+}
+
+void PutFixed64(std::string* dst, uint64_t value) {
+  char buf[sizeof(value)];
+  EncodeFixed64(buf, value);
+  dst->append(buf, sizeof(buf));
+}
+
+char* EncodeVarint32(char* dst, uint32_t v) {
+  // Operate on characters as unsigneds
+  unsigned char* ptr = reinterpret_cast<unsigned char*>(dst);
+  static const int B = 128;
+  if (v < (1<<7)) {
+    *(ptr++) = v;
+  } else if (v < (1<<14)) {
+    *(ptr++) = v | B;
+    *(ptr++) = v>>7;
+  } else if (v < (1<<21)) {
+    *(ptr++) = v | B;
+    *(ptr++) = (v>>7) | B;
+    *(ptr++) = v>>14;
+  } else if (v < (1<<28)) {
+    *(ptr++) = v | B;
+    *(ptr++) = (v>>7) | B;
+    *(ptr++) = (v>>14) | B;
+    *(ptr++) = v>>21;
+  } else {
+    *(ptr++) = v | B;
+    *(ptr++) = (v>>7) | B;
+    *(ptr++) = (v>>14) | B;
+    *(ptr++) = (v>>21) | B;
+    *(ptr++) = v>>28;
+  }
+  return reinterpret_cast<char*>(ptr);
+}
+
+void PutVarint32(std::string* dst, uint32_t v) {
+  char buf[5];
+  char* ptr = EncodeVarint32(buf, v);
+  dst->append(buf, ptr - buf);
+}
+
+char* EncodeVarint64(char* dst, uint64_t v) {
+  static const int B = 128;
+  unsigned char* ptr = reinterpret_cast<unsigned char*>(dst);
+  while (v >= B) {
+    *(ptr++) = (v & (B-1)) | B;
+    v >>= 7;
+  }
+  *(ptr++) = static_cast<unsigned char>(v);
+  return reinterpret_cast<char*>(ptr);
+}
+
+void PutVarint64(std::string* dst, uint64_t v) {
+  char buf[10];
+  char* ptr = EncodeVarint64(buf, v);
+  dst->append(buf, ptr - buf);
+}
+
+void PutLengthPrefixedSlice(std::string* dst, const Slice& value) {
+  PutVarint32(dst, value.size());
+  dst->append(value.data(), value.size());
+}
+
+int VarintLength(uint64_t v) {
+  int len = 1;
+  while (v >= 128) {
+    v >>= 7;
+    len++;
+  }
+  return len;
+}
+
+const char* GetVarint32PtrFallback(const char* p,
+                                   const char* limit,
+                                   uint32_t* value) {
+  uint32_t result = 0;
+  for (uint32_t shift = 0; shift <= 28 && p < limit; shift += 7) {
+    uint32_t byte = *(reinterpret_cast<const unsigned char*>(p));
+    p++;
+    if (byte & 128) {
+      // More bytes are present
+      result |= ((byte & 127) << shift);
+    } else {
+      result |= (byte << shift);
+      *value = result;
+      return reinterpret_cast<const char*>(p);
+    }
+  }
+  return NULL;
+}
+
+bool GetVarint32(Slice* input, uint32_t* value) {
+  const char* p = input->data();
+  const char* limit = p + input->size();
+  const char* q = GetVarint32Ptr(p, limit, value);
+  if (q == NULL) {
+    return false;
+  } else {
+    *input = Slice(q, limit - q);
+    return true;
+  }
+}
+
+const char* GetVarint64Ptr(const char* p, const char* limit, uint64_t* value) {
+  uint64_t result = 0;
+  for (uint32_t shift = 0; shift <= 63 && p < limit; shift += 7) {
+    uint64_t byte = *(reinterpret_cast<const unsigned char*>(p));
+    p++;
+    if (byte & 128) {
+      // More bytes are present
+      result |= ((byte & 127) << shift);
+    } else {
+      result |= (byte << shift);
+      *value = result;
+      return reinterpret_cast<const char*>(p);
+    }
+  }
+  return NULL;
+}
+
+bool GetVarint64(Slice* input, uint64_t* value) {
+  const char* p = input->data();
+  const char* limit = p + input->size();
+  const char* q = GetVarint64Ptr(p, limit, value);
+  if (q == NULL) {
+    return false;
+  } else {
+    *input = Slice(q, limit - q);
+    return true;
+  }
+}
+
+const char* GetLengthPrefixedSlice(const char* p, const char* limit,
+                                   Slice* result) {
+  uint32_t len;
+  p = GetVarint32Ptr(p, limit, &len);
+  if (p == NULL) return NULL;
+  if (p + len > limit) return NULL;
+  *result = Slice(p, len);
+  return p + len;
+}
+
+bool GetLengthPrefixedSlice(Slice* input, Slice* result) {
+  uint32_t len;
+  if (GetVarint32(input, &len) &&
+      input->size() >= len) {
+    *result = Slice(input->data(), len);
+    input->remove_prefix(len);
+    return true;
+  } else {
+    return false;
+  }
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/coding.h b/packages/LevelDB.1.16.0.5/lib/native/src/util/coding.h
new file mode 100644
index 0000000..3993c4a
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/coding.h
@@ -0,0 +1,104 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// Endian-neutral encoding:
+// * Fixed-length numbers are encoded with least-significant byte first
+// * In addition we support variable length "varint" encoding
+// * Strings are encoded prefixed by their length in varint format
+
+#ifndef STORAGE_LEVELDB_UTIL_CODING_H_
+#define STORAGE_LEVELDB_UTIL_CODING_H_
+
+#include <stdint.h>
+#include <string.h>
+#include <string>
+#include "leveldb/slice.h"
+#include "port/port.h"
+
+namespace leveldb {
+
+// Standard Put... routines append to a string
+extern void PutFixed32(std::string* dst, uint32_t value);
+extern void PutFixed64(std::string* dst, uint64_t value);
+extern void PutVarint32(std::string* dst, uint32_t value);
+extern void PutVarint64(std::string* dst, uint64_t value);
+extern void PutLengthPrefixedSlice(std::string* dst, const Slice& value);
+
+// Standard Get... routines parse a value from the beginning of a Slice
+// and advance the slice past the parsed value.
+extern bool GetVarint32(Slice* input, uint32_t* value);
+extern bool GetVarint64(Slice* input, uint64_t* value);
+extern bool GetLengthPrefixedSlice(Slice* input, Slice* result);
+
+// Pointer-based variants of GetVarint...  These either store a value
+// in *v and return a pointer just past the parsed value, or return
+// NULL on error.  These routines only look at bytes in the range
+// [p..limit-1]
+extern const char* GetVarint32Ptr(const char* p,const char* limit, uint32_t* v);
+extern const char* GetVarint64Ptr(const char* p,const char* limit, uint64_t* v);
+
+// Returns the length of the varint32 or varint64 encoding of "v"
+extern int VarintLength(uint64_t v);
+
+// Lower-level versions of Put... that write directly into a character buffer
+// REQUIRES: dst has enough space for the value being written
+extern void EncodeFixed32(char* dst, uint32_t value);
+extern void EncodeFixed64(char* dst, uint64_t value);
+
+// Lower-level versions of Put... that write directly into a character buffer
+// and return a pointer just past the last byte written.
+// REQUIRES: dst has enough space for the value being written
+extern char* EncodeVarint32(char* dst, uint32_t value);
+extern char* EncodeVarint64(char* dst, uint64_t value);
+
+// Lower-level versions of Get... that read directly from a character buffer
+// without any bounds checking.
+
+inline uint32_t DecodeFixed32(const char* ptr) {
+  if (port::kLittleEndian) {
+    // Load the raw bytes
+    uint32_t result;
+    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load
+    return result;
+  } else {
+    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))
+        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)
+        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)
+        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));
+  }
+}
+
+inline uint64_t DecodeFixed64(const char* ptr) {
+  if (port::kLittleEndian) {
+    // Load the raw bytes
+    uint64_t result;
+    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load
+    return result;
+  } else {
+    uint64_t lo = DecodeFixed32(ptr);
+    uint64_t hi = DecodeFixed32(ptr + 4);
+    return (hi << 32) | lo;
+  }
+}
+
+// Internal routine for use by fallback path of GetVarint32Ptr
+extern const char* GetVarint32PtrFallback(const char* p,
+                                          const char* limit,
+                                          uint32_t* value);
+inline const char* GetVarint32Ptr(const char* p,
+                                  const char* limit,
+                                  uint32_t* value) {
+  if (p < limit) {
+    uint32_t result = *(reinterpret_cast<const unsigned char*>(p));
+    if ((result & 128) == 0) {
+      *value = result;
+      return p + 1;
+    }
+  }
+  return GetVarint32PtrFallback(p, limit, value);
+}
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_UTIL_CODING_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/comparator.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/comparator.cc
new file mode 100644
index 0000000..4b7b572
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/comparator.cc
@@ -0,0 +1,81 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include <algorithm>
+#include <stdint.h>
+#include "leveldb/comparator.h"
+#include "leveldb/slice.h"
+#include "port/port.h"
+#include "util/logging.h"
+
+namespace leveldb {
+
+Comparator::~Comparator() { }
+
+namespace {
+class BytewiseComparatorImpl : public Comparator {
+ public:
+  BytewiseComparatorImpl() { }
+
+  virtual const char* Name() const {
+    return "leveldb.BytewiseComparator";
+  }
+
+  virtual int Compare(const Slice& a, const Slice& b) const {
+    return a.compare(b);
+  }
+
+  virtual void FindShortestSeparator(
+      std::string* start,
+      const Slice& limit) const {
+    // Find length of common prefix
+    size_t min_length = std::min(start->size(), limit.size());
+    size_t diff_index = 0;
+    while ((diff_index < min_length) &&
+           ((*start)[diff_index] == limit[diff_index])) {
+      diff_index++;
+    }
+
+    if (diff_index >= min_length) {
+      // Do not shorten if one string is a prefix of the other
+    } else {
+      uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);
+      if (diff_byte < static_cast<uint8_t>(0xff) &&
+          diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {
+        (*start)[diff_index]++;
+        start->resize(diff_index + 1);
+        assert(Compare(*start, limit) < 0);
+      }
+    }
+  }
+
+  virtual void FindShortSuccessor(std::string* key) const {
+    // Find first character that can be incremented
+    size_t n = key->size();
+    for (size_t i = 0; i < n; i++) {
+      const uint8_t byte = (*key)[i];
+      if (byte != static_cast<uint8_t>(0xff)) {
+        (*key)[i] = byte + 1;
+        key->resize(i+1);
+        return;
+      }
+    }
+    // *key is a run of 0xffs.  Leave it alone.
+  }
+};
+}  // namespace
+
+static port::OnceType once = LEVELDB_ONCE_INIT;
+static const Comparator* bytewise;
+
+static void InitModule() {
+  bytewise = new BytewiseComparatorImpl;
+}
+
+const Comparator* BytewiseComparator() {
+  port::InitOnce(&once, InitModule);
+  return bytewise;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/crc32c.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/crc32c.cc
new file mode 100644
index 0000000..6db9e77
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/crc32c.cc
@@ -0,0 +1,332 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// A portable implementation of crc32c, optimized to handle
+// four bytes at a time.
+
+#include "util/crc32c.h"
+
+#include <stdint.h>
+#include "util/coding.h"
+
+namespace leveldb {
+namespace crc32c {
+
+static const uint32_t table0_[256] = {
+  0x00000000, 0xf26b8303, 0xe13b70f7, 0x1350f3f4,
+  0xc79a971f, 0x35f1141c, 0x26a1e7e8, 0xd4ca64eb,
+  0x8ad958cf, 0x78b2dbcc, 0x6be22838, 0x9989ab3b,
+  0x4d43cfd0, 0xbf284cd3, 0xac78bf27, 0x5e133c24,
+  0x105ec76f, 0xe235446c, 0xf165b798, 0x030e349b,
+  0xd7c45070, 0x25afd373, 0x36ff2087, 0xc494a384,
+  0x9a879fa0, 0x68ec1ca3, 0x7bbcef57, 0x89d76c54,
+  0x5d1d08bf, 0xaf768bbc, 0xbc267848, 0x4e4dfb4b,
+  0x20bd8ede, 0xd2d60ddd, 0xc186fe29, 0x33ed7d2a,
+  0xe72719c1, 0x154c9ac2, 0x061c6936, 0xf477ea35,
+  0xaa64d611, 0x580f5512, 0x4b5fa6e6, 0xb93425e5,
+  0x6dfe410e, 0x9f95c20d, 0x8cc531f9, 0x7eaeb2fa,
+  0x30e349b1, 0xc288cab2, 0xd1d83946, 0x23b3ba45,
+  0xf779deae, 0x05125dad, 0x1642ae59, 0xe4292d5a,
+  0xba3a117e, 0x4851927d, 0x5b016189, 0xa96ae28a,
+  0x7da08661, 0x8fcb0562, 0x9c9bf696, 0x6ef07595,
+  0x417b1dbc, 0xb3109ebf, 0xa0406d4b, 0x522bee48,
+  0x86e18aa3, 0x748a09a0, 0x67dafa54, 0x95b17957,
+  0xcba24573, 0x39c9c670, 0x2a993584, 0xd8f2b687,
+  0x0c38d26c, 0xfe53516f, 0xed03a29b, 0x1f682198,
+  0x5125dad3, 0xa34e59d0, 0xb01eaa24, 0x42752927,
+  0x96bf4dcc, 0x64d4cecf, 0x77843d3b, 0x85efbe38,
+  0xdbfc821c, 0x2997011f, 0x3ac7f2eb, 0xc8ac71e8,
+  0x1c661503, 0xee0d9600, 0xfd5d65f4, 0x0f36e6f7,
+  0x61c69362, 0x93ad1061, 0x80fde395, 0x72966096,
+  0xa65c047d, 0x5437877e, 0x4767748a, 0xb50cf789,
+  0xeb1fcbad, 0x197448ae, 0x0a24bb5a, 0xf84f3859,
+  0x2c855cb2, 0xdeeedfb1, 0xcdbe2c45, 0x3fd5af46,
+  0x7198540d, 0x83f3d70e, 0x90a324fa, 0x62c8a7f9,
+  0xb602c312, 0x44694011, 0x5739b3e5, 0xa55230e6,
+  0xfb410cc2, 0x092a8fc1, 0x1a7a7c35, 0xe811ff36,
+  0x3cdb9bdd, 0xceb018de, 0xdde0eb2a, 0x2f8b6829,
+  0x82f63b78, 0x709db87b, 0x63cd4b8f, 0x91a6c88c,
+  0x456cac67, 0xb7072f64, 0xa457dc90, 0x563c5f93,
+  0x082f63b7, 0xfa44e0b4, 0xe9141340, 0x1b7f9043,
+  0xcfb5f4a8, 0x3dde77ab, 0x2e8e845f, 0xdce5075c,
+  0x92a8fc17, 0x60c37f14, 0x73938ce0, 0x81f80fe3,
+  0x55326b08, 0xa759e80b, 0xb4091bff, 0x466298fc,
+  0x1871a4d8, 0xea1a27db, 0xf94ad42f, 0x0b21572c,
+  0xdfeb33c7, 0x2d80b0c4, 0x3ed04330, 0xccbbc033,
+  0xa24bb5a6, 0x502036a5, 0x4370c551, 0xb11b4652,
+  0x65d122b9, 0x97baa1ba, 0x84ea524e, 0x7681d14d,
+  0x2892ed69, 0xdaf96e6a, 0xc9a99d9e, 0x3bc21e9d,
+  0xef087a76, 0x1d63f975, 0x0e330a81, 0xfc588982,
+  0xb21572c9, 0x407ef1ca, 0x532e023e, 0xa145813d,
+  0x758fe5d6, 0x87e466d5, 0x94b49521, 0x66df1622,
+  0x38cc2a06, 0xcaa7a905, 0xd9f75af1, 0x2b9cd9f2,
+  0xff56bd19, 0x0d3d3e1a, 0x1e6dcdee, 0xec064eed,
+  0xc38d26c4, 0x31e6a5c7, 0x22b65633, 0xd0ddd530,
+  0x0417b1db, 0xf67c32d8, 0xe52cc12c, 0x1747422f,
+  0x49547e0b, 0xbb3ffd08, 0xa86f0efc, 0x5a048dff,
+  0x8ecee914, 0x7ca56a17, 0x6ff599e3, 0x9d9e1ae0,
+  0xd3d3e1ab, 0x21b862a8, 0x32e8915c, 0xc083125f,
+  0x144976b4, 0xe622f5b7, 0xf5720643, 0x07198540,
+  0x590ab964, 0xab613a67, 0xb831c993, 0x4a5a4a90,
+  0x9e902e7b, 0x6cfbad78, 0x7fab5e8c, 0x8dc0dd8f,
+  0xe330a81a, 0x115b2b19, 0x020bd8ed, 0xf0605bee,
+  0x24aa3f05, 0xd6c1bc06, 0xc5914ff2, 0x37faccf1,
+  0x69e9f0d5, 0x9b8273d6, 0x88d28022, 0x7ab90321,
+  0xae7367ca, 0x5c18e4c9, 0x4f48173d, 0xbd23943e,
+  0xf36e6f75, 0x0105ec76, 0x12551f82, 0xe03e9c81,
+  0x34f4f86a, 0xc69f7b69, 0xd5cf889d, 0x27a40b9e,
+  0x79b737ba, 0x8bdcb4b9, 0x988c474d, 0x6ae7c44e,
+  0xbe2da0a5, 0x4c4623a6, 0x5f16d052, 0xad7d5351
+};
+static const uint32_t table1_[256] = {
+  0x00000000, 0x13a29877, 0x274530ee, 0x34e7a899,
+  0x4e8a61dc, 0x5d28f9ab, 0x69cf5132, 0x7a6dc945,
+  0x9d14c3b8, 0x8eb65bcf, 0xba51f356, 0xa9f36b21,
+  0xd39ea264, 0xc03c3a13, 0xf4db928a, 0xe7790afd,
+  0x3fc5f181, 0x2c6769f6, 0x1880c16f, 0x0b225918,
+  0x714f905d, 0x62ed082a, 0x560aa0b3, 0x45a838c4,
+  0xa2d13239, 0xb173aa4e, 0x859402d7, 0x96369aa0,
+  0xec5b53e5, 0xfff9cb92, 0xcb1e630b, 0xd8bcfb7c,
+  0x7f8be302, 0x6c297b75, 0x58ced3ec, 0x4b6c4b9b,
+  0x310182de, 0x22a31aa9, 0x1644b230, 0x05e62a47,
+  0xe29f20ba, 0xf13db8cd, 0xc5da1054, 0xd6788823,
+  0xac154166, 0xbfb7d911, 0x8b507188, 0x98f2e9ff,
+  0x404e1283, 0x53ec8af4, 0x670b226d, 0x74a9ba1a,
+  0x0ec4735f, 0x1d66eb28, 0x298143b1, 0x3a23dbc6,
+  0xdd5ad13b, 0xcef8494c, 0xfa1fe1d5, 0xe9bd79a2,
+  0x93d0b0e7, 0x80722890, 0xb4958009, 0xa737187e,
+  0xff17c604, 0xecb55e73, 0xd852f6ea, 0xcbf06e9d,
+  0xb19da7d8, 0xa23f3faf, 0x96d89736, 0x857a0f41,
+  0x620305bc, 0x71a19dcb, 0x45463552, 0x56e4ad25,
+  0x2c896460, 0x3f2bfc17, 0x0bcc548e, 0x186eccf9,
+  0xc0d23785, 0xd370aff2, 0xe797076b, 0xf4359f1c,
+  0x8e585659, 0x9dface2e, 0xa91d66b7, 0xbabffec0,
+  0x5dc6f43d, 0x4e646c4a, 0x7a83c4d3, 0x69215ca4,
+  0x134c95e1, 0x00ee0d96, 0x3409a50f, 0x27ab3d78,
+  0x809c2506, 0x933ebd71, 0xa7d915e8, 0xb47b8d9f,
+  0xce1644da, 0xddb4dcad, 0xe9537434, 0xfaf1ec43,
+  0x1d88e6be, 0x0e2a7ec9, 0x3acdd650, 0x296f4e27,
+  0x53028762, 0x40a01f15, 0x7447b78c, 0x67e52ffb,
+  0xbf59d487, 0xacfb4cf0, 0x981ce469, 0x8bbe7c1e,
+  0xf1d3b55b, 0xe2712d2c, 0xd69685b5, 0xc5341dc2,
+  0x224d173f, 0x31ef8f48, 0x050827d1, 0x16aabfa6,
+  0x6cc776e3, 0x7f65ee94, 0x4b82460d, 0x5820de7a,
+  0xfbc3faf9, 0xe861628e, 0xdc86ca17, 0xcf245260,
+  0xb5499b25, 0xa6eb0352, 0x920cabcb, 0x81ae33bc,
+  0x66d73941, 0x7575a136, 0x419209af, 0x523091d8,
+  0x285d589d, 0x3bffc0ea, 0x0f186873, 0x1cbaf004,
+  0xc4060b78, 0xd7a4930f, 0xe3433b96, 0xf0e1a3e1,
+  0x8a8c6aa4, 0x992ef2d3, 0xadc95a4a, 0xbe6bc23d,
+  0x5912c8c0, 0x4ab050b7, 0x7e57f82e, 0x6df56059,
+  0x1798a91c, 0x043a316b, 0x30dd99f2, 0x237f0185,
+  0x844819fb, 0x97ea818c, 0xa30d2915, 0xb0afb162,
+  0xcac27827, 0xd960e050, 0xed8748c9, 0xfe25d0be,
+  0x195cda43, 0x0afe4234, 0x3e19eaad, 0x2dbb72da,
+  0x57d6bb9f, 0x447423e8, 0x70938b71, 0x63311306,
+  0xbb8de87a, 0xa82f700d, 0x9cc8d894, 0x8f6a40e3,
+  0xf50789a6, 0xe6a511d1, 0xd242b948, 0xc1e0213f,
+  0x26992bc2, 0x353bb3b5, 0x01dc1b2c, 0x127e835b,
+  0x68134a1e, 0x7bb1d269, 0x4f567af0, 0x5cf4e287,
+  0x04d43cfd, 0x1776a48a, 0x23910c13, 0x30339464,
+  0x4a5e5d21, 0x59fcc556, 0x6d1b6dcf, 0x7eb9f5b8,
+  0x99c0ff45, 0x8a626732, 0xbe85cfab, 0xad2757dc,
+  0xd74a9e99, 0xc4e806ee, 0xf00fae77, 0xe3ad3600,
+  0x3b11cd7c, 0x28b3550b, 0x1c54fd92, 0x0ff665e5,
+  0x759baca0, 0x663934d7, 0x52de9c4e, 0x417c0439,
+  0xa6050ec4, 0xb5a796b3, 0x81403e2a, 0x92e2a65d,
+  0xe88f6f18, 0xfb2df76f, 0xcfca5ff6, 0xdc68c781,
+  0x7b5fdfff, 0x68fd4788, 0x5c1aef11, 0x4fb87766,
+  0x35d5be23, 0x26772654, 0x12908ecd, 0x013216ba,
+  0xe64b1c47, 0xf5e98430, 0xc10e2ca9, 0xd2acb4de,
+  0xa8c17d9b, 0xbb63e5ec, 0x8f844d75, 0x9c26d502,
+  0x449a2e7e, 0x5738b609, 0x63df1e90, 0x707d86e7,
+  0x0a104fa2, 0x19b2d7d5, 0x2d557f4c, 0x3ef7e73b,
+  0xd98eedc6, 0xca2c75b1, 0xfecbdd28, 0xed69455f,
+  0x97048c1a, 0x84a6146d, 0xb041bcf4, 0xa3e32483
+};
+static const uint32_t table2_[256] = {
+  0x00000000, 0xa541927e, 0x4f6f520d, 0xea2ec073,
+  0x9edea41a, 0x3b9f3664, 0xd1b1f617, 0x74f06469,
+  0x38513ec5, 0x9d10acbb, 0x773e6cc8, 0xd27ffeb6,
+  0xa68f9adf, 0x03ce08a1, 0xe9e0c8d2, 0x4ca15aac,
+  0x70a27d8a, 0xd5e3eff4, 0x3fcd2f87, 0x9a8cbdf9,
+  0xee7cd990, 0x4b3d4bee, 0xa1138b9d, 0x045219e3,
+  0x48f3434f, 0xedb2d131, 0x079c1142, 0xa2dd833c,
+  0xd62de755, 0x736c752b, 0x9942b558, 0x3c032726,
+  0xe144fb14, 0x4405696a, 0xae2ba919, 0x0b6a3b67,
+  0x7f9a5f0e, 0xdadbcd70, 0x30f50d03, 0x95b49f7d,
+  0xd915c5d1, 0x7c5457af, 0x967a97dc, 0x333b05a2,
+  0x47cb61cb, 0xe28af3b5, 0x08a433c6, 0xade5a1b8,
+  0x91e6869e, 0x34a714e0, 0xde89d493, 0x7bc846ed,
+  0x0f382284, 0xaa79b0fa, 0x40577089, 0xe516e2f7,
+  0xa9b7b85b, 0x0cf62a25, 0xe6d8ea56, 0x43997828,
+  0x37691c41, 0x92288e3f, 0x78064e4c, 0xdd47dc32,
+  0xc76580d9, 0x622412a7, 0x880ad2d4, 0x2d4b40aa,
+  0x59bb24c3, 0xfcfab6bd, 0x16d476ce, 0xb395e4b0,
+  0xff34be1c, 0x5a752c62, 0xb05bec11, 0x151a7e6f,
+  0x61ea1a06, 0xc4ab8878, 0x2e85480b, 0x8bc4da75,
+  0xb7c7fd53, 0x12866f2d, 0xf8a8af5e, 0x5de93d20,
+  0x29195949, 0x8c58cb37, 0x66760b44, 0xc337993a,
+  0x8f96c396, 0x2ad751e8, 0xc0f9919b, 0x65b803e5,
+  0x1148678c, 0xb409f5f2, 0x5e273581, 0xfb66a7ff,
+  0x26217bcd, 0x8360e9b3, 0x694e29c0, 0xcc0fbbbe,
+  0xb8ffdfd7, 0x1dbe4da9, 0xf7908dda, 0x52d11fa4,
+  0x1e704508, 0xbb31d776, 0x511f1705, 0xf45e857b,
+  0x80aee112, 0x25ef736c, 0xcfc1b31f, 0x6a802161,
+  0x56830647, 0xf3c29439, 0x19ec544a, 0xbcadc634,
+  0xc85da25d, 0x6d1c3023, 0x8732f050, 0x2273622e,
+  0x6ed23882, 0xcb93aafc, 0x21bd6a8f, 0x84fcf8f1,
+  0xf00c9c98, 0x554d0ee6, 0xbf63ce95, 0x1a225ceb,
+  0x8b277743, 0x2e66e53d, 0xc448254e, 0x6109b730,
+  0x15f9d359, 0xb0b84127, 0x5a968154, 0xffd7132a,
+  0xb3764986, 0x1637dbf8, 0xfc191b8b, 0x595889f5,
+  0x2da8ed9c, 0x88e97fe2, 0x62c7bf91, 0xc7862def,
+  0xfb850ac9, 0x5ec498b7, 0xb4ea58c4, 0x11abcaba,
+  0x655baed3, 0xc01a3cad, 0x2a34fcde, 0x8f756ea0,
+  0xc3d4340c, 0x6695a672, 0x8cbb6601, 0x29faf47f,
+  0x5d0a9016, 0xf84b0268, 0x1265c21b, 0xb7245065,
+  0x6a638c57, 0xcf221e29, 0x250cde5a, 0x804d4c24,
+  0xf4bd284d, 0x51fcba33, 0xbbd27a40, 0x1e93e83e,
+  0x5232b292, 0xf77320ec, 0x1d5de09f, 0xb81c72e1,
+  0xccec1688, 0x69ad84f6, 0x83834485, 0x26c2d6fb,
+  0x1ac1f1dd, 0xbf8063a3, 0x55aea3d0, 0xf0ef31ae,
+  0x841f55c7, 0x215ec7b9, 0xcb7007ca, 0x6e3195b4,
+  0x2290cf18, 0x87d15d66, 0x6dff9d15, 0xc8be0f6b,
+  0xbc4e6b02, 0x190ff97c, 0xf321390f, 0x5660ab71,
+  0x4c42f79a, 0xe90365e4, 0x032da597, 0xa66c37e9,
+  0xd29c5380, 0x77ddc1fe, 0x9df3018d, 0x38b293f3,
+  0x7413c95f, 0xd1525b21, 0x3b7c9b52, 0x9e3d092c,
+  0xeacd6d45, 0x4f8cff3b, 0xa5a23f48, 0x00e3ad36,
+  0x3ce08a10, 0x99a1186e, 0x738fd81d, 0xd6ce4a63,
+  0xa23e2e0a, 0x077fbc74, 0xed517c07, 0x4810ee79,
+  0x04b1b4d5, 0xa1f026ab, 0x4bdee6d8, 0xee9f74a6,
+  0x9a6f10cf, 0x3f2e82b1, 0xd50042c2, 0x7041d0bc,
+  0xad060c8e, 0x08479ef0, 0xe2695e83, 0x4728ccfd,
+  0x33d8a894, 0x96993aea, 0x7cb7fa99, 0xd9f668e7,
+  0x9557324b, 0x3016a035, 0xda386046, 0x7f79f238,
+  0x0b899651, 0xaec8042f, 0x44e6c45c, 0xe1a75622,
+  0xdda47104, 0x78e5e37a, 0x92cb2309, 0x378ab177,
+  0x437ad51e, 0xe63b4760, 0x0c158713, 0xa954156d,
+  0xe5f54fc1, 0x40b4ddbf, 0xaa9a1dcc, 0x0fdb8fb2,
+  0x7b2bebdb, 0xde6a79a5, 0x3444b9d6, 0x91052ba8
+};
+static const uint32_t table3_[256] = {
+  0x00000000, 0xdd45aab8, 0xbf672381, 0x62228939,
+  0x7b2231f3, 0xa6679b4b, 0xc4451272, 0x1900b8ca,
+  0xf64463e6, 0x2b01c95e, 0x49234067, 0x9466eadf,
+  0x8d665215, 0x5023f8ad, 0x32017194, 0xef44db2c,
+  0xe964b13d, 0x34211b85, 0x560392bc, 0x8b463804,
+  0x924680ce, 0x4f032a76, 0x2d21a34f, 0xf06409f7,
+  0x1f20d2db, 0xc2657863, 0xa047f15a, 0x7d025be2,
+  0x6402e328, 0xb9474990, 0xdb65c0a9, 0x06206a11,
+  0xd725148b, 0x0a60be33, 0x6842370a, 0xb5079db2,
+  0xac072578, 0x71428fc0, 0x136006f9, 0xce25ac41,
+  0x2161776d, 0xfc24ddd5, 0x9e0654ec, 0x4343fe54,
+  0x5a43469e, 0x8706ec26, 0xe524651f, 0x3861cfa7,
+  0x3e41a5b6, 0xe3040f0e, 0x81268637, 0x5c632c8f,
+  0x45639445, 0x98263efd, 0xfa04b7c4, 0x27411d7c,
+  0xc805c650, 0x15406ce8, 0x7762e5d1, 0xaa274f69,
+  0xb327f7a3, 0x6e625d1b, 0x0c40d422, 0xd1057e9a,
+  0xaba65fe7, 0x76e3f55f, 0x14c17c66, 0xc984d6de,
+  0xd0846e14, 0x0dc1c4ac, 0x6fe34d95, 0xb2a6e72d,
+  0x5de23c01, 0x80a796b9, 0xe2851f80, 0x3fc0b538,
+  0x26c00df2, 0xfb85a74a, 0x99a72e73, 0x44e284cb,
+  0x42c2eeda, 0x9f874462, 0xfda5cd5b, 0x20e067e3,
+  0x39e0df29, 0xe4a57591, 0x8687fca8, 0x5bc25610,
+  0xb4868d3c, 0x69c32784, 0x0be1aebd, 0xd6a40405,
+  0xcfa4bccf, 0x12e11677, 0x70c39f4e, 0xad8635f6,
+  0x7c834b6c, 0xa1c6e1d4, 0xc3e468ed, 0x1ea1c255,
+  0x07a17a9f, 0xdae4d027, 0xb8c6591e, 0x6583f3a6,
+  0x8ac7288a, 0x57828232, 0x35a00b0b, 0xe8e5a1b3,
+  0xf1e51979, 0x2ca0b3c1, 0x4e823af8, 0x93c79040,
+  0x95e7fa51, 0x48a250e9, 0x2a80d9d0, 0xf7c57368,
+  0xeec5cba2, 0x3380611a, 0x51a2e823, 0x8ce7429b,
+  0x63a399b7, 0xbee6330f, 0xdcc4ba36, 0x0181108e,
+  0x1881a844, 0xc5c402fc, 0xa7e68bc5, 0x7aa3217d,
+  0x52a0c93f, 0x8fe56387, 0xedc7eabe, 0x30824006,
+  0x2982f8cc, 0xf4c75274, 0x96e5db4d, 0x4ba071f5,
+  0xa4e4aad9, 0x79a10061, 0x1b838958, 0xc6c623e0,
+  0xdfc69b2a, 0x02833192, 0x60a1b8ab, 0xbde41213,
+  0xbbc47802, 0x6681d2ba, 0x04a35b83, 0xd9e6f13b,
+  0xc0e649f1, 0x1da3e349, 0x7f816a70, 0xa2c4c0c8,
+  0x4d801be4, 0x90c5b15c, 0xf2e73865, 0x2fa292dd,
+  0x36a22a17, 0xebe780af, 0x89c50996, 0x5480a32e,
+  0x8585ddb4, 0x58c0770c, 0x3ae2fe35, 0xe7a7548d,
+  0xfea7ec47, 0x23e246ff, 0x41c0cfc6, 0x9c85657e,
+  0x73c1be52, 0xae8414ea, 0xcca69dd3, 0x11e3376b,
+  0x08e38fa1, 0xd5a62519, 0xb784ac20, 0x6ac10698,
+  0x6ce16c89, 0xb1a4c631, 0xd3864f08, 0x0ec3e5b0,
+  0x17c35d7a, 0xca86f7c2, 0xa8a47efb, 0x75e1d443,
+  0x9aa50f6f, 0x47e0a5d7, 0x25c22cee, 0xf8878656,
+  0xe1873e9c, 0x3cc29424, 0x5ee01d1d, 0x83a5b7a5,
+  0xf90696d8, 0x24433c60, 0x4661b559, 0x9b241fe1,
+  0x8224a72b, 0x5f610d93, 0x3d4384aa, 0xe0062e12,
+  0x0f42f53e, 0xd2075f86, 0xb025d6bf, 0x6d607c07,
+  0x7460c4cd, 0xa9256e75, 0xcb07e74c, 0x16424df4,
+  0x106227e5, 0xcd278d5d, 0xaf050464, 0x7240aedc,
+  0x6b401616, 0xb605bcae, 0xd4273597, 0x09629f2f,
+  0xe6264403, 0x3b63eebb, 0x59416782, 0x8404cd3a,
+  0x9d0475f0, 0x4041df48, 0x22635671, 0xff26fcc9,
+  0x2e238253, 0xf36628eb, 0x9144a1d2, 0x4c010b6a,
+  0x5501b3a0, 0x88441918, 0xea669021, 0x37233a99,
+  0xd867e1b5, 0x05224b0d, 0x6700c234, 0xba45688c,
+  0xa345d046, 0x7e007afe, 0x1c22f3c7, 0xc167597f,
+  0xc747336e, 0x1a0299d6, 0x782010ef, 0xa565ba57,
+  0xbc65029d, 0x6120a825, 0x0302211c, 0xde478ba4,
+  0x31035088, 0xec46fa30, 0x8e647309, 0x5321d9b1,
+  0x4a21617b, 0x9764cbc3, 0xf54642fa, 0x2803e842
+};
+
+// Used to fetch a naturally-aligned 32-bit word in little endian byte-order
+static inline uint32_t LE_LOAD32(const uint8_t *p) {
+  return DecodeFixed32(reinterpret_cast<const char*>(p));
+}
+
+uint32_t Extend(uint32_t crc, const char* buf, size_t size) {
+  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);
+  const uint8_t *e = p + size;
+  uint32_t l = crc ^ 0xffffffffu;
+
+#define STEP1 do {                              \
+    int c = (l & 0xff) ^ *p++;                  \
+    l = table0_[c] ^ (l >> 8);                  \
+} while (0)
+#define STEP4 do {                              \
+    uint32_t c = l ^ LE_LOAD32(p);              \
+    p += 4;                                     \
+    l = table3_[c & 0xff] ^                     \
+        table2_[(c >> 8) & 0xff] ^              \
+        table1_[(c >> 16) & 0xff] ^             \
+        table0_[c >> 24];                       \
+} while (0)
+
+  // Point x at first 4-byte aligned byte in string.  This might be
+  // just past the end of the string.
+  const uintptr_t pval = reinterpret_cast<uintptr_t>(p);
+  const uint8_t* x = reinterpret_cast<const uint8_t*>(((pval + 3) >> 2) << 2);
+  if (x <= e) {
+    // Process bytes until finished or p is 4-byte aligned
+    while (p != x) {
+      STEP1;
+    }
+  }
+  // Process bytes 16 at a time
+  while ((e-p) >= 16) {
+    STEP4; STEP4; STEP4; STEP4;
+  }
+  // Process bytes 4 at a time
+  while ((e-p) >= 4) {
+    STEP4;
+  }
+  // Process the last few bytes
+  while (p != e) {
+    STEP1;
+  }
+#undef STEP4
+#undef STEP1
+  return l ^ 0xffffffffu;
+}
+
+}  // namespace crc32c
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/crc32c.h b/packages/LevelDB.1.16.0.5/lib/native/src/util/crc32c.h
new file mode 100644
index 0000000..1d7e5c0
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/crc32c.h
@@ -0,0 +1,45 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_UTIL_CRC32C_H_
+#define STORAGE_LEVELDB_UTIL_CRC32C_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+namespace leveldb {
+namespace crc32c {
+
+// Return the crc32c of concat(A, data[0,n-1]) where init_crc is the
+// crc32c of some string A.  Extend() is often used to maintain the
+// crc32c of a stream of data.
+extern uint32_t Extend(uint32_t init_crc, const char* data, size_t n);
+
+// Return the crc32c of data[0,n-1]
+inline uint32_t Value(const char* data, size_t n) {
+  return Extend(0, data, n);
+}
+
+static const uint32_t kMaskDelta = 0xa282ead8ul;
+
+// Return a masked representation of crc.
+//
+// Motivation: it is problematic to compute the CRC of a string that
+// contains embedded CRCs.  Therefore we recommend that CRCs stored
+// somewhere (e.g., in files) should be masked before being stored.
+inline uint32_t Mask(uint32_t crc) {
+  // Rotate right by 15 bits and add a constant.
+  return ((crc >> 15) | (crc << 17)) + kMaskDelta;
+}
+
+// Return the crc whose masked representation is masked_crc.
+inline uint32_t Unmask(uint32_t masked_crc) {
+  uint32_t rot = masked_crc - kMaskDelta;
+  return ((rot >> 17) | (rot << 15));
+}
+
+}  // namespace crc32c
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_UTIL_CRC32C_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/env.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/env.cc
new file mode 100644
index 0000000..c2600e9
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/env.cc
@@ -0,0 +1,96 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "leveldb/env.h"
+
+namespace leveldb {
+
+Env::~Env() {
+}
+
+SequentialFile::~SequentialFile() {
+}
+
+RandomAccessFile::~RandomAccessFile() {
+}
+
+WritableFile::~WritableFile() {
+}
+
+Logger::~Logger() {
+}
+
+FileLock::~FileLock() {
+}
+
+void Log(Logger* info_log, const char* format, ...) {
+  if (info_log != NULL) {
+    va_list ap;
+    va_start(ap, format);
+    info_log->Logv(format, ap);
+    va_end(ap);
+  }
+}
+
+static Status DoWriteStringToFile(Env* env, const Slice& data,
+                                  const std::string& fname,
+                                  bool should_sync) {
+  WritableFile* file;
+  Status s = env->NewWritableFile(fname, &file);
+  if (!s.ok()) {
+    return s;
+  }
+  s = file->Append(data);
+  if (s.ok() && should_sync) {
+    s = file->Sync();
+  }
+  if (s.ok()) {
+    s = file->Close();
+  }
+  delete file;  // Will auto-close if we did not close above
+  if (!s.ok()) {
+    env->DeleteFile(fname);
+  }
+  return s;
+}
+
+Status WriteStringToFile(Env* env, const Slice& data,
+                         const std::string& fname) {
+  return DoWriteStringToFile(env, data, fname, false);
+}
+
+Status WriteStringToFileSync(Env* env, const Slice& data,
+                             const std::string& fname) {
+  return DoWriteStringToFile(env, data, fname, true);
+}
+
+Status ReadFileToString(Env* env, const std::string& fname, std::string* data) {
+  data->clear();
+  SequentialFile* file;
+  Status s = env->NewSequentialFile(fname, &file);
+  if (!s.ok()) {
+    return s;
+  }
+  static const int kBufferSize = 8192;
+  char* space = new char[kBufferSize];
+  while (true) {
+    Slice fragment;
+    s = file->Read(kBufferSize, &fragment, space);
+    if (!s.ok()) {
+      break;
+    }
+    data->append(fragment.data(), fragment.size());
+    if (fragment.empty()) {
+      break;
+    }
+  }
+  delete[] space;
+  delete file;
+  return s;
+}
+
+EnvWrapper::~EnvWrapper() {
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/env_posix.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/env_posix.cc
new file mode 100644
index 0000000..e1cbebd
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/env_posix.cc
@@ -0,0 +1,607 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include <deque>
+#include <set>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <time.h>
+#include <unistd.h>
+#if defined(LEVELDB_PLATFORM_ANDROID)
+#include <sys/stat.h>
+#endif
+#include "leveldb/env.h"
+#include "leveldb/slice.h"
+#include "port/port.h"
+#include "util/logging.h"
+#include "util/mutexlock.h"
+#include "util/posix_logger.h"
+
+namespace leveldb {
+
+namespace {
+
+static Status IOError(const std::string& context, int err_number) {
+  return Status::IOError(context, strerror(err_number));
+}
+
+class PosixSequentialFile: public SequentialFile {
+ private:
+  std::string filename_;
+  FILE* file_;
+
+ public:
+  PosixSequentialFile(const std::string& fname, FILE* f)
+      : filename_(fname), file_(f) { }
+  virtual ~PosixSequentialFile() { fclose(file_); }
+
+  virtual Status Read(size_t n, Slice* result, char* scratch) {
+    Status s;
+    size_t r = fread_unlocked(scratch, 1, n, file_);
+    *result = Slice(scratch, r);
+    if (r < n) {
+      if (feof(file_)) {
+        // We leave status as ok if we hit the end of the file
+      } else {
+        // A partial read with an error: return a non-ok status
+        s = IOError(filename_, errno);
+      }
+    }
+    return s;
+  }
+
+  virtual Status Skip(uint64_t n) {
+    if (fseek(file_, n, SEEK_CUR)) {
+      return IOError(filename_, errno);
+    }
+    return Status::OK();
+  }
+};
+
+// pread() based random-access
+class PosixRandomAccessFile: public RandomAccessFile {
+ private:
+  std::string filename_;
+  int fd_;
+
+ public:
+  PosixRandomAccessFile(const std::string& fname, int fd)
+      : filename_(fname), fd_(fd) { }
+  virtual ~PosixRandomAccessFile() { close(fd_); }
+
+  virtual Status Read(uint64_t offset, size_t n, Slice* result,
+                      char* scratch) const {
+    Status s;
+    ssize_t r = pread(fd_, scratch, n, static_cast<off_t>(offset));
+    *result = Slice(scratch, (r < 0) ? 0 : r);
+    if (r < 0) {
+      // An error: return a non-ok status
+      s = IOError(filename_, errno);
+    }
+    return s;
+  }
+};
+
+// Helper class to limit mmap file usage so that we do not end up
+// running out virtual memory or running into kernel performance
+// problems for very large databases.
+class MmapLimiter {
+ public:
+  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.
+  MmapLimiter() {
+    SetAllowed(sizeof(void*) >= 8 ? 1000 : 0);
+  }
+
+  // If another mmap slot is available, acquire it and return true.
+  // Else return false.
+  bool Acquire() {
+    if (GetAllowed() <= 0) {
+      return false;
+    }
+    MutexLock l(&mu_);
+    intptr_t x = GetAllowed();
+    if (x <= 0) {
+      return false;
+    } else {
+      SetAllowed(x - 1);
+      return true;
+    }
+  }
+
+  // Release a slot acquired by a previous call to Acquire() that returned true.
+  void Release() {
+    MutexLock l(&mu_);
+    SetAllowed(GetAllowed() + 1);
+  }
+
+ private:
+  port::Mutex mu_;
+  port::AtomicPointer allowed_;
+
+  intptr_t GetAllowed() const {
+    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());
+  }
+
+  // REQUIRES: mu_ must be held
+  void SetAllowed(intptr_t v) {
+    allowed_.Release_Store(reinterpret_cast<void*>(v));
+  }
+
+  MmapLimiter(const MmapLimiter&);
+  void operator=(const MmapLimiter&);
+};
+
+// mmap() based random-access
+class PosixMmapReadableFile: public RandomAccessFile {
+ private:
+  std::string filename_;
+  void* mmapped_region_;
+  size_t length_;
+  MmapLimiter* limiter_;
+
+ public:
+  // base[0,length-1] contains the mmapped contents of the file.
+  PosixMmapReadableFile(const std::string& fname, void* base, size_t length,
+                        MmapLimiter* limiter)
+      : filename_(fname), mmapped_region_(base), length_(length),
+        limiter_(limiter) {
+  }
+
+  virtual ~PosixMmapReadableFile() {
+    munmap(mmapped_region_, length_);
+    limiter_->Release();
+  }
+
+  virtual Status Read(uint64_t offset, size_t n, Slice* result,
+                      char* scratch) const {
+    Status s;
+    if (offset + n > length_) {
+      *result = Slice();
+      s = IOError(filename_, EINVAL);
+    } else {
+      *result = Slice(reinterpret_cast<char*>(mmapped_region_) + offset, n);
+    }
+    return s;
+  }
+};
+
+class PosixWritableFile : public WritableFile {
+ private:
+  std::string filename_;
+  FILE* file_;
+
+ public:
+  PosixWritableFile(const std::string& fname, FILE* f)
+      : filename_(fname), file_(f) { }
+
+  ~PosixWritableFile() {
+    if (file_ != NULL) {
+      // Ignoring any potential errors
+      fclose(file_);
+    }
+  }
+
+  virtual Status Append(const Slice& data) {
+    size_t r = fwrite_unlocked(data.data(), 1, data.size(), file_);
+    if (r != data.size()) {
+      return IOError(filename_, errno);
+    }
+    return Status::OK();
+  }
+
+  virtual Status Close() {
+    Status result;
+    if (fclose(file_) != 0) {
+      result = IOError(filename_, errno);
+    }
+    file_ = NULL;
+    return result;
+  }
+
+  virtual Status Flush() {
+    if (fflush_unlocked(file_) != 0) {
+      return IOError(filename_, errno);
+    }
+    return Status::OK();
+  }
+
+  Status SyncDirIfManifest() {
+    const char* f = filename_.c_str();
+    const char* sep = strrchr(f, '/');
+    Slice basename;
+    std::string dir;
+    if (sep == NULL) {
+      dir = ".";
+      basename = f;
+    } else {
+      dir = std::string(f, sep - f);
+      basename = sep + 1;
+    }
+    Status s;
+    if (basename.starts_with("MANIFEST")) {
+      int fd = open(dir.c_str(), O_RDONLY);
+      if (fd < 0) {
+        s = IOError(dir, errno);
+      } else {
+        if (fsync(fd) < 0) {
+          s = IOError(dir, errno);
+        }
+        close(fd);
+      }
+    }
+    return s;
+  }
+
+  virtual Status Sync() {
+    // Ensure new files referred to by the manifest are in the filesystem.
+    Status s = SyncDirIfManifest();
+    if (!s.ok()) {
+      return s;
+    }
+    if (fflush_unlocked(file_) != 0 ||
+        fdatasync(fileno(file_)) != 0) {
+      s = Status::IOError(filename_, strerror(errno));
+    }
+    return s;
+  }
+};
+
+static int LockOrUnlock(int fd, bool lock) {
+  errno = 0;
+  struct flock f;
+  memset(&f, 0, sizeof(f));
+  f.l_type = (lock ? F_WRLCK : F_UNLCK);
+  f.l_whence = SEEK_SET;
+  f.l_start = 0;
+  f.l_len = 0;        // Lock/unlock entire file
+  return fcntl(fd, F_SETLK, &f);
+}
+
+class PosixFileLock : public FileLock {
+ public:
+  int fd_;
+  std::string name_;
+};
+
+// Set of locked files.  We keep a separate set instead of just
+// relying on fcntrl(F_SETLK) since fcntl(F_SETLK) does not provide
+// any protection against multiple uses from the same process.
+class PosixLockTable {
+ private:
+  port::Mutex mu_;
+  std::set<std::string> locked_files_;
+ public:
+  bool Insert(const std::string& fname) {
+    MutexLock l(&mu_);
+    return locked_files_.insert(fname).second;
+  }
+  void Remove(const std::string& fname) {
+    MutexLock l(&mu_);
+    locked_files_.erase(fname);
+  }
+};
+
+class PosixEnv : public Env {
+ public:
+  PosixEnv();
+  virtual ~PosixEnv() {
+    fprintf(stderr, "Destroying Env::Default()\n");
+    abort();
+  }
+
+  virtual Status NewSequentialFile(const std::string& fname,
+                                   SequentialFile** result) {
+    FILE* f = fopen(fname.c_str(), "r");
+    if (f == NULL) {
+      *result = NULL;
+      return IOError(fname, errno);
+    } else {
+      *result = new PosixSequentialFile(fname, f);
+      return Status::OK();
+    }
+  }
+
+  virtual Status NewRandomAccessFile(const std::string& fname,
+                                     RandomAccessFile** result) {
+    *result = NULL;
+    Status s;
+    int fd = open(fname.c_str(), O_RDONLY);
+    if (fd < 0) {
+      s = IOError(fname, errno);
+    } else if (mmap_limit_.Acquire()) {
+      uint64_t size;
+      s = GetFileSize(fname, &size);
+      if (s.ok()) {
+        void* base = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
+        if (base != MAP_FAILED) {
+          *result = new PosixMmapReadableFile(fname, base, size, &mmap_limit_);
+        } else {
+          s = IOError(fname, errno);
+        }
+      }
+      close(fd);
+      if (!s.ok()) {
+        mmap_limit_.Release();
+      }
+    } else {
+      *result = new PosixRandomAccessFile(fname, fd);
+    }
+    return s;
+  }
+
+  virtual Status NewWritableFile(const std::string& fname,
+                                 WritableFile** result) {
+    Status s;
+    FILE* f = fopen(fname.c_str(), "w");
+    if (f == NULL) {
+      *result = NULL;
+      s = IOError(fname, errno);
+    } else {
+      *result = new PosixWritableFile(fname, f);
+    }
+    return s;
+  }
+
+  virtual bool FileExists(const std::string& fname) {
+    return access(fname.c_str(), F_OK) == 0;
+  }
+
+  virtual Status GetChildren(const std::string& dir,
+                             std::vector<std::string>* result) {
+    result->clear();
+    DIR* d = opendir(dir.c_str());
+    if (d == NULL) {
+      return IOError(dir, errno);
+    }
+    struct dirent* entry;
+    while ((entry = readdir(d)) != NULL) {
+      result->push_back(entry->d_name);
+    }
+    closedir(d);
+    return Status::OK();
+  }
+
+  virtual Status DeleteFile(const std::string& fname) {
+    Status result;
+    if (unlink(fname.c_str()) != 0) {
+      result = IOError(fname, errno);
+    }
+    return result;
+  }
+
+  virtual Status CreateDir(const std::string& name) {
+    Status result;
+    if (mkdir(name.c_str(), 0755) != 0) {
+      result = IOError(name, errno);
+    }
+    return result;
+  }
+
+  virtual Status DeleteDir(const std::string& name) {
+    Status result;
+    if (rmdir(name.c_str()) != 0) {
+      result = IOError(name, errno);
+    }
+    return result;
+  }
+
+  virtual Status GetFileSize(const std::string& fname, uint64_t* size) {
+    Status s;
+    struct stat sbuf;
+    if (stat(fname.c_str(), &sbuf) != 0) {
+      *size = 0;
+      s = IOError(fname, errno);
+    } else {
+      *size = sbuf.st_size;
+    }
+    return s;
+  }
+
+  virtual Status RenameFile(const std::string& src, const std::string& target) {
+    Status result;
+    if (rename(src.c_str(), target.c_str()) != 0) {
+      result = IOError(src, errno);
+    }
+    return result;
+  }
+
+  virtual Status LockFile(const std::string& fname, FileLock** lock) {
+    *lock = NULL;
+    Status result;
+    int fd = open(fname.c_str(), O_RDWR | O_CREAT, 0644);
+    if (fd < 0) {
+      result = IOError(fname, errno);
+    } else if (!locks_.Insert(fname)) {
+      close(fd);
+      result = Status::IOError("lock " + fname, "already held by process");
+    } else if (LockOrUnlock(fd, true) == -1) {
+      result = IOError("lock " + fname, errno);
+      close(fd);
+      locks_.Remove(fname);
+    } else {
+      PosixFileLock* my_lock = new PosixFileLock;
+      my_lock->fd_ = fd;
+      my_lock->name_ = fname;
+      *lock = my_lock;
+    }
+    return result;
+  }
+
+  virtual Status UnlockFile(FileLock* lock) {
+    PosixFileLock* my_lock = reinterpret_cast<PosixFileLock*>(lock);
+    Status result;
+    if (LockOrUnlock(my_lock->fd_, false) == -1) {
+      result = IOError("unlock", errno);
+    }
+    locks_.Remove(my_lock->name_);
+    close(my_lock->fd_);
+    delete my_lock;
+    return result;
+  }
+
+  virtual void Schedule(void (*function)(void*), void* arg);
+
+  virtual void StartThread(void (*function)(void* arg), void* arg);
+
+  virtual Status GetTestDirectory(std::string* result) {
+    const char* env = getenv("TEST_TMPDIR");
+    if (env && env[0] != '\0') {
+      *result = env;
+    } else {
+      char buf[100];
+      snprintf(buf, sizeof(buf), "/tmp/leveldbtest-%d", int(geteuid()));
+      *result = buf;
+    }
+    // Directory may already exist
+    CreateDir(*result);
+    return Status::OK();
+  }
+
+  static uint64_t gettid() {
+    pthread_t tid = pthread_self();
+    uint64_t thread_id = 0;
+    memcpy(&thread_id, &tid, std::min(sizeof(thread_id), sizeof(tid)));
+    return thread_id;
+  }
+
+  virtual Status NewLogger(const std::string& fname, Logger** result) {
+    FILE* f = fopen(fname.c_str(), "w");
+    if (f == NULL) {
+      *result = NULL;
+      return IOError(fname, errno);
+    } else {
+      *result = new PosixLogger(f, &PosixEnv::gettid);
+      return Status::OK();
+    }
+  }
+
+  virtual uint64_t NowMicros() {
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    return static_cast<uint64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;
+  }
+
+  virtual void SleepForMicroseconds(int micros) {
+    usleep(micros);
+  }
+
+ private:
+  void PthreadCall(const char* label, int result) {
+    if (result != 0) {
+      fprintf(stderr, "pthread %s: %s\n", label, strerror(result));
+      abort();
+    }
+  }
+
+  // BGThread() is the body of the background thread
+  void BGThread();
+  static void* BGThreadWrapper(void* arg) {
+    reinterpret_cast<PosixEnv*>(arg)->BGThread();
+    return NULL;
+  }
+
+  pthread_mutex_t mu_;
+  pthread_cond_t bgsignal_;
+  pthread_t bgthread_;
+  bool started_bgthread_;
+
+  // Entry per Schedule() call
+  struct BGItem { void* arg; void (*function)(void*); };
+  typedef std::deque<BGItem> BGQueue;
+  BGQueue queue_;
+
+  PosixLockTable locks_;
+  MmapLimiter mmap_limit_;
+};
+
+PosixEnv::PosixEnv() : started_bgthread_(false) {
+  PthreadCall("mutex_init", pthread_mutex_init(&mu_, NULL));
+  PthreadCall("cvar_init", pthread_cond_init(&bgsignal_, NULL));
+}
+
+void PosixEnv::Schedule(void (*function)(void*), void* arg) {
+  PthreadCall("lock", pthread_mutex_lock(&mu_));
+
+  // Start background thread if necessary
+  if (!started_bgthread_) {
+    started_bgthread_ = true;
+    PthreadCall(
+        "create thread",
+        pthread_create(&bgthread_, NULL,  &PosixEnv::BGThreadWrapper, this));
+  }
+
+  // If the queue is currently empty, the background thread may currently be
+  // waiting.
+  if (queue_.empty()) {
+    PthreadCall("signal", pthread_cond_signal(&bgsignal_));
+  }
+
+  // Add to priority queue
+  queue_.push_back(BGItem());
+  queue_.back().function = function;
+  queue_.back().arg = arg;
+
+  PthreadCall("unlock", pthread_mutex_unlock(&mu_));
+}
+
+void PosixEnv::BGThread() {
+  while (true) {
+    // Wait until there is an item that is ready to run
+    PthreadCall("lock", pthread_mutex_lock(&mu_));
+    while (queue_.empty()) {
+      PthreadCall("wait", pthread_cond_wait(&bgsignal_, &mu_));
+    }
+
+    void (*function)(void*) = queue_.front().function;
+    void* arg = queue_.front().arg;
+    queue_.pop_front();
+
+    PthreadCall("unlock", pthread_mutex_unlock(&mu_));
+    (*function)(arg);
+  }
+}
+
+namespace {
+struct StartThreadState {
+  void (*user_function)(void*);
+  void* arg;
+};
+}
+static void* StartThreadWrapper(void* arg) {
+  StartThreadState* state = reinterpret_cast<StartThreadState*>(arg);
+  state->user_function(state->arg);
+  delete state;
+  return NULL;
+}
+
+void PosixEnv::StartThread(void (*function)(void* arg), void* arg) {
+  pthread_t t;
+  StartThreadState* state = new StartThreadState;
+  state->user_function = function;
+  state->arg = arg;
+  PthreadCall("start thread",
+              pthread_create(&t, NULL,  &StartThreadWrapper, state));
+}
+
+}  // namespace
+
+static pthread_once_t once = PTHREAD_ONCE_INIT;
+static Env* default_env;
+static void InitDefaultEnv() { default_env = new PosixEnv; }
+
+Env* Env::Default() {
+  pthread_once(&once, InitDefaultEnv);
+  return default_env;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/env_win.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/env_win.cc
new file mode 100644
index 0000000..d103f18
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/env_win.cc
@@ -0,0 +1,1015 @@
+// This file contains source that originates from:
+// http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/env_win32.h
+// http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/port_win32.cc
+// Those files dont' have any explict license headers but the 
+// project (http://code.google.com/p/leveldbwin/) lists the 'New BSD License'
+// as the license.
+#if defined(LEVELDB_PLATFORM_WINDOWS)
+#include <map>
+
+
+#include "leveldb/env.h"
+
+#include "port/port.h"
+#include "leveldb/slice.h"
+#include "util/logging.h"
+
+#include <Shlwapi.h>
+#include <process.h>
+#include <cstring>
+#include <stdio.h>
+#include <errno.h>
+#include <io.h>
+#include <DbgHelp.h>
+#include <algorithm>
+#pragma comment(lib,"DbgHelp.lib")
+
+#ifdef max
+#undef max
+#endif
+
+#ifndef va_copy
+#define va_copy(d,s) ((d) = (s))
+#endif
+
+#if defined DeleteFile
+#undef DeleteFile
+#endif
+
+//Declarations
+namespace leveldb
+{
+
+namespace Win32
+{
+
+#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
+  TypeName(const TypeName&);               \
+  void operator=(const TypeName&)
+
+std::string GetCurrentDir();
+std::wstring GetCurrentDirW();
+
+static const std::string CurrentDir = GetCurrentDir();
+static const std::wstring CurrentDirW = GetCurrentDirW();
+
+std::string& ModifyPath(std::string& path);
+std::wstring& ModifyPath(std::wstring& path);
+
+std::string GetLastErrSz();
+std::wstring GetLastErrSzW();
+
+size_t GetPageSize();
+
+typedef void (*ScheduleProc)(void*) ;
+
+struct WorkItemWrapper
+{
+    WorkItemWrapper(ScheduleProc proc_,void* content_);
+    ScheduleProc proc;
+    void* pContent;
+};
+
+DWORD WINAPI WorkItemWrapperProc(LPVOID pContent);
+
+class Win32SequentialFile : public SequentialFile
+{
+public:
+    friend class Win32Env;
+    virtual ~Win32SequentialFile();
+    virtual Status Read(size_t n, Slice* result, char* scratch);
+    virtual Status Skip(uint64_t n);
+    BOOL isEnable();
+private:
+    BOOL _Init();
+    void _CleanUp();
+    Win32SequentialFile(const std::string& fname);
+    std::string _filename;
+    ::HANDLE _hFile;
+    DISALLOW_COPY_AND_ASSIGN(Win32SequentialFile);
+};
+
+class Win32RandomAccessFile : public RandomAccessFile
+{
+public:
+    friend class Win32Env;
+    virtual ~Win32RandomAccessFile();
+    virtual Status Read(uint64_t offset, size_t n, Slice* result,char* scratch) const;
+    BOOL isEnable();
+private:
+    BOOL _Init(LPCWSTR path);
+    void _CleanUp();
+    Win32RandomAccessFile(const std::string& fname);
+    HANDLE _hFile;
+    const std::string _filename;
+    DISALLOW_COPY_AND_ASSIGN(Win32RandomAccessFile);
+};
+
+class Win32MapFile : public WritableFile
+{
+public:
+    Win32MapFile(const std::string& fname);
+
+    ~Win32MapFile();
+    virtual Status Append(const Slice& data);
+    virtual Status Close();
+    virtual Status Flush();
+    virtual Status Sync();
+    BOOL isEnable();
+private:
+    std::string _filename;
+    HANDLE _hFile;
+    size_t _page_size;
+    size_t _map_size;       // How much extra memory to map at a time
+    char* _base;            // The mapped region
+    HANDLE _base_handle;	
+    char* _limit;           // Limit of the mapped region
+    char* _dst;             // Where to write next  (in range [base_,limit_])
+    char* _last_sync;       // Where have we synced up to
+    uint64_t _file_offset;  // Offset of base_ in file
+    //LARGE_INTEGER file_offset_;
+    // Have we done an munmap of unsynced data?
+    bool _pending_sync;
+
+    // Roundup x to a multiple of y
+    static size_t _Roundup(size_t x, size_t y);
+    size_t _TruncateToPageBoundary(size_t s);
+    bool _UnmapCurrentRegion();
+    bool _MapNewRegion();
+    DISALLOW_COPY_AND_ASSIGN(Win32MapFile);
+    BOOL _Init(LPCWSTR Path);
+};
+
+class Win32FileLock : public FileLock
+{
+public:
+    friend class Win32Env;
+    virtual ~Win32FileLock();
+    BOOL isEnable();
+private:
+    BOOL _Init(LPCWSTR path);
+    void _CleanUp();
+    Win32FileLock(const std::string& fname);
+    HANDLE _hFile;
+    std::string _filename;
+    DISALLOW_COPY_AND_ASSIGN(Win32FileLock);
+};
+
+class Win32Logger : public Logger
+{
+public: 
+    friend class Win32Env;
+    virtual ~Win32Logger();
+    virtual void Logv(const char* format, va_list ap);
+private:
+    explicit Win32Logger(WritableFile* pFile);
+    WritableFile* _pFileProxy;
+    DISALLOW_COPY_AND_ASSIGN(Win32Logger);
+};
+
+class Win32Env : public Env
+{
+public:
+    Win32Env();
+    virtual ~Win32Env();
+    virtual Status NewSequentialFile(const std::string& fname,
+        SequentialFile** result);
+
+    virtual Status NewRandomAccessFile(const std::string& fname,
+        RandomAccessFile** result);
+    virtual Status NewWritableFile(const std::string& fname,
+        WritableFile** result);
+
+    virtual bool FileExists(const std::string& fname);
+
+    virtual Status GetChildren(const std::string& dir,
+        std::vector<std::string>* result);
+
+    virtual Status DeleteFile(const std::string& fname);
+
+    virtual Status CreateDir(const std::string& dirname);
+
+    virtual Status DeleteDir(const std::string& dirname);
+
+    virtual Status GetFileSize(const std::string& fname, uint64_t* file_size);
+
+    virtual Status RenameFile(const std::string& src,
+        const std::string& target);
+
+    virtual Status LockFile(const std::string& fname, FileLock** lock);
+
+    virtual Status UnlockFile(FileLock* lock);
+
+    virtual void Schedule(
+        void (*function)(void* arg),
+        void* arg);
+
+    virtual void StartThread(void (*function)(void* arg), void* arg);
+
+    virtual Status GetTestDirectory(std::string* path);
+
+    virtual Status NewLogger(const std::string& fname, Logger** result);
+
+    virtual uint64_t NowMicros();
+
+    virtual void SleepForMicroseconds(int micros);
+};
+
+void ToWidePath(const std::string& value, std::wstring& target) {
+	wchar_t buffer[MAX_PATH];
+	MultiByteToWideChar(CP_ACP, 0, value.c_str(), -1, buffer, MAX_PATH);
+	target = buffer;
+}
+
+void ToNarrowPath(const std::wstring& value, std::string& target) {
+	char buffer[MAX_PATH];
+	WideCharToMultiByte(CP_ACP, 0, value.c_str(), -1, buffer, MAX_PATH, NULL, NULL);
+	target = buffer;
+}
+
+std::string GetCurrentDir()
+{
+    CHAR path[MAX_PATH];
+    ::GetModuleFileNameA(::GetModuleHandleA(NULL),path,MAX_PATH);
+    *strrchr(path,'\\') = 0;
+    return std::string(path);
+}
+
+std::wstring GetCurrentDirW()
+{
+    WCHAR path[MAX_PATH];
+    ::GetModuleFileNameW(::GetModuleHandleW(NULL),path,MAX_PATH);
+    *wcsrchr(path,L'\\') = 0;
+    return std::wstring(path);
+}
+
+std::string& ModifyPath(std::string& path)
+{
+    if(path[0] == '/' || path[0] == '\\'){
+        path = CurrentDir + path;
+    }
+    std::replace(path.begin(),path.end(),'/','\\');
+
+    return path;
+}
+
+std::wstring& ModifyPath(std::wstring& path)
+{
+    if(path[0] == L'/' || path[0] == L'\\'){
+        path = CurrentDirW + path;
+    }
+    std::replace(path.begin(),path.end(),L'/',L'\\');
+    return path;
+}
+
+std::string GetLastErrSz()
+{
+    LPWSTR lpMsgBuf;
+    FormatMessageW( 
+        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
+        FORMAT_MESSAGE_FROM_SYSTEM | 
+        FORMAT_MESSAGE_IGNORE_INSERTS,
+        NULL,
+        GetLastError(),
+        0, // Default language
+        (LPWSTR) &lpMsgBuf,
+        0,
+        NULL 
+        );
+    std::string Err;
+	ToNarrowPath(lpMsgBuf, Err); 
+    LocalFree( lpMsgBuf );
+    return Err;
+}
+
+std::wstring GetLastErrSzW()
+{
+    LPVOID lpMsgBuf;
+    FormatMessageW( 
+        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
+        FORMAT_MESSAGE_FROM_SYSTEM | 
+        FORMAT_MESSAGE_IGNORE_INSERTS,
+        NULL,
+        GetLastError(),
+        0, // Default language
+        (LPWSTR) &lpMsgBuf,
+        0,
+        NULL 
+        );
+    std::wstring Err = (LPCWSTR)lpMsgBuf;
+    LocalFree(lpMsgBuf);
+    return Err;
+}
+
+WorkItemWrapper::WorkItemWrapper( ScheduleProc proc_,void* content_ ) :
+    proc(proc_),pContent(content_)
+{
+
+}
+
+DWORD WINAPI WorkItemWrapperProc(LPVOID pContent)
+{
+    WorkItemWrapper* item = static_cast<WorkItemWrapper*>(pContent);
+    ScheduleProc TempProc = item->proc;
+    void* arg = item->pContent;
+    delete item;
+    TempProc(arg);
+    return 0;
+}
+
+size_t GetPageSize()
+{
+    SYSTEM_INFO si;
+    GetSystemInfo(&si);
+    return std::max(si.dwPageSize,si.dwAllocationGranularity);
+}
+
+const size_t g_PageSize = GetPageSize();
+
+
+Win32SequentialFile::Win32SequentialFile( const std::string& fname ) :
+    _filename(fname),_hFile(NULL)
+{
+    _Init();
+}
+
+Win32SequentialFile::~Win32SequentialFile()
+{
+    _CleanUp();
+}
+
+Status Win32SequentialFile::Read( size_t n, Slice* result, char* scratch )
+{
+    Status sRet;
+    DWORD hasRead = 0;
+    if(_hFile && ReadFile(_hFile,scratch,n,&hasRead,NULL) ){
+        *result = Slice(scratch,hasRead);
+    } else {
+        sRet = Status::IOError(_filename, Win32::GetLastErrSz() );
+    }
+    return sRet;
+}
+
+Status Win32SequentialFile::Skip( uint64_t n )
+{
+    Status sRet;
+    LARGE_INTEGER Move,NowPointer;
+    Move.QuadPart = n;
+    if(!SetFilePointerEx(_hFile,Move,&NowPointer,FILE_CURRENT)){
+        sRet = Status::IOError(_filename,Win32::GetLastErrSz());
+    }
+    return sRet;
+}
+
+BOOL Win32SequentialFile::isEnable()
+{
+    return _hFile ? TRUE : FALSE;
+}
+
+BOOL Win32SequentialFile::_Init()
+{
+	std::wstring path;
+	ToWidePath(_filename, path);
+	_hFile = CreateFileW(path.c_str(),
+                         GENERIC_READ,
+                         FILE_SHARE_READ | FILE_SHARE_WRITE,
+                         NULL,
+                         OPEN_EXISTING,
+                         FILE_ATTRIBUTE_NORMAL,
+                         NULL);
+    return _hFile ? TRUE : FALSE;
+}
+
+void Win32SequentialFile::_CleanUp()
+{
+    if(_hFile){
+        CloseHandle(_hFile);
+        _hFile = NULL;
+    }
+}
+
+Win32RandomAccessFile::Win32RandomAccessFile( const std::string& fname ) :
+    _filename(fname),_hFile(NULL)
+{
+	std::wstring path;
+	ToWidePath(fname, path);
+    _Init( path.c_str() );
+}
+
+Win32RandomAccessFile::~Win32RandomAccessFile()
+{
+    _CleanUp();
+}
+
+Status Win32RandomAccessFile::Read(uint64_t offset,size_t n,Slice* result,char* scratch) const
+{
+    Status sRet;
+    OVERLAPPED ol = {0};
+    ZeroMemory(&ol,sizeof(ol));
+    ol.Offset = (DWORD)offset;
+    ol.OffsetHigh = (DWORD)(offset >> 32);
+    DWORD hasRead = 0;
+    if(!ReadFile(_hFile,scratch,n,&hasRead,&ol))
+        sRet = Status::IOError(_filename,Win32::GetLastErrSz());
+    else
+        *result = Slice(scratch,hasRead);
+    return sRet;
+}
+
+BOOL Win32RandomAccessFile::_Init( LPCWSTR path )
+{
+    BOOL bRet = FALSE;
+    if(!_hFile)
+        _hFile = ::CreateFileW(path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
+        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,NULL);
+    if(!_hFile || _hFile == INVALID_HANDLE_VALUE )
+        _hFile = NULL;
+    else
+        bRet = TRUE;
+    return bRet;
+}
+
+BOOL Win32RandomAccessFile::isEnable()
+{
+    return _hFile ? TRUE : FALSE;
+}
+
+void Win32RandomAccessFile::_CleanUp()
+{
+    if(_hFile){
+        ::CloseHandle(_hFile);
+        _hFile = NULL;
+    }
+}
+
+size_t Win32MapFile::_Roundup( size_t x, size_t y )
+{
+    return ((x + y - 1) / y) * y;
+}
+
+size_t Win32MapFile::_TruncateToPageBoundary( size_t s )
+{
+    s -= (s & (_page_size - 1));
+    assert((s % _page_size) == 0);
+    return s;
+}
+
+bool Win32MapFile::_UnmapCurrentRegion()
+{
+    bool result = true;
+    if (_base != NULL) {
+        if (_last_sync < _limit) {
+            // Defer syncing this data until next Sync() call, if any
+            _pending_sync = true;
+        }
+        UnmapViewOfFile(_base);
+        CloseHandle(_base_handle);
+        _file_offset += _limit - _base;
+        _base = NULL;
+        _base_handle = NULL;
+        _limit = NULL;
+        _last_sync = NULL;
+        _dst = NULL;
+        // Increase the amount we map the next time, but capped at 1MB
+        if (_map_size < (1<<20)) {
+            _map_size *= 2;
+        }
+    }
+    return result;
+}
+
+bool Win32MapFile::_MapNewRegion()
+{
+    assert(_base == NULL);
+    //LONG newSizeHigh = (LONG)((file_offset_ + map_size_) >> 32);
+    //LONG newSizeLow = (LONG)((file_offset_ + map_size_) & 0xFFFFFFFF);
+    DWORD off_hi = (DWORD)(_file_offset >> 32);
+    DWORD off_lo = (DWORD)(_file_offset & 0xFFFFFFFF);
+    LARGE_INTEGER newSize;
+    newSize.QuadPart = _file_offset + _map_size;
+    SetFilePointerEx(_hFile, newSize, NULL, FILE_BEGIN);
+    SetEndOfFile(_hFile);
+
+    _base_handle = CreateFileMappingA(
+        _hFile,
+        NULL,
+        PAGE_READWRITE,
+        0,
+        0,
+        0);
+    if (_base_handle != NULL) {
+        _base = (char*) MapViewOfFile(_base_handle,
+            FILE_MAP_ALL_ACCESS,
+            off_hi,
+            off_lo,
+            _map_size);
+        if (_base != NULL) {
+            _limit = _base + _map_size;
+            _dst = _base;
+            _last_sync = _base;
+            return true;
+        }
+    }
+    return false;
+}
+
+Win32MapFile::Win32MapFile( const std::string& fname) :
+    _filename(fname),
+    _hFile(NULL),
+    _page_size(Win32::g_PageSize),
+    _map_size(_Roundup(65536, Win32::g_PageSize)),
+    _base(NULL),
+    _base_handle(NULL),
+    _limit(NULL),
+    _dst(NULL),
+    _last_sync(NULL),
+    _file_offset(0),
+    _pending_sync(false)
+{
+	std::wstring path;
+	ToWidePath(fname, path);
+    _Init(path.c_str());
+    assert((Win32::g_PageSize & (Win32::g_PageSize - 1)) == 0);
+}
+
+Status Win32MapFile::Append( const Slice& data )
+{
+    const char* src = data.data();
+    size_t left = data.size();
+    Status s;
+    while (left > 0) {
+        assert(_base <= _dst);
+        assert(_dst <= _limit);
+        size_t avail = _limit - _dst;
+        if (avail == 0) {
+            if (!_UnmapCurrentRegion() ||
+                !_MapNewRegion()) {
+                    return Status::IOError("WinMmapFile.Append::UnmapCurrentRegion or MapNewRegion: ", Win32::GetLastErrSz());
+            }
+        }
+        size_t n = (left <= avail) ? left : avail;
+        memcpy(_dst, src, n);
+        _dst += n;
+        src += n;
+        left -= n;
+    }
+    return s;
+}
+
+Status Win32MapFile::Close()
+{
+    Status s;
+    size_t unused = _limit - _dst;
+    if (!_UnmapCurrentRegion()) {
+        s = Status::IOError("WinMmapFile.Close::UnmapCurrentRegion: ",Win32::GetLastErrSz());
+    } else if (unused > 0) {
+        // Trim the extra space at the end of the file
+        LARGE_INTEGER newSize;
+        newSize.QuadPart = _file_offset - unused;
+        if (!SetFilePointerEx(_hFile, newSize, NULL, FILE_BEGIN)) {
+            s = Status::IOError("WinMmapFile.Close::SetFilePointer: ",Win32::GetLastErrSz());
+        } else 
+            SetEndOfFile(_hFile);
+    }
+    if (!CloseHandle(_hFile)) {
+        if (s.ok()) {
+            s = Status::IOError("WinMmapFile.Close::CloseHandle: ", Win32::GetLastErrSz());
+        }
+    }
+    _hFile = INVALID_HANDLE_VALUE;
+    _base = NULL;
+    _base_handle = NULL;
+    _limit = NULL;
+
+    return s;
+}
+
+Status Win32MapFile::Sync()
+{
+    Status s;
+    if (_pending_sync) {
+        // Some unmapped data was not synced
+        _pending_sync = false;
+        if (!FlushFileBuffers(_hFile)) {
+            s = Status::IOError("WinMmapFile.Sync::FlushFileBuffers: ",Win32::GetLastErrSz());
+        }
+    }
+    if (_dst > _last_sync) {
+        // Find the beginnings of the pages that contain the first and last
+        // bytes to be synced.
+        size_t p1 = _TruncateToPageBoundary(_last_sync - _base);
+        size_t p2 = _TruncateToPageBoundary(_dst - _base - 1);
+        _last_sync = _dst;
+        if (!FlushViewOfFile(_base + p1, p2 - p1 + _page_size)) {
+            s = Status::IOError("WinMmapFile.Sync::FlushViewOfFile: ",Win32::GetLastErrSz());
+        }
+    }
+    return s;
+}
+
+Status Win32MapFile::Flush()
+{
+    return Status::OK();
+}
+
+Win32MapFile::~Win32MapFile()
+{
+    if (_hFile != INVALID_HANDLE_VALUE) { 
+        Win32MapFile::Close();
+    }
+}
+
+BOOL Win32MapFile::_Init( LPCWSTR Path )
+{
+    DWORD Flag = PathFileExistsW(Path) ? OPEN_EXISTING : CREATE_ALWAYS;
+    _hFile = CreateFileW(Path,
+                         GENERIC_READ | GENERIC_WRITE,
+                         FILE_SHARE_READ|FILE_SHARE_DELETE|FILE_SHARE_WRITE,
+                         NULL,
+                         Flag,
+                         FILE_ATTRIBUTE_NORMAL,
+                         NULL);
+    if(!_hFile || _hFile == INVALID_HANDLE_VALUE)
+        return FALSE;
+    else
+        return TRUE;
+}
+
+BOOL Win32MapFile::isEnable()
+{
+    return _hFile && _hFile != INVALID_HANDLE_VALUE ? TRUE : FALSE;
+}
+
+Win32FileLock::Win32FileLock( const std::string& fname ) :
+    _hFile(NULL),_filename(fname)
+{
+	std::wstring path;
+	ToWidePath(fname, path);
+	_Init(path.c_str());
+}
+
+Win32FileLock::~Win32FileLock()
+{
+    _CleanUp();
+}
+
+BOOL Win32FileLock::_Init( LPCWSTR path )
+{
+    BOOL bRet = FALSE;
+    if (!_hFile)
+        _hFile = ::CreateFileW(path, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    if(!_hFile || _hFile == INVALID_HANDLE_VALUE ){
+        _hFile = NULL;
+    }
+    else
+        bRet = TRUE;
+    return bRet;
+}
+
+void Win32FileLock::_CleanUp()
+{
+    ::CloseHandle(_hFile);
+    _hFile = NULL;
+}
+
+BOOL Win32FileLock::isEnable()
+{
+    return _hFile ? TRUE : FALSE;
+}
+
+Win32Logger::Win32Logger(WritableFile* pFile) : _pFileProxy(pFile)
+{
+    assert(_pFileProxy);
+}
+
+Win32Logger::~Win32Logger()
+{
+    if(_pFileProxy)
+        delete _pFileProxy;
+}
+
+void Win32Logger::Logv( const char* format, va_list ap )
+{
+    uint64_t thread_id = ::GetCurrentThreadId();
+
+    // We try twice: the first time with a fixed-size stack allocated buffer,
+    // and the second time with a much larger dynamically allocated buffer.
+    char buffer[500];
+    for (int iter = 0; iter < 2; iter++) {
+        char* base;
+        int bufsize;
+        if (iter == 0) {
+            bufsize = sizeof(buffer);
+            base = buffer;
+        } else {
+            bufsize = 30000;
+            base = new char[bufsize];
+        }
+        char* p = base;
+        char* limit = base + bufsize;
+
+        SYSTEMTIME st;
+        GetLocalTime(&st);
+        p += snprintf(p, limit - p,
+            "%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx ",
+            int(st.wYear),
+            int(st.wMonth),
+            int(st.wDay),
+            int(st.wHour),
+            int(st.wMinute),
+            int(st.wMinute),
+            int(st.wMilliseconds),
+            static_cast<long long unsigned int>(thread_id));
+
+        // Print the message
+        if (p < limit) {
+            va_list backup_ap;
+            va_copy(backup_ap, ap);
+            p += vsnprintf(p, limit - p, format, backup_ap);
+            va_end(backup_ap);
+        }
+
+        // Truncate to available space if necessary
+        if (p >= limit) {
+            if (iter == 0) {
+                continue;       // Try again with larger buffer
+            } else {
+                p = limit - 1;
+            }
+        }
+
+        // Add newline if necessary
+        if (p == base || p[-1] != '\n') {
+            *p++ = '\n';
+        }
+
+        assert(p <= limit);
+        DWORD hasWritten = 0;
+        if(_pFileProxy){
+            _pFileProxy->Append(Slice(base, p - base));
+            _pFileProxy->Flush();
+        }
+        if (base != buffer) {
+            delete[] base;
+        }
+        break;
+    }
+}
+
+bool Win32Env::FileExists(const std::string& fname)
+{
+	std::string path = fname;
+    std::wstring wpath;
+	ToWidePath(ModifyPath(path), wpath);
+    return ::PathFileExistsW(wpath.c_str()) ? true : false;
+}
+
+Status Win32Env::GetChildren(const std::string& dir, std::vector<std::string>* result)
+{
+    Status sRet;
+    ::WIN32_FIND_DATAW wfd;
+    std::string path = dir;
+    ModifyPath(path);
+    path += "\\*.*";
+	std::wstring wpath;
+	ToWidePath(path, wpath);
+
+	::HANDLE hFind = ::FindFirstFileW(wpath.c_str() ,&wfd);
+    if(hFind && hFind != INVALID_HANDLE_VALUE){
+        BOOL hasNext = TRUE;
+        std::string child;
+        while(hasNext){
+            ToNarrowPath(wfd.cFileName, child); 
+            if(child != ".." && child != ".")  {
+                result->push_back(child);
+            }
+            hasNext = ::FindNextFileW(hFind,&wfd);
+        }
+        ::FindClose(hFind);
+    }
+    else
+        sRet = Status::IOError(dir,"Could not get children.");
+    return sRet;
+}
+
+void Win32Env::SleepForMicroseconds( int micros )
+{
+    ::Sleep((micros + 999) /1000);
+}
+
+
+Status Win32Env::DeleteFile( const std::string& fname )
+{
+    Status sRet;
+    std::string path = fname;
+    std::wstring wpath;
+	ToWidePath(ModifyPath(path), wpath);
+
+    if(!::DeleteFileW(wpath.c_str())) {
+        sRet = Status::IOError(path, "Could not delete file.");
+    }
+    return sRet;
+}
+
+Status Win32Env::GetFileSize( const std::string& fname, uint64_t* file_size )
+{
+    Status sRet;
+    std::string path = fname;
+    std::wstring wpath;
+	ToWidePath(ModifyPath(path), wpath);
+
+    HANDLE file = ::CreateFileW(wpath.c_str(),
+        GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
+    LARGE_INTEGER li;
+    if(::GetFileSizeEx(file,&li)){
+        *file_size = (uint64_t)li.QuadPart;
+    }else
+        sRet = Status::IOError(path,"Could not get the file size.");
+    CloseHandle(file);
+    return sRet;
+}
+
+Status Win32Env::RenameFile( const std::string& src, const std::string& target )
+{
+    Status sRet;
+    std::string src_path = src;
+    std::wstring wsrc_path;
+	ToWidePath(ModifyPath(src_path), wsrc_path);
+	std::string target_path = target;
+    std::wstring wtarget_path;
+	ToWidePath(ModifyPath(target_path), wtarget_path);
+
+    if(!MoveFileW(wsrc_path.c_str(), wtarget_path.c_str() ) ){
+        DWORD err = GetLastError();
+        if(err == 0x000000b7){
+            if(!::DeleteFileW(wtarget_path.c_str() ) )
+                sRet = Status::IOError(src, "Could not rename file.");
+			else if(!::MoveFileW(wsrc_path.c_str(),
+                                 wtarget_path.c_str() ) )
+                sRet = Status::IOError(src, "Could not rename file.");    
+        }
+    }
+    return sRet;
+}
+
+Status Win32Env::LockFile( const std::string& fname, FileLock** lock )
+{
+    Status sRet;
+    std::string path = fname;
+    ModifyPath(path);
+    Win32FileLock* _lock = new Win32FileLock(path);
+    if(!_lock->isEnable()){
+        delete _lock;
+        *lock = NULL;
+        sRet = Status::IOError(path, "Could not lock file.");
+    }
+    else
+        *lock = _lock;
+    return sRet;
+}
+
+Status Win32Env::UnlockFile( FileLock* lock )
+{
+    Status sRet;
+    delete lock;
+    return sRet;
+}
+
+void Win32Env::Schedule( void (*function)(void* arg), void* arg )
+{
+    QueueUserWorkItem(Win32::WorkItemWrapperProc,
+                      new Win32::WorkItemWrapper(function,arg),
+                      WT_EXECUTEDEFAULT);
+}
+
+void Win32Env::StartThread( void (*function)(void* arg), void* arg )
+{
+    ::_beginthread(function,0,arg);
+}
+
+Status Win32Env::GetTestDirectory( std::string* path )
+{
+    Status sRet;
+    WCHAR TempPath[MAX_PATH];
+    ::GetTempPathW(MAX_PATH,TempPath);
+	ToNarrowPath(TempPath, *path);
+    path->append("leveldb\\test\\");
+    ModifyPath(*path);
+    return sRet;
+}
+
+uint64_t Win32Env::NowMicros()
+{
+#ifndef USE_VISTA_API
+#define GetTickCount64 GetTickCount
+#endif
+    return (uint64_t)(GetTickCount64()*1000);
+}
+
+Status Win32Env::CreateDir( const std::string& dirname )
+{
+    Status sRet;
+    std::string path = dirname;
+    if(path[path.length() - 1] != '\\'){
+        path += '\\';
+    }
+    ModifyPath(path);
+    if(!::MakeSureDirectoryPathExists( path.c_str() ) ){
+        sRet = Status::IOError(dirname, "Could not create directory.");
+    }
+    return sRet;
+}
+
+Status Win32Env::DeleteDir( const std::string& dirname )
+{
+    Status sRet;
+    std::wstring path;
+	ToWidePath(dirname, path);
+    ModifyPath(path);
+    if(!::RemoveDirectoryW( path.c_str() ) ){
+        sRet = Status::IOError(dirname, "Could not delete directory.");
+    }
+    return sRet;
+}
+
+Status Win32Env::NewSequentialFile( const std::string& fname, SequentialFile** result )
+{
+    Status sRet;
+    std::string path = fname;
+    ModifyPath(path);
+    Win32SequentialFile* pFile = new Win32SequentialFile(path);
+    if(pFile->isEnable()){
+        *result = pFile;
+    }else {
+        delete pFile;
+        sRet = Status::IOError(path, Win32::GetLastErrSz());
+    }
+    return sRet;
+}
+
+Status Win32Env::NewRandomAccessFile( const std::string& fname, RandomAccessFile** result )
+{
+    Status sRet;
+    std::string path = fname;
+    Win32RandomAccessFile* pFile = new Win32RandomAccessFile(ModifyPath(path));
+    if(!pFile->isEnable()){
+        delete pFile;
+        *result = NULL;
+        sRet = Status::IOError(path,"Could not create random access file.");
+    }else
+        *result = pFile;
+    return sRet;
+}
+
+Status Win32Env::NewLogger( const std::string& fname, Logger** result )
+{
+    Status sRet;
+    std::string path = fname;
+    Win32MapFile* pMapFile = new Win32MapFile(ModifyPath(path));
+    if(!pMapFile->isEnable()){
+        delete pMapFile;
+        *result = NULL;
+        sRet = Status::IOError(path,"could not create a logger.");
+    }else
+        *result = new Win32Logger(pMapFile);
+    return sRet;
+}
+
+Status Win32Env::NewWritableFile( const std::string& fname, WritableFile** result )
+{
+    Status sRet;
+    std::string path = fname;
+    Win32MapFile* pFile = new Win32MapFile(ModifyPath(path));
+    if(!pFile->isEnable()){
+        *result = NULL;
+        sRet = Status::IOError(fname,Win32::GetLastErrSz());
+    }else
+        *result = pFile;
+    return sRet;
+}
+
+Win32Env::Win32Env()
+{
+
+}
+
+Win32Env::~Win32Env()
+{
+
+}
+
+
+}  // Win32 namespace
+
+static port::OnceType once_env = LEVELDB_ONCE_INIT;
+static Env* default_env;
+static void InitDefaultEnv() { default_env = new Win32::Win32Env(); }
+
+Env* Env::Default() {
+  port::InitOnce(&once_env, InitDefaultEnv);
+  return default_env;
+}
+
+}  // namespace leveldb
+
+#endif // defined(LEVELDB_PLATFORM_WINDOWS)
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/filter_policy.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/filter_policy.cc
new file mode 100644
index 0000000..7b045c8
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/filter_policy.cc
@@ -0,0 +1,11 @@
+// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "leveldb/filter_policy.h"
+
+namespace leveldb {
+
+FilterPolicy::~FilterPolicy() { }
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/hash.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/hash.cc
new file mode 100644
index 0000000..07cf022
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/hash.cc
@@ -0,0 +1,52 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include <string.h>
+#include "util/coding.h"
+#include "util/hash.h"
+
+// The FALLTHROUGH_INTENDED macro can be used to annotate implicit fall-through
+// between switch labels. The real definition should be provided externally.
+// This one is a fallback version for unsupported compilers.
+#ifndef FALLTHROUGH_INTENDED
+#define FALLTHROUGH_INTENDED do { } while (0)
+#endif
+
+namespace leveldb {
+
+uint32_t Hash(const char* data, size_t n, uint32_t seed) {
+  // Similar to murmur hash
+  const uint32_t m = 0xc6a4a793;
+  const uint32_t r = 24;
+  const char* limit = data + n;
+  uint32_t h = seed ^ (n * m);
+
+  // Pick up four bytes at a time
+  while (data + 4 <= limit) {
+    uint32_t w = DecodeFixed32(data);
+    data += 4;
+    h += w;
+    h *= m;
+    h ^= (h >> 16);
+  }
+
+  // Pick up remaining bytes
+  switch (limit - data) {
+    case 3:
+      h += data[2] << 16;
+      FALLTHROUGH_INTENDED;
+    case 2:
+      h += data[1] << 8;
+      FALLTHROUGH_INTENDED;
+    case 1:
+      h += data[0];
+      h *= m;
+      h ^= (h >> r);
+      break;
+  }
+  return h;
+}
+
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/hash.h b/packages/LevelDB.1.16.0.5/lib/native/src/util/hash.h
new file mode 100644
index 0000000..8889d56
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/hash.h
@@ -0,0 +1,19 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// Simple hash function used for internal data structures
+
+#ifndef STORAGE_LEVELDB_UTIL_HASH_H_
+#define STORAGE_LEVELDB_UTIL_HASH_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+namespace leveldb {
+
+extern uint32_t Hash(const char* data, size_t n, uint32_t seed);
+
+}
+
+#endif  // STORAGE_LEVELDB_UTIL_HASH_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/histogram.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/histogram.cc
new file mode 100644
index 0000000..bb95f58
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/histogram.cc
@@ -0,0 +1,139 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include <math.h>
+#include <stdio.h>
+#include "port/port.h"
+#include "util/histogram.h"
+
+namespace leveldb {
+
+const double Histogram::kBucketLimit[kNumBuckets] = {
+  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18, 20, 25, 30, 35, 40, 45,
+  50, 60, 70, 80, 90, 100, 120, 140, 160, 180, 200, 250, 300, 350, 400, 450,
+  500, 600, 700, 800, 900, 1000, 1200, 1400, 1600, 1800, 2000, 2500, 3000,
+  3500, 4000, 4500, 5000, 6000, 7000, 8000, 9000, 10000, 12000, 14000,
+  16000, 18000, 20000, 25000, 30000, 35000, 40000, 45000, 50000, 60000,
+  70000, 80000, 90000, 100000, 120000, 140000, 160000, 180000, 200000,
+  250000, 300000, 350000, 400000, 450000, 500000, 600000, 700000, 800000,
+  900000, 1000000, 1200000, 1400000, 1600000, 1800000, 2000000, 2500000,
+  3000000, 3500000, 4000000, 4500000, 5000000, 6000000, 7000000, 8000000,
+  9000000, 10000000, 12000000, 14000000, 16000000, 18000000, 20000000,
+  25000000, 30000000, 35000000, 40000000, 45000000, 50000000, 60000000,
+  70000000, 80000000, 90000000, 100000000, 120000000, 140000000, 160000000,
+  180000000, 200000000, 250000000, 300000000, 350000000, 400000000,
+  450000000, 500000000, 600000000, 700000000, 800000000, 900000000,
+  1000000000, 1200000000, 1400000000, 1600000000, 1800000000, 2000000000,
+  2500000000.0, 3000000000.0, 3500000000.0, 4000000000.0, 4500000000.0,
+  5000000000.0, 6000000000.0, 7000000000.0, 8000000000.0, 9000000000.0,
+  1e200,
+};
+
+void Histogram::Clear() {
+  min_ = kBucketLimit[kNumBuckets-1];
+  max_ = 0;
+  num_ = 0;
+  sum_ = 0;
+  sum_squares_ = 0;
+  for (int i = 0; i < kNumBuckets; i++) {
+    buckets_[i] = 0;
+  }
+}
+
+void Histogram::Add(double value) {
+  // Linear search is fast enough for our usage in db_bench
+  int b = 0;
+  while (b < kNumBuckets - 1 && kBucketLimit[b] <= value) {
+    b++;
+  }
+  buckets_[b] += 1.0;
+  if (min_ > value) min_ = value;
+  if (max_ < value) max_ = value;
+  num_++;
+  sum_ += value;
+  sum_squares_ += (value * value);
+}
+
+void Histogram::Merge(const Histogram& other) {
+  if (other.min_ < min_) min_ = other.min_;
+  if (other.max_ > max_) max_ = other.max_;
+  num_ += other.num_;
+  sum_ += other.sum_;
+  sum_squares_ += other.sum_squares_;
+  for (int b = 0; b < kNumBuckets; b++) {
+    buckets_[b] += other.buckets_[b];
+  }
+}
+
+double Histogram::Median() const {
+  return Percentile(50.0);
+}
+
+double Histogram::Percentile(double p) const {
+  double threshold = num_ * (p / 100.0);
+  double sum = 0;
+  for (int b = 0; b < kNumBuckets; b++) {
+    sum += buckets_[b];
+    if (sum >= threshold) {
+      // Scale linearly within this bucket
+      double left_point = (b == 0) ? 0 : kBucketLimit[b-1];
+      double right_point = kBucketLimit[b];
+      double left_sum = sum - buckets_[b];
+      double right_sum = sum;
+      double pos = (threshold - left_sum) / (right_sum - left_sum);
+      double r = left_point + (right_point - left_point) * pos;
+      if (r < min_) r = min_;
+      if (r > max_) r = max_;
+      return r;
+    }
+  }
+  return max_;
+}
+
+double Histogram::Average() const {
+  if (num_ == 0.0) return 0;
+  return sum_ / num_;
+}
+
+double Histogram::StandardDeviation() const {
+  if (num_ == 0.0) return 0;
+  double variance = (sum_squares_ * num_ - sum_ * sum_) / (num_ * num_);
+  return sqrt(variance);
+}
+
+std::string Histogram::ToString() const {
+  std::string r;
+  char buf[200];
+  snprintf(buf, sizeof(buf),
+           "Count: %.0f  Average: %.4f  StdDev: %.2f\n",
+           num_, Average(), StandardDeviation());
+  r.append(buf);
+  snprintf(buf, sizeof(buf),
+           "Min: %.4f  Median: %.4f  Max: %.4f\n",
+           (num_ == 0.0 ? 0.0 : min_), Median(), max_);
+  r.append(buf);
+  r.append("------------------------------------------------------\n");
+  const double mult = 100.0 / num_;
+  double sum = 0;
+  for (int b = 0; b < kNumBuckets; b++) {
+    if (buckets_[b] <= 0.0) continue;
+    sum += buckets_[b];
+    snprintf(buf, sizeof(buf),
+             "[ %7.0f, %7.0f ) %7.0f %7.3f%% %7.3f%% ",
+             ((b == 0) ? 0.0 : kBucketLimit[b-1]),      // left
+             kBucketLimit[b],                           // right
+             buckets_[b],                               // count
+             mult * buckets_[b],                        // percentage
+             mult * sum);                               // cumulative percentage
+    r.append(buf);
+
+    // Add hash marks based on percentage; 20 marks for 100%.
+    int marks = static_cast<int>(20*(buckets_[b] / num_) + 0.5);
+    r.append(marks, '#');
+    r.push_back('\n');
+  }
+  return r;
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/histogram.h b/packages/LevelDB.1.16.0.5/lib/native/src/util/histogram.h
new file mode 100644
index 0000000..1ef9f3c
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/histogram.h
@@ -0,0 +1,42 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_UTIL_HISTOGRAM_H_
+#define STORAGE_LEVELDB_UTIL_HISTOGRAM_H_
+
+#include <string>
+
+namespace leveldb {
+
+class Histogram {
+ public:
+  Histogram() { }
+  ~Histogram() { }
+
+  void Clear();
+  void Add(double value);
+  void Merge(const Histogram& other);
+
+  std::string ToString() const;
+
+ private:
+  double min_;
+  double max_;
+  double num_;
+  double sum_;
+  double sum_squares_;
+
+  enum { kNumBuckets = 154 };
+  static const double kBucketLimit[kNumBuckets];
+  double buckets_[kNumBuckets];
+
+  double Median() const;
+  double Percentile(double p) const;
+  double Average() const;
+  double StandardDeviation() const;
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_UTIL_HISTOGRAM_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/logging.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/logging.cc
new file mode 100644
index 0000000..22cf278
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/logging.cc
@@ -0,0 +1,81 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "util/logging.h"
+
+#include <errno.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "leveldb/env.h"
+#include "leveldb/slice.h"
+
+namespace leveldb {
+
+void AppendNumberTo(std::string* str, uint64_t num) {
+  char buf[30];
+  snprintf(buf, sizeof(buf), "%llu", (unsigned long long) num);
+  str->append(buf);
+}
+
+void AppendEscapedStringTo(std::string* str, const Slice& value) {
+  for (size_t i = 0; i < value.size(); i++) {
+    char c = value[i];
+    if (c >= ' ' && c <= '~') {
+      str->push_back(c);
+    } else {
+      char buf[10];
+      snprintf(buf, sizeof(buf), "\\x%02x",
+               static_cast<unsigned int>(c) & 0xff);
+      str->append(buf);
+    }
+  }
+}
+
+std::string NumberToString(uint64_t num) {
+  std::string r;
+  AppendNumberTo(&r, num);
+  return r;
+}
+
+std::string EscapeString(const Slice& value) {
+  std::string r;
+  AppendEscapedStringTo(&r, value);
+  return r;
+}
+
+bool ConsumeChar(Slice* in, char c) {
+  if (!in->empty() && (*in)[0] == c) {
+    in->remove_prefix(1);
+    return true;
+  } else {
+    return false;
+  }
+}
+
+bool ConsumeDecimalNumber(Slice* in, uint64_t* val) {
+  uint64_t v = 0;
+  int digits = 0;
+  while (!in->empty()) {
+    char c = (*in)[0];
+    if (c >= '0' && c <= '9') {
+      ++digits;
+      const int delta = (c - '0');
+      static const uint64_t kMaxUint64 = ~static_cast<uint64_t>(0);
+      if (v > kMaxUint64/10 ||
+          (v == kMaxUint64/10 && delta > kMaxUint64%10)) {
+        // Overflow
+        return false;
+      }
+      v = (v * 10) + delta;
+      in->remove_prefix(1);
+    } else {
+      break;
+    }
+  }
+  *val = v;
+  return (digits > 0);
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/logging.h b/packages/LevelDB.1.16.0.5/lib/native/src/util/logging.h
new file mode 100644
index 0000000..b0c5da8
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/logging.h
@@ -0,0 +1,47 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// Must not be included from any .h files to avoid polluting the namespace
+// with macros.
+
+#ifndef STORAGE_LEVELDB_UTIL_LOGGING_H_
+#define STORAGE_LEVELDB_UTIL_LOGGING_H_
+
+#include <stdio.h>
+#include <stdint.h>
+#include <string>
+#include "port/port.h"
+
+namespace leveldb {
+
+class Slice;
+class WritableFile;
+
+// Append a human-readable printout of "num" to *str
+extern void AppendNumberTo(std::string* str, uint64_t num);
+
+// Append a human-readable printout of "value" to *str.
+// Escapes any non-printable characters found in "value".
+extern void AppendEscapedStringTo(std::string* str, const Slice& value);
+
+// Return a human-readable printout of "num"
+extern std::string NumberToString(uint64_t num);
+
+// Return a human-readable version of "value".
+// Escapes any non-printable characters found in "value".
+extern std::string EscapeString(const Slice& value);
+
+// If *in starts with "c", advances *in past the first character and
+// returns true.  Otherwise, returns false.
+extern bool ConsumeChar(Slice* in, char c);
+
+// Parse a human-readable number from "*in" into *value.  On success,
+// advances "*in" past the consumed number and sets "*val" to the
+// numeric value.  Otherwise, returns false and leaves *in in an
+// unspecified state.
+extern bool ConsumeDecimalNumber(Slice* in, uint64_t* val);
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_UTIL_LOGGING_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/mutexlock.h b/packages/LevelDB.1.16.0.5/lib/native/src/util/mutexlock.h
new file mode 100644
index 0000000..1ff5a9e
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/mutexlock.h
@@ -0,0 +1,41 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_UTIL_MUTEXLOCK_H_
+#define STORAGE_LEVELDB_UTIL_MUTEXLOCK_H_
+
+#include "port/port.h"
+#include "port/thread_annotations.h"
+
+namespace leveldb {
+
+// Helper class that locks a mutex on construction and unlocks the mutex when
+// the destructor of the MutexLock object is invoked.
+//
+// Typical usage:
+//
+//   void MyClass::MyMethod() {
+//     MutexLock l(&mu_);       // mu_ is an instance variable
+//     ... some complex code, possibly with multiple return paths ...
+//   }
+
+class SCOPED_LOCKABLE MutexLock {
+ public:
+  explicit MutexLock(port::Mutex *mu) EXCLUSIVE_LOCK_FUNCTION(mu)
+      : mu_(mu)  {
+    this->mu_->Lock();
+  }
+  ~MutexLock() UNLOCK_FUNCTION() { this->mu_->Unlock(); }
+
+ private:
+  port::Mutex *const mu_;
+  // No copying allowed
+  MutexLock(const MutexLock&);
+  void operator=(const MutexLock&);
+};
+
+}  // namespace leveldb
+
+
+#endif  // STORAGE_LEVELDB_UTIL_MUTEXLOCK_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/options.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/options.cc
new file mode 100644
index 0000000..76af5b9
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/options.cc
@@ -0,0 +1,29 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "leveldb/options.h"
+
+#include "leveldb/comparator.h"
+#include "leveldb/env.h"
+
+namespace leveldb {
+
+Options::Options()
+    : comparator(BytewiseComparator()),
+      create_if_missing(false),
+      error_if_exists(false),
+      paranoid_checks(false),
+      env(Env::Default()),
+      info_log(NULL),
+      write_buffer_size(4<<20),
+      max_open_files(1000),
+      block_cache(NULL),
+      block_size(4096),
+      block_restart_interval(16),
+      compression(kSnappyCompression),
+      filter_policy(NULL) {
+}
+
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/posix_logger.h b/packages/LevelDB.1.16.0.5/lib/native/src/util/posix_logger.h
new file mode 100644
index 0000000..9741b1a
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/posix_logger.h
@@ -0,0 +1,98 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+//
+// Logger implementation that can be shared by all environments
+// where enough posix functionality is available.
+
+#ifndef STORAGE_LEVELDB_UTIL_POSIX_LOGGER_H_
+#define STORAGE_LEVELDB_UTIL_POSIX_LOGGER_H_
+
+#include <algorithm>
+#include <stdio.h>
+#include <sys/time.h>
+#include <time.h>
+#include "leveldb/env.h"
+
+namespace leveldb {
+
+class PosixLogger : public Logger {
+ private:
+  FILE* file_;
+  uint64_t (*gettid_)();  // Return the thread id for the current thread
+ public:
+  PosixLogger(FILE* f, uint64_t (*gettid)()) : file_(f), gettid_(gettid) { }
+  virtual ~PosixLogger() {
+    fclose(file_);
+  }
+  virtual void Logv(const char* format, va_list ap) {
+    const uint64_t thread_id = (*gettid_)();
+
+    // We try twice: the first time with a fixed-size stack allocated buffer,
+    // and the second time with a much larger dynamically allocated buffer.
+    char buffer[500];
+    for (int iter = 0; iter < 2; iter++) {
+      char* base;
+      int bufsize;
+      if (iter == 0) {
+        bufsize = sizeof(buffer);
+        base = buffer;
+      } else {
+        bufsize = 30000;
+        base = new char[bufsize];
+      }
+      char* p = base;
+      char* limit = base + bufsize;
+
+      struct timeval now_tv;
+      gettimeofday(&now_tv, NULL);
+      const time_t seconds = now_tv.tv_sec;
+      struct tm t;
+      localtime_r(&seconds, &t);
+      p += snprintf(p, limit - p,
+                    "%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx ",
+                    t.tm_year + 1900,
+                    t.tm_mon + 1,
+                    t.tm_mday,
+                    t.tm_hour,
+                    t.tm_min,
+                    t.tm_sec,
+                    static_cast<int>(now_tv.tv_usec),
+                    static_cast<long long unsigned int>(thread_id));
+
+      // Print the message
+      if (p < limit) {
+        va_list backup_ap;
+        va_copy(backup_ap, ap);
+        p += vsnprintf(p, limit - p, format, backup_ap);
+        va_end(backup_ap);
+      }
+
+      // Truncate to available space if necessary
+      if (p >= limit) {
+        if (iter == 0) {
+          continue;       // Try again with larger buffer
+        } else {
+          p = limit - 1;
+        }
+      }
+
+      // Add newline if necessary
+      if (p == base || p[-1] != '\n') {
+        *p++ = '\n';
+      }
+
+      assert(p <= limit);
+      fwrite(base, 1, p - base, file_);
+      fflush(file_);
+      if (base != buffer) {
+        delete[] base;
+      }
+      break;
+    }
+  }
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_UTIL_POSIX_LOGGER_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/random.h b/packages/LevelDB.1.16.0.5/lib/native/src/util/random.h
new file mode 100644
index 0000000..ddd51b1
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/random.h
@@ -0,0 +1,64 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_UTIL_RANDOM_H_
+#define STORAGE_LEVELDB_UTIL_RANDOM_H_
+
+#include <stdint.h>
+
+namespace leveldb {
+
+// A very simple random number generator.  Not especially good at
+// generating truly random bits, but good enough for our needs in this
+// package.
+class Random {
+ private:
+  uint32_t seed_;
+ public:
+  explicit Random(uint32_t s) : seed_(s & 0x7fffffffu) {
+    // Avoid bad seeds.
+    if (seed_ == 0 || seed_ == 2147483647L) {
+      seed_ = 1;
+    }
+  }
+  uint32_t Next() {
+    static const uint32_t M = 2147483647L;   // 2^31-1
+    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0
+    // We are computing
+    //       seed_ = (seed_ * A) % M,    where M = 2^31-1
+    //
+    // seed_ must not be zero or M, or else all subsequent computed values
+    // will be zero or M respectively.  For all other values, seed_ will end
+    // up cycling through every number in [1,M-1]
+    uint64_t product = seed_ * A;
+
+    // Compute (product % M) using the fact that ((x << 31) % M) == x.
+    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));
+    // The first reduction may overflow by 1 bit, so we may need to
+    // repeat.  mod == M is not possible; using > allows the faster
+    // sign-bit-based test.
+    if (seed_ > M) {
+      seed_ -= M;
+    }
+    return seed_;
+  }
+  // Returns a uniformly distributed value in the range [0..n-1]
+  // REQUIRES: n > 0
+  uint32_t Uniform(int n) { return Next() % n; }
+
+  // Randomly returns true ~"1/n" of the time, and false otherwise.
+  // REQUIRES: n > 0
+  bool OneIn(int n) { return (Next() % n) == 0; }
+
+  // Skewed: pick "base" uniformly from range [0,max_log] and then
+  // return "base" random bits.  The effect is to pick a number in the
+  // range [0,2^max_log-1] with exponential bias towards smaller numbers.
+  uint32_t Skewed(int max_log) {
+    return Uniform(1 << Uniform(max_log + 1));
+  }
+};
+
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_UTIL_RANDOM_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/status.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/status.cc
new file mode 100644
index 0000000..a44f35b
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/status.cc
@@ -0,0 +1,75 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include <stdio.h>
+#include "port/port.h"
+#include "leveldb/status.h"
+
+namespace leveldb {
+
+const char* Status::CopyState(const char* state) {
+  uint32_t size;
+  memcpy(&size, state, sizeof(size));
+  char* result = new char[size + 5];
+  memcpy(result, state, size + 5);
+  return result;
+}
+
+Status::Status(Code code, const Slice& msg, const Slice& msg2) {
+  assert(code != kOk);
+  const uint32_t len1 = msg.size();
+  const uint32_t len2 = msg2.size();
+  const uint32_t size = len1 + (len2 ? (2 + len2) : 0);
+  char* result = new char[size + 5];
+  memcpy(result, &size, sizeof(size));
+  result[4] = static_cast<char>(code);
+  memcpy(result + 5, msg.data(), len1);
+  if (len2) {
+    result[5 + len1] = ':';
+    result[6 + len1] = ' ';
+    memcpy(result + 7 + len1, msg2.data(), len2);
+  }
+  state_ = result;
+}
+
+std::string Status::ToString() const {
+  if (state_ == NULL) {
+    return "OK";
+  } else {
+    char tmp[30];
+    const char* type;
+    switch (code()) {
+      case kOk:
+        type = "OK";
+        break;
+      case kNotFound:
+        type = "NotFound: ";
+        break;
+      case kCorruption:
+        type = "Corruption: ";
+        break;
+      case kNotSupported:
+        type = "Not implemented: ";
+        break;
+      case kInvalidArgument:
+        type = "Invalid argument: ";
+        break;
+      case kIOError:
+        type = "IO error: ";
+        break;
+      default:
+        snprintf(tmp, sizeof(tmp), "Unknown code(%d): ",
+                 static_cast<int>(code()));
+        type = tmp;
+        break;
+    }
+    std::string result(type);
+    uint32_t length;
+    memcpy(&length, state_, sizeof(length));
+    result.append(state_ + 5, length);
+    return result;
+  }
+}
+
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/testharness.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/testharness.cc
new file mode 100644
index 0000000..402fab3
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/testharness.cc
@@ -0,0 +1,77 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "util/testharness.h"
+
+#include <string>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+namespace leveldb {
+namespace test {
+
+namespace {
+struct Test {
+  const char* base;
+  const char* name;
+  void (*func)();
+};
+std::vector<Test>* tests;
+}
+
+bool RegisterTest(const char* base, const char* name, void (*func)()) {
+  if (tests == NULL) {
+    tests = new std::vector<Test>;
+  }
+  Test t;
+  t.base = base;
+  t.name = name;
+  t.func = func;
+  tests->push_back(t);
+  return true;
+}
+
+int RunAllTests() {
+  const char* matcher = getenv("LEVELDB_TESTS");
+
+  int num = 0;
+  if (tests != NULL) {
+    for (size_t i = 0; i < tests->size(); i++) {
+      const Test& t = (*tests)[i];
+      if (matcher != NULL) {
+        std::string name = t.base;
+        name.push_back('.');
+        name.append(t.name);
+        if (strstr(name.c_str(), matcher) == NULL) {
+          continue;
+        }
+      }
+      fprintf(stderr, "==== Test %s.%s\n", t.base, t.name);
+      (*t.func)();
+      ++num;
+    }
+  }
+  fprintf(stderr, "==== PASSED %d tests\n", num);
+  return 0;
+}
+
+std::string TmpDir() {
+  std::string dir;
+  Status s = Env::Default()->GetTestDirectory(&dir);
+  ASSERT_TRUE(s.ok()) << s.ToString();
+  return dir;
+}
+
+int RandomSeed() {
+  const char* env = getenv("TEST_RANDOM_SEED");
+  int result = (env != NULL ? atoi(env) : 301);
+  if (result <= 0) {
+    result = 301;
+  }
+  return result;
+}
+
+}  // namespace test
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/testharness.h b/packages/LevelDB.1.16.0.5/lib/native/src/util/testharness.h
new file mode 100644
index 0000000..6dc3da6
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/testharness.h
@@ -0,0 +1,140 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_UTIL_TESTHARNESS_H_
+#define STORAGE_LEVELDB_UTIL_TESTHARNESS_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sstream>
+#include "leveldb/env.h"
+#include "leveldb/slice.h"
+#include "util/random.h"
+
+namespace leveldb {
+namespace test {
+
+// Run some of the tests registered by the TEST() macro.  If the
+// environment variable "LEVELDB_TESTS" is not set, runs all tests.
+// Otherwise, runs only the tests whose name contains the value of
+// "LEVELDB_TESTS" as a substring.  E.g., suppose the tests are:
+//    TEST(Foo, Hello) { ... }
+//    TEST(Foo, World) { ... }
+// LEVELDB_TESTS=Hello will run the first test
+// LEVELDB_TESTS=o     will run both tests
+// LEVELDB_TESTS=Junk  will run no tests
+//
+// Returns 0 if all tests pass.
+// Dies or returns a non-zero value if some test fails.
+extern int RunAllTests();
+
+// Return the directory to use for temporary storage.
+extern std::string TmpDir();
+
+// Return a randomization seed for this run.  Typically returns the
+// same number on repeated invocations of this binary, but automated
+// runs may be able to vary the seed.
+extern int RandomSeed();
+
+// An instance of Tester is allocated to hold temporary state during
+// the execution of an assertion.
+class Tester {
+ private:
+  bool ok_;
+  const char* fname_;
+  int line_;
+  std::stringstream ss_;
+
+ public:
+  Tester(const char* f, int l)
+      : ok_(true), fname_(f), line_(l) {
+  }
+
+  ~Tester() {
+    if (!ok_) {
+      fprintf(stderr, "%s:%d:%s\n", fname_, line_, ss_.str().c_str());
+      exit(1);
+    }
+  }
+
+  Tester& Is(bool b, const char* msg) {
+    if (!b) {
+      ss_ << " Assertion failure " << msg;
+      ok_ = false;
+    }
+    return *this;
+  }
+
+  Tester& IsOk(const Status& s) {
+    if (!s.ok()) {
+      ss_ << " " << s.ToString();
+      ok_ = false;
+    }
+    return *this;
+  }
+
+#define BINARY_OP(name,op)                              \
+  template <class X, class Y>                           \
+  Tester& name(const X& x, const Y& y) {                \
+    if (! (x op y)) {                                   \
+      ss_ << " failed: " << x << (" " #op " ") << y;    \
+      ok_ = false;                                      \
+    }                                                   \
+    return *this;                                       \
+  }
+
+  BINARY_OP(IsEq, ==)
+  BINARY_OP(IsNe, !=)
+  BINARY_OP(IsGe, >=)
+  BINARY_OP(IsGt, >)
+  BINARY_OP(IsLe, <=)
+  BINARY_OP(IsLt, <)
+#undef BINARY_OP
+
+  // Attach the specified value to the error message if an error has occurred
+  template <class V>
+  Tester& operator<<(const V& value) {
+    if (!ok_) {
+      ss_ << " " << value;
+    }
+    return *this;
+  }
+};
+
+#define ASSERT_TRUE(c) ::leveldb::test::Tester(__FILE__, __LINE__).Is((c), #c)
+#define ASSERT_OK(s) ::leveldb::test::Tester(__FILE__, __LINE__).IsOk((s))
+#define ASSERT_EQ(a,b) ::leveldb::test::Tester(__FILE__, __LINE__).IsEq((a),(b))
+#define ASSERT_NE(a,b) ::leveldb::test::Tester(__FILE__, __LINE__).IsNe((a),(b))
+#define ASSERT_GE(a,b) ::leveldb::test::Tester(__FILE__, __LINE__).IsGe((a),(b))
+#define ASSERT_GT(a,b) ::leveldb::test::Tester(__FILE__, __LINE__).IsGt((a),(b))
+#define ASSERT_LE(a,b) ::leveldb::test::Tester(__FILE__, __LINE__).IsLe((a),(b))
+#define ASSERT_LT(a,b) ::leveldb::test::Tester(__FILE__, __LINE__).IsLt((a),(b))
+
+#define TCONCAT(a,b) TCONCAT1(a,b)
+#define TCONCAT1(a,b) a##b
+#define TCONCAT3(a,b,c) a##b##c
+#define TCONCAT4(a,b,c,d) a##b##c##d
+
+#define TEST(base,name)                                                 \
+class TCONCAT4(_Test_,base,_,name) : public base {                      \
+ public:                                                                \
+  void _Run();                                                          \
+  static void _RunIt() {                                                \
+    TCONCAT4(_Test_,base,_,name) t;                                     \
+    t._Run();                                                           \
+  }                                                                     \
+};                                                                      \
+bool TCONCAT4(_Test_ignored_,base,_,name) =                             \
+  ::leveldb::test::RegisterTest(#base, #name, &TCONCAT4(_Test_,base,_,name)::_RunIt); \
+void TCONCAT4(_Test_,base,_,name)::_Run()
+
+// Register the specified test.  Typically not used directly, but
+// invoked via the macro expansion of TEST.
+extern bool RegisterTest(const char* base, const char* name, void (*func)());
+
+
+}  // namespace test
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_UTIL_TESTHARNESS_H_
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/testutil.cc b/packages/LevelDB.1.16.0.5/lib/native/src/util/testutil.cc
new file mode 100644
index 0000000..bee56bf
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/testutil.cc
@@ -0,0 +1,51 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#include "util/testutil.h"
+
+#include "util/random.h"
+
+namespace leveldb {
+namespace test {
+
+Slice RandomString(Random* rnd, int len, std::string* dst) {
+  dst->resize(len);
+  for (int i = 0; i < len; i++) {
+    (*dst)[i] = static_cast<char>(' ' + rnd->Uniform(95));   // ' ' .. '~'
+  }
+  return Slice(*dst);
+}
+
+std::string RandomKey(Random* rnd, int len) {
+  // Make sure to generate a wide variety of characters so we
+  // test the boundary conditions for short-key optimizations.
+  static const char kTestChars[] = {
+    '\0', '\1', 'a', 'b', 'c', 'd', 'e', '\xfd', '\xfe', '\xff'
+  };
+  std::string result;
+  for (int i = 0; i < len; i++) {
+    result += kTestChars[rnd->Uniform(sizeof(kTestChars))];
+  }
+  return result;
+}
+
+
+extern Slice CompressibleString(Random* rnd, double compressed_fraction,
+                                size_t len, std::string* dst) {
+  int raw = static_cast<int>(len * compressed_fraction);
+  if (raw < 1) raw = 1;
+  std::string raw_data;
+  RandomString(rnd, raw, &raw_data);
+
+  // Duplicate the random data until we have filled "len" bytes
+  dst->clear();
+  while (dst->size() < len) {
+    dst->append(raw_data);
+  }
+  dst->resize(len);
+  return Slice(*dst);
+}
+
+}  // namespace test
+}  // namespace leveldb
diff --git a/packages/LevelDB.1.16.0.5/lib/native/src/util/testutil.h b/packages/LevelDB.1.16.0.5/lib/native/src/util/testutil.h
new file mode 100644
index 0000000..adad3fc
--- /dev/null
+++ b/packages/LevelDB.1.16.0.5/lib/native/src/util/testutil.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file. See the AUTHORS file for names of contributors.
+
+#ifndef STORAGE_LEVELDB_UTIL_TESTUTIL_H_
+#define STORAGE_LEVELDB_UTIL_TESTUTIL_H_
+
+#include "leveldb/env.h"
+#include "leveldb/slice.h"
+#include "util/random.h"
+
+namespace leveldb {
+namespace test {
+
+// Store in *dst a random string of length "len" and return a Slice that
+// references the generated data.
+extern Slice RandomString(Random* rnd, int len, std::string* dst);
+
+// Return a random key with the specified length that may contain interesting
+// characters (e.g. \x00, \xff, etc.).
+extern std::string RandomKey(Random* rnd, int len);
+
+// Store in *dst a string of length "len" that will compress to
+// "N*compressed_fraction" bytes and return a Slice that references
+// the generated data.
+extern Slice CompressibleString(Random* rnd, double compressed_fraction,
+                                size_t len, std::string* dst);
+
+// A wrapper that allows injection of errors.
+class ErrorEnv : public EnvWrapper {
+ public:
+  bool writable_file_error_;
+  int num_writable_file_errors_;
+
+  ErrorEnv() : EnvWrapper(Env::Default()),
+               writable_file_error_(false),
+               num_writable_file_errors_(0) { }
+
+  virtual Status NewWritableFile(const std::string& fname,
+                                 WritableFile** result) {
+    if (writable_file_error_) {
+      ++num_writable_file_errors_;
+      *result = NULL;
+      return Status::IOError(fname, "fake error");
+    }
+    return target()->NewWritableFile(fname, result);
+  }
+};
+
+}  // namespace test
+}  // namespace leveldb
+
+#endif  // STORAGE_LEVELDB_UTIL_TESTUTIL_H_
diff --git a/packages/Snappy.1.1.1.7/Snappy.1.1.1.7.nupkg b/packages/Snappy.1.1.1.7/Snappy.1.1.1.7.nupkg
new file mode 100644
index 0000000000000000000000000000000000000000..daad7f4bb8d0ccbe5d57ea51f660aa20f3a069b3
GIT binary patch
literal 61562
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
N9m4<sVn1G<{U79<MHK)5

literal 0
HcmV?d00001

diff --git a/packages/Snappy.1.1.1.7/Snappy.1.1.1.7.nuspec b/packages/Snappy.1.1.1.7/Snappy.1.1.1.7.nuspec
new file mode 100644
index 0000000..8568aba
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/Snappy.1.1.1.7.nuspec
@@ -0,0 +1,18 @@
+<?xml version="1.0"?>
+<package xmlns="http://schemas.microsoft.com/packaging/2011/08/nuspec.xsd">
+  <metadata>
+    <id>Snappy</id>
+    <version>1.1.1.7</version>
+    <title>Snappy for C++</title>
+    <authors>Robert Važan</authors>
+    <owners>Robert Važan</owners>
+    <licenseUrl>http://snappy.angeloflogic.com/license/</licenseUrl>
+    <projectUrl>http://snappy.angeloflogic.com/</projectUrl>
+    <iconUrl>http://snappy.angeloflogic.com/images/nuget-icon.png</iconUrl>
+    <requireLicenseAcceptance>false</requireLicenseAcceptance>
+    <description>Snappy is a compression algorithm reaching over 250MB/s compression and 500MB/s decompression speeds while still providing interesting compression ratio. This is a source code package that compiles Snappy into your project.</description>
+    <releaseNotes>Fixed a warning.</releaseNotes>
+    <copyright>Copyright (c) 2005-2014 Google Inc., Robert Važan</copyright>
+    <tags>snappy compression codec fast native</tags>
+  </metadata>
+</package>
\ No newline at end of file
diff --git a/packages/Snappy.1.1.1.7/build/native/Snappy.props b/packages/Snappy.1.1.1.7/build/native/Snappy.props
new file mode 100644
index 0000000..b0b87ed
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/build/native/Snappy.props
@@ -0,0 +1,14 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <PreprocessorDefinitions>SNAPPY_STATIC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(MSBuildThisFileDirectory)..\..\lib\native\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\lib\native\src\snappy-single-file.cpp">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/packages/Snappy.1.1.1.7/lib/native/include/snappy-c.h b/packages/Snappy.1.1.1.7/lib/native/include/snappy-c.h
new file mode 100644
index 0000000..25bd9cc
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/include/snappy-c.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2011 Martin Gieseking <martin.gieseking@uos.de>.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *     * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer
+ * in the documentation and/or other materials provided with the
+ * distribution.
+ *     * Neither the name of Google Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Plain C interface (a wrapper around the C++ implementation).
+ */
+
+#ifndef UTIL_SNAPPY_OPENSOURCE_SNAPPY_C_H_
+#define UTIL_SNAPPY_OPENSOURCE_SNAPPY_C_H_
+
+#ifndef SNAPPY_STATIC
+#ifdef SNAPPY_EXPORTS
+#define SNAPPY_API __declspec(dllexport)
+#else
+#define SNAPPY_API __declspec(dllimport)
+#endif
+#else
+#define SNAPPY_API
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stddef.h>
+
+/*
+ * Return values; see the documentation for each function to know
+ * what each can return.
+ */
+typedef enum {
+  SNAPPY_OK = 0,
+  SNAPPY_INVALID_INPUT = 1,
+  SNAPPY_BUFFER_TOO_SMALL = 2
+} snappy_status;
+
+/*
+ * Takes the data stored in "input[0..input_length-1]" and stores
+ * it in the array pointed to by "compressed".
+ *
+ * <compressed_length> signals the space available in "compressed".
+ * If it is not at least equal to "snappy_max_compressed_length(input_length)",
+ * SNAPPY_BUFFER_TOO_SMALL is returned. After successful compression,
+ * <compressed_length> contains the true length of the compressed output,
+ * and SNAPPY_OK is returned.
+ *
+ * Example:
+ *   size_t output_length = snappy_max_compressed_length(input_length);
+ *   char* output = (char*)malloc(output_length);
+ *   if (snappy_compress(input, input_length, output, &output_length)
+ *       == SNAPPY_OK) {
+ *     ... Process(output, output_length) ...
+ *   }
+ *   free(output);
+ */
+SNAPPY_API snappy_status snappy_compress(
+	const char* input,
+	size_t input_length,
+	char* compressed,
+	size_t* compressed_length);
+
+/*
+ * Given data in "compressed[0..compressed_length-1]" generated by
+ * calling the snappy_compress routine, this routine stores
+ * the uncompressed data to
+ *   uncompressed[0..uncompressed_length-1].
+ * Returns failure (a value not equal to SNAPPY_OK) if the message
+ * is corrupted and could not be decrypted.
+ *
+ * <uncompressed_length> signals the space available in "uncompressed".
+ * If it is not at least equal to the value returned by
+ * snappy_uncompressed_length for this stream, SNAPPY_BUFFER_TOO_SMALL
+ * is returned. After successful decompression, <uncompressed_length>
+ * contains the true length of the decompressed output.
+ *
+ * Example:
+ *   size_t output_length;
+ *   if (snappy_uncompressed_length(input, input_length, &output_length)
+ *       != SNAPPY_OK) {
+ *     ... fail ...
+ *   }
+ *   char* output = (char*)malloc(output_length);
+ *   if (snappy_uncompress(input, input_length, output, &output_length)
+ *       == SNAPPY_OK) {
+ *     ... Process(output, output_length) ...
+ *   }
+ *   free(output);
+ */
+SNAPPY_API snappy_status snappy_uncompress(
+	const char* compressed,
+	size_t compressed_length,
+	char* uncompressed,
+	size_t* uncompressed_length);
+
+/*
+ * Returns the maximal size of the compressed representation of
+ * input data that is "source_length" bytes in length.
+ */
+SNAPPY_API size_t snappy_max_compressed_length(size_t source_length);
+
+/*
+ * REQUIRES: "compressed[]" was produced by snappy_compress()
+ * Returns SNAPPY_OK and stores the length of the uncompressed data in
+ * *result normally. Returns SNAPPY_INVALID_INPUT on parsing error.
+ * This operation takes O(1) time.
+ */
+SNAPPY_API snappy_status snappy_uncompressed_length(
+	const char* compressed,
+	size_t compressed_length,
+	size_t* result);
+
+/*
+ * Check if the contents of "compressed[]" can be uncompressed successfully.
+ * Does not return the uncompressed data; if so, returns SNAPPY_OK,
+ * or if not, returns SNAPPY_INVALID_INPUT.
+ * Takes time proportional to compressed_length, but is usually at least a
+ * factor of four faster than actual decompression.
+ */
+SNAPPY_API snappy_status snappy_validate_compressed_buffer(
+	const char* compressed,
+	size_t compressed_length);
+
+#ifdef __cplusplus
+}  // extern "C"
+#endif
+
+#endif  /* UTIL_SNAPPY_OPENSOURCE_SNAPPY_C_H_ */
diff --git a/packages/Snappy.1.1.1.7/lib/native/include/snappy-internal.h b/packages/Snappy.1.1.1.7/lib/native/include/snappy-internal.h
new file mode 100644
index 0000000..c99d331
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/include/snappy-internal.h
@@ -0,0 +1,150 @@
+// Copyright 2008 Google Inc. All Rights Reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Internals shared between the Snappy implementation and its unittest.
+
+#ifndef UTIL_SNAPPY_SNAPPY_INTERNAL_H_
+#define UTIL_SNAPPY_SNAPPY_INTERNAL_H_
+
+#include "snappy-stubs-internal.h"
+
+namespace snappy {
+namespace internal {
+
+class WorkingMemory {
+ public:
+  WorkingMemory() : large_table_(NULL) { }
+  ~WorkingMemory() { delete[] large_table_; }
+
+  // Allocates and clears a hash table using memory in "*this",
+  // stores the number of buckets in "*table_size" and returns a pointer to
+  // the base of the hash table.
+  uint16* GetHashTable(size_t input_size, int* table_size);
+
+ private:
+  uint16 small_table_[1<<10];    // 2KB
+  uint16* large_table_;          // Allocated only when needed
+
+  DISALLOW_COPY_AND_ASSIGN(WorkingMemory);
+};
+
+// Flat array compression that does not emit the "uncompressed length"
+// prefix. Compresses "input" string to the "*op" buffer.
+//
+// REQUIRES: "input_length <= kBlockSize"
+// REQUIRES: "op" points to an array of memory that is at least
+// "MaxCompressedLength(input_length)" in size.
+// REQUIRES: All elements in "table[0..table_size-1]" are initialized to zero.
+// REQUIRES: "table_size" is a power of two
+//
+// Returns an "end" pointer into "op" buffer.
+// "end - op" is the compressed size of "input".
+char* CompressFragment(const char* input,
+                       size_t input_length,
+                       char* op,
+                       uint16* table,
+                       const int table_size);
+
+// Return the largest n such that
+//
+//   s1[0,n-1] == s2[0,n-1]
+//   and n <= (s2_limit - s2).
+//
+// Does not read *s2_limit or beyond.
+// Does not read *(s1 + (s2_limit - s2)) or beyond.
+// Requires that s2_limit >= s2.
+//
+// Separate implementation for x86_64, for speed.  Uses the fact that
+// x86_64 is little endian.
+#if defined(ARCH_K8)
+static inline int FindMatchLength(const char* s1,
+                                  const char* s2,
+                                  const char* s2_limit) {
+  assert(s2_limit >= s2);
+  int matched = 0;
+
+  // Find out how long the match is. We loop over the data 64 bits at a
+  // time until we find a 64-bit block that doesn't match; then we find
+  // the first non-matching bit and use that to calculate the total
+  // length of the match.
+  while (PREDICT_TRUE(s2 <= s2_limit - 8)) {
+    if (PREDICT_FALSE(UNALIGNED_LOAD64(s2) == UNALIGNED_LOAD64(s1 + matched))) {
+      s2 += 8;
+      matched += 8;
+    } else {
+      // On current (mid-2008) Opteron models there is a 3% more
+      // efficient code sequence to find the first non-matching byte.
+      // However, what follows is ~10% better on Intel Core 2 and newer,
+      // and we expect AMD's bsf instruction to improve.
+      uint64 x = UNALIGNED_LOAD64(s2) ^ UNALIGNED_LOAD64(s1 + matched);
+      int matching_bits = Bits::FindLSBSetNonZero64(x);
+      matched += matching_bits >> 3;
+      return matched;
+    }
+  }
+  while (PREDICT_TRUE(s2 < s2_limit)) {
+    if (PREDICT_TRUE(s1[matched] == *s2)) {
+      ++s2;
+      ++matched;
+    } else {
+      return matched;
+    }
+  }
+  return matched;
+}
+#else
+static inline int FindMatchLength(const char* s1,
+                                  const char* s2,
+                                  const char* s2_limit) {
+  // Implementation based on the x86-64 version, above.
+  assert(s2_limit >= s2);
+  int matched = 0;
+
+  while (s2 <= s2_limit - 4 &&
+         UNALIGNED_LOAD32(s2) == UNALIGNED_LOAD32(s1 + matched)) {
+    s2 += 4;
+    matched += 4;
+  }
+  if (LittleEndian::IsLittleEndian() && s2 <= s2_limit - 4) {
+    uint32 x = UNALIGNED_LOAD32(s2) ^ UNALIGNED_LOAD32(s1 + matched);
+    int matching_bits = Bits::FindLSBSetNonZero(x);
+    matched += matching_bits >> 3;
+  } else {
+    while ((s2 < s2_limit) && (s1[matched] == *s2)) {
+      ++s2;
+      ++matched;
+    }
+  }
+  return matched;
+}
+#endif
+
+}  // end namespace internal
+}  // end namespace snappy
+
+#endif  // UTIL_SNAPPY_SNAPPY_INTERNAL_H_
diff --git a/packages/Snappy.1.1.1.7/lib/native/include/snappy-sinksource.h b/packages/Snappy.1.1.1.7/lib/native/include/snappy-sinksource.h
new file mode 100644
index 0000000..faabfa1
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/include/snappy-sinksource.h
@@ -0,0 +1,137 @@
+// Copyright 2011 Google Inc. All Rights Reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef UTIL_SNAPPY_SNAPPY_SINKSOURCE_H_
+#define UTIL_SNAPPY_SNAPPY_SINKSOURCE_H_
+
+#include <stddef.h>
+
+
+namespace snappy {
+
+// A Sink is an interface that consumes a sequence of bytes.
+class Sink {
+ public:
+  Sink() { }
+  virtual ~Sink();
+
+  // Append "bytes[0,n-1]" to this.
+  virtual void Append(const char* bytes, size_t n) = 0;
+
+  // Returns a writable buffer of the specified length for appending.
+  // May return a pointer to the caller-owned scratch buffer which
+  // must have at least the indicated length.  The returned buffer is
+  // only valid until the next operation on this Sink.
+  //
+  // After writing at most "length" bytes, call Append() with the
+  // pointer returned from this function and the number of bytes
+  // written.  Many Append() implementations will avoid copying
+  // bytes if this function returned an internal buffer.
+  //
+  // If a non-scratch buffer is returned, the caller may only pass a
+  // prefix of it to Append().  That is, it is not correct to pass an
+  // interior pointer of the returned array to Append().
+  //
+  // The default implementation always returns the scratch buffer.
+  virtual char* GetAppendBuffer(size_t length, char* scratch);
+
+
+ private:
+  // No copying
+  Sink(const Sink&);
+  void operator=(const Sink&);
+};
+
+// A Source is an interface that yields a sequence of bytes
+class Source {
+ public:
+  Source() { }
+  virtual ~Source();
+
+  // Return the number of bytes left to read from the source
+  virtual size_t Available() const = 0;
+
+  // Peek at the next flat region of the source.  Does not reposition
+  // the source.  The returned region is empty iff Available()==0.
+  //
+  // Returns a pointer to the beginning of the region and store its
+  // length in *len.
+  //
+  // The returned region is valid until the next call to Skip() or
+  // until this object is destroyed, whichever occurs first.
+  //
+  // The returned region may be larger than Available() (for example
+  // if this ByteSource is a view on a substring of a larger source).
+  // The caller is responsible for ensuring that it only reads the
+  // Available() bytes.
+  virtual const char* Peek(size_t* len) = 0;
+
+  // Skip the next n bytes.  Invalidates any buffer returned by
+  // a previous call to Peek().
+  // REQUIRES: Available() >= n
+  virtual void Skip(size_t n) = 0;
+
+ private:
+  // No copying
+  Source(const Source&);
+  void operator=(const Source&);
+};
+
+// A Source implementation that yields the contents of a flat array
+class ByteArraySource : public Source {
+ public:
+  ByteArraySource(const char* p, size_t n) : ptr_(p), left_(n) { }
+  virtual ~ByteArraySource();
+  virtual size_t Available() const;
+  virtual const char* Peek(size_t* len);
+  virtual void Skip(size_t n);
+ private:
+  const char* ptr_;
+  size_t left_;
+};
+
+// A Sink implementation that writes to a flat array without any bound checks.
+class UncheckedByteArraySink : public Sink {
+ public:
+  explicit UncheckedByteArraySink(char* dest) : dest_(dest) { }
+  virtual ~UncheckedByteArraySink();
+  virtual void Append(const char* data, size_t n);
+  virtual char* GetAppendBuffer(size_t len, char* scratch);
+
+  // Return the current output pointer so that a caller can see how
+  // many bytes were produced.
+  // Note: this is not a Sink method.
+  char* CurrentDestination() const { return dest_; }
+ private:
+  char* dest_;
+};
+
+
+}
+
+#endif  // UTIL_SNAPPY_SNAPPY_SINKSOURCE_H_
diff --git a/packages/Snappy.1.1.1.7/lib/native/include/snappy-stubs-internal.h b/packages/Snappy.1.1.1.7/lib/native/include/snappy-stubs-internal.h
new file mode 100644
index 0000000..bd062b4
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/include/snappy-stubs-internal.h
@@ -0,0 +1,521 @@
+// Copyright 2011 Google Inc. All Rights Reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Various stubs for the open-source version of Snappy.
+
+#ifndef UTIL_SNAPPY_OPENSOURCE_SNAPPY_STUBS_INTERNAL_H_
+#define UTIL_SNAPPY_OPENSOURCE_SNAPPY_STUBS_INTERNAL_H_
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string>
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef HAVE_SYS_MMAN_H
+#include <sys/mman.h>
+#endif
+
+#include "snappy-stubs-public.h"
+
+#if defined(__x86_64__)
+
+// Enable 64-bit optimized versions of some routines.
+#define ARCH_K8 1
+
+#endif
+
+// Needed by OS X, among others.
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
+// Pull in std::min, std::ostream, and the likes. This is safe because this
+// header file is never used from any public header files.
+using namespace std;
+
+// The size of an array, if known at compile-time.
+// Will give unexpected results if used on a pointer.
+// We undefine it first, since some compilers already have a definition.
+#ifdef ARRAYSIZE
+#undef ARRAYSIZE
+#endif
+#define ARRAYSIZE(a) (sizeof(a) / sizeof(*(a)))
+
+// Static prediction hints.
+#ifdef HAVE_BUILTIN_EXPECT
+#define PREDICT_FALSE(x) (__builtin_expect(x, 0))
+#define PREDICT_TRUE(x) (__builtin_expect(!!(x), 1))
+#else
+#define PREDICT_FALSE(x) x
+#define PREDICT_TRUE(x) x
+#endif
+
+// This is only used for recomputing the tag byte table used during
+// decompression; for simplicity we just remove it from the open-source
+// version (anyone who wants to regenerate it can just do the call
+// themselves within main()).
+#define DEFINE_bool(flag_name, default_value, description) \
+  bool FLAGS_ ## flag_name = default_value
+#define DECLARE_bool(flag_name) \
+  extern bool FLAGS_ ## flag_name
+
+namespace snappy {
+
+static const uint32 kuint32max = static_cast<uint32>(0xFFFFFFFF);
+static const int64 kint64max = static_cast<int64>(0x7FFFFFFFFFFFFFFFLL);
+
+// Potentially unaligned loads and stores.
+
+// x86 and PowerPC can simply do these loads and stores native.
+
+#if defined(__i386__) || defined(__x86_64__) || defined(__powerpc__)
+
+#define UNALIGNED_LOAD16(_p) (*reinterpret_cast<const uint16 *>(_p))
+#define UNALIGNED_LOAD32(_p) (*reinterpret_cast<const uint32 *>(_p))
+#define UNALIGNED_LOAD64(_p) (*reinterpret_cast<const uint64 *>(_p))
+
+#define UNALIGNED_STORE16(_p, _val) (*reinterpret_cast<uint16 *>(_p) = (_val))
+#define UNALIGNED_STORE32(_p, _val) (*reinterpret_cast<uint32 *>(_p) = (_val))
+#define UNALIGNED_STORE64(_p, _val) (*reinterpret_cast<uint64 *>(_p) = (_val))
+
+// ARMv7 and newer support native unaligned accesses, but only of 16-bit
+// and 32-bit values (not 64-bit); older versions either raise a fatal signal,
+// do an unaligned read and rotate the words around a bit, or do the reads very
+// slowly (trip through kernel mode). There's no simple #define that says just
+// “ARMv7 or higher”, so we have to filter away all ARMv5 and ARMv6
+// sub-architectures.
+//
+// This is a mess, but there's not much we can do about it.
+
+#elif defined(__arm__) && \
+      !defined(__ARM_ARCH_4__) && \
+      !defined(__ARM_ARCH_4T__) && \
+      !defined(__ARM_ARCH_5__) && \
+      !defined(__ARM_ARCH_5T__) && \
+      !defined(__ARM_ARCH_5TE__) && \
+      !defined(__ARM_ARCH_5TEJ__) && \
+      !defined(__ARM_ARCH_6__) && \
+      !defined(__ARM_ARCH_6J__) && \
+      !defined(__ARM_ARCH_6K__) && \
+      !defined(__ARM_ARCH_6Z__) && \
+      !defined(__ARM_ARCH_6ZK__) && \
+      !defined(__ARM_ARCH_6T2__)
+
+#define UNALIGNED_LOAD16(_p) (*reinterpret_cast<const uint16 *>(_p))
+#define UNALIGNED_LOAD32(_p) (*reinterpret_cast<const uint32 *>(_p))
+
+#define UNALIGNED_STORE16(_p, _val) (*reinterpret_cast<uint16 *>(_p) = (_val))
+#define UNALIGNED_STORE32(_p, _val) (*reinterpret_cast<uint32 *>(_p) = (_val))
+
+// TODO(user): NEON supports unaligned 64-bit loads and stores.
+// See if that would be more efficient on platforms supporting it,
+// at least for copies.
+
+inline uint64 UNALIGNED_LOAD64(const void *p) {
+  uint64 t;
+  memcpy(&t, p, sizeof t);
+  return t;
+}
+
+inline void UNALIGNED_STORE64(void *p, uint64 v) {
+  memcpy(p, &v, sizeof v);
+}
+
+#else
+
+// These functions are provided for architectures that don't support
+// unaligned loads and stores.
+
+inline uint16 UNALIGNED_LOAD16(const void *p) {
+  uint16 t;
+  memcpy(&t, p, sizeof t);
+  return t;
+}
+
+inline uint32 UNALIGNED_LOAD32(const void *p) {
+  uint32 t;
+  memcpy(&t, p, sizeof t);
+  return t;
+}
+
+inline uint64 UNALIGNED_LOAD64(const void *p) {
+  uint64 t;
+  memcpy(&t, p, sizeof t);
+  return t;
+}
+
+inline void UNALIGNED_STORE16(void *p, uint16 v) {
+  memcpy(p, &v, sizeof v);
+}
+
+inline void UNALIGNED_STORE32(void *p, uint32 v) {
+  memcpy(p, &v, sizeof v);
+}
+
+inline void UNALIGNED_STORE64(void *p, uint64 v) {
+  memcpy(p, &v, sizeof v);
+}
+
+#endif
+
+// This can be more efficient than UNALIGNED_LOAD64 + UNALIGNED_STORE64
+// on some platforms, in particular ARM.
+inline void UnalignedCopy64(const void *src, void *dst) {
+  if (sizeof(void *) == 8) {
+    UNALIGNED_STORE64(dst, UNALIGNED_LOAD64(src));
+  } else {
+    const char *src_char = reinterpret_cast<const char *>(src);
+    char *dst_char = reinterpret_cast<char *>(dst);
+
+    UNALIGNED_STORE32(dst_char, UNALIGNED_LOAD32(src_char));
+    UNALIGNED_STORE32(dst_char + 4, UNALIGNED_LOAD32(src_char + 4));
+  }
+}
+
+// The following guarantees declaration of the byte swap functions.
+#ifdef WORDS_BIGENDIAN
+
+#ifdef HAVE_SYS_BYTEORDER_H
+#include <sys/byteorder.h>
+#endif
+
+#ifdef HAVE_SYS_ENDIAN_H
+#include <sys/endian.h>
+#endif
+
+#ifdef _MSC_VER
+#include <stdlib.h>
+#define bswap_16(x) _byteswap_ushort(x)
+#define bswap_32(x) _byteswap_ulong(x)
+#define bswap_64(x) _byteswap_uint64(x)
+
+#elif defined(__APPLE__)
+// Mac OS X / Darwin features
+#include <libkern/OSByteOrder.h>
+#define bswap_16(x) OSSwapInt16(x)
+#define bswap_32(x) OSSwapInt32(x)
+#define bswap_64(x) OSSwapInt64(x)
+
+#elif defined(HAVE_BYTESWAP_H)
+#include <byteswap.h>
+
+#elif defined(bswap32)
+// FreeBSD defines bswap{16,32,64} in <sys/endian.h> (already #included).
+#define bswap_16(x) bswap16(x)
+#define bswap_32(x) bswap32(x)
+#define bswap_64(x) bswap64(x)
+
+#elif defined(BSWAP_64)
+// Solaris 10 defines BSWAP_{16,32,64} in <sys/byteorder.h> (already #included).
+#define bswap_16(x) BSWAP_16(x)
+#define bswap_32(x) BSWAP_32(x)
+#define bswap_64(x) BSWAP_64(x)
+
+#else
+
+inline uint16 bswap_16(uint16 x) {
+  return (x << 8) | (x >> 8);
+}
+
+inline uint32 bswap_32(uint32 x) {
+  x = ((x & 0xff00ff00UL) >> 8) | ((x & 0x00ff00ffUL) << 8);
+  return (x >> 16) | (x << 16);
+}
+
+inline uint64 bswap_64(uint64 x) {
+  x = ((x & 0xff00ff00ff00ff00ULL) >> 8) | ((x & 0x00ff00ff00ff00ffULL) << 8);
+  x = ((x & 0xffff0000ffff0000ULL) >> 16) | ((x & 0x0000ffff0000ffffULL) << 16);
+  return (x >> 32) | (x << 32);
+}
+
+#endif
+
+#endif  // WORDS_BIGENDIAN
+
+// Convert to little-endian storage, opposite of network format.
+// Convert x from host to little endian: x = LittleEndian.FromHost(x);
+// convert x from little endian to host: x = LittleEndian.ToHost(x);
+//
+//  Store values into unaligned memory converting to little endian order:
+//    LittleEndian.Store16(p, x);
+//
+//  Load unaligned values stored in little endian converting to host order:
+//    x = LittleEndian.Load16(p);
+class LittleEndian {
+ public:
+  // Conversion functions.
+#ifdef WORDS_BIGENDIAN
+
+  static uint16 FromHost16(uint16 x) { return bswap_16(x); }
+  static uint16 ToHost16(uint16 x) { return bswap_16(x); }
+
+  static uint32 FromHost32(uint32 x) { return bswap_32(x); }
+  static uint32 ToHost32(uint32 x) { return bswap_32(x); }
+
+  static bool IsLittleEndian() { return false; }
+
+#else  // !defined(WORDS_BIGENDIAN)
+
+  static uint16 FromHost16(uint16 x) { return x; }
+  static uint16 ToHost16(uint16 x) { return x; }
+
+  static uint32 FromHost32(uint32 x) { return x; }
+  static uint32 ToHost32(uint32 x) { return x; }
+
+  static bool IsLittleEndian() { return true; }
+
+#endif  // !defined(WORDS_BIGENDIAN)
+
+  // Functions to do unaligned loads and stores in little-endian order.
+  static uint16 Load16(const void *p) {
+    return ToHost16(UNALIGNED_LOAD16(p));
+  }
+
+  static void Store16(void *p, uint16 v) {
+    UNALIGNED_STORE16(p, FromHost16(v));
+  }
+
+  static uint32 Load32(const void *p) {
+    return ToHost32(UNALIGNED_LOAD32(p));
+  }
+
+  static void Store32(void *p, uint32 v) {
+    UNALIGNED_STORE32(p, FromHost32(v));
+  }
+};
+
+// Some bit-manipulation functions.
+class Bits {
+ public:
+  // Return floor(log2(n)) for positive integer n.  Returns -1 iff n == 0.
+  static int Log2Floor(uint32 n);
+
+  // Return the first set least / most significant bit, 0-indexed.  Returns an
+  // undefined value if n == 0.  FindLSBSetNonZero() is similar to ffs() except
+  // that it's 0-indexed.
+  static int FindLSBSetNonZero(uint32 n);
+  static int FindLSBSetNonZero64(uint64 n);
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(Bits);
+};
+
+#ifdef HAVE_BUILTIN_CTZ
+
+inline int Bits::Log2Floor(uint32 n) {
+  return n == 0 ? -1 : 31 ^ __builtin_clz(n);
+}
+
+inline int Bits::FindLSBSetNonZero(uint32 n) {
+  return __builtin_ctz(n);
+}
+
+inline int Bits::FindLSBSetNonZero64(uint64 n) {
+  return __builtin_ctzll(n);
+}
+
+#elif defined(WIN32)
+#include <intrin.h>
+#pragma intrinsic(_BitScanReverse)
+
+inline int Bits::Log2Floor(uint32 n) {
+	unsigned long r = 0;
+	return _BitScanReverse(&r, n) ? r : -1;
+}
+
+inline int Bits::FindLSBSetNonZero(uint32 n) {
+	unsigned long r = 0;
+	return _BitScanForward(&r, n) ? r : 32;
+}
+
+#ifdef _M_X64
+
+inline int Bits::FindLSBSetNonZero64(uint64 n) {
+	unsigned long r = 0;
+	return _BitScanForward64(&r, n) ? r : 64;
+}
+
+#else
+
+inline int Bits::FindLSBSetNonZero64(uint64 n) {
+	unsigned long r1 = 0, r2 = 0;
+	return _BitScanForward(&r1, (uint32)n) ? r1 : _BitScanForward(&r2, (uint32)(n >> 32)) ? 32 + r2 : 64;
+}
+
+#endif
+
+#else  // Portable versions.
+
+inline int Bits::Log2Floor(uint32 n) {
+  if (n == 0)
+    return -1;
+  int log = 0;
+  uint32 value = n;
+  for (int i = 4; i >= 0; --i) {
+    int shift = (1 << i);
+    uint32 x = value >> shift;
+    if (x != 0) {
+      value = x;
+      log += shift;
+    }
+  }
+  assert(value == 1);
+  return log;
+}
+
+inline int Bits::FindLSBSetNonZero(uint32 n) {
+  int rc = 31;
+  for (int i = 4, shift = 1 << 4; i >= 0; --i) {
+    const uint32 x = n << shift;
+    if (x != 0) {
+      n = x;
+      rc -= shift;
+    }
+    shift >>= 1;
+  }
+  return rc;
+}
+
+// FindLSBSetNonZero64() is defined in terms of FindLSBSetNonZero().
+inline int Bits::FindLSBSetNonZero64(uint64 n) {
+  const uint32 bottombits = static_cast<uint32>(n);
+  if (bottombits == 0) {
+    // Bottom bits are zero, so scan in top bits
+    return 32 + FindLSBSetNonZero(static_cast<uint32>(n >> 32));
+  } else {
+    return FindLSBSetNonZero(bottombits);
+  }
+}
+
+#endif  // End portable versions.
+
+// Variable-length integer encoding.
+class Varint {
+ public:
+  // Maximum lengths of varint encoding of uint32.
+  static const int kMax32 = 5;
+
+  // Attempts to parse a varint32 from a prefix of the bytes in [ptr,limit-1].
+  // Never reads a character at or beyond limit.  If a valid/terminated varint32
+  // was found in the range, stores it in *OUTPUT and returns a pointer just
+  // past the last byte of the varint32. Else returns NULL.  On success,
+  // "result <= limit".
+  static const char* Parse32WithLimit(const char* ptr, const char* limit,
+                                      uint32* OUTPUT);
+
+  // REQUIRES   "ptr" points to a buffer of length sufficient to hold "v".
+  // EFFECTS    Encodes "v" into "ptr" and returns a pointer to the
+  //            byte just past the last encoded byte.
+  static char* Encode32(char* ptr, uint32 v);
+
+  // EFFECTS    Appends the varint representation of "value" to "*s".
+  static void Append32(string* s, uint32 value);
+};
+
+inline const char* Varint::Parse32WithLimit(const char* p,
+                                            const char* l,
+                                            uint32* OUTPUT) {
+  const unsigned char* ptr = reinterpret_cast<const unsigned char*>(p);
+  const unsigned char* limit = reinterpret_cast<const unsigned char*>(l);
+  uint32 b, result;
+  if (ptr >= limit) return NULL;
+  b = *(ptr++); result = b & 127;          if (b < 128) goto done;
+  if (ptr >= limit) return NULL;
+  b = *(ptr++); result |= (b & 127) <<  7; if (b < 128) goto done;
+  if (ptr >= limit) return NULL;
+  b = *(ptr++); result |= (b & 127) << 14; if (b < 128) goto done;
+  if (ptr >= limit) return NULL;
+  b = *(ptr++); result |= (b & 127) << 21; if (b < 128) goto done;
+  if (ptr >= limit) return NULL;
+  b = *(ptr++); result |= (b & 127) << 28; if (b < 16) goto done;
+  return NULL;       // Value is too long to be a varint32
+ done:
+  *OUTPUT = result;
+  return reinterpret_cast<const char*>(ptr);
+}
+
+inline char* Varint::Encode32(char* sptr, uint32 v) {
+  // Operate on characters as unsigneds
+  unsigned char* ptr = reinterpret_cast<unsigned char*>(sptr);
+  static const int B = 128;
+  if (v < (1<<7)) {
+    *(ptr++) = v;
+  } else if (v < (1<<14)) {
+    *(ptr++) = v | B;
+    *(ptr++) = v>>7;
+  } else if (v < (1<<21)) {
+    *(ptr++) = v | B;
+    *(ptr++) = (v>>7) | B;
+    *(ptr++) = v>>14;
+  } else if (v < (1<<28)) {
+    *(ptr++) = v | B;
+    *(ptr++) = (v>>7) | B;
+    *(ptr++) = (v>>14) | B;
+    *(ptr++) = v>>21;
+  } else {
+    *(ptr++) = v | B;
+    *(ptr++) = (v>>7) | B;
+    *(ptr++) = (v>>14) | B;
+    *(ptr++) = (v>>21) | B;
+    *(ptr++) = v>>28;
+  }
+  return reinterpret_cast<char*>(ptr);
+}
+
+// If you know the internal layout of the std::string in use, you can
+// replace this function with one that resizes the string without
+// filling the new space with zeros (if applicable) --
+// it will be non-portable but faster.
+inline void STLStringResizeUninitialized(string* s, size_t new_size) {
+  s->resize(new_size);
+}
+
+// Return a mutable char* pointing to a string's internal buffer,
+// which may not be null-terminated. Writing through this pointer will
+// modify the string.
+//
+// string_as_array(&str)[i] is valid for 0 <= i < str.size() until the
+// next call to a string method that invalidates iterators.
+//
+// As of 2006-04, there is no standard-blessed way of getting a
+// mutable reference to a string's internal buffer. However, issue 530
+// (http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-defects.html#530)
+// proposes this as the method. It will officially be part of the standard
+// for C++0x. This should already work on all current implementations.
+inline char* string_as_array(string* str) {
+  return str->empty() ? NULL : &*str->begin();
+}
+
+}  // namespace snappy
+
+#endif  // UTIL_SNAPPY_OPENSOURCE_SNAPPY_STUBS_INTERNAL_H_
diff --git a/packages/Snappy.1.1.1.7/lib/native/include/snappy-stubs-public.h b/packages/Snappy.1.1.1.7/lib/native/include/snappy-stubs-public.h
new file mode 100644
index 0000000..426ad40
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/include/snappy-stubs-public.h
@@ -0,0 +1,38 @@
+#ifndef UTIL_SNAPPY_OPENSOURCE_SNAPPY_STUBS_PUBLIC_H_
+#define UTIL_SNAPPY_OPENSOURCE_SNAPPY_STUBS_PUBLIC_H_
+
+#include <stdint.h>
+#include <stddef.h>
+
+#define SNAPPY_MAJOR 1
+#define SNAPPY_MINOR 1
+#define SNAPPY_PATCHLEVEL 1
+#define SNAPPY_BUILD 7
+#define SNAPPY_VERSION \
+	((SNAPPY_MAJOR << 16) | (SNAPPY_MINOR << 8) | SNAPPY_PATCHLEVEL)
+#define SNAPPY_VERSION_STRING "1.1.1.7"
+
+#include <string>
+
+namespace snappy {
+
+	typedef int ssize_t;
+
+	typedef int8_t int8;
+	typedef uint8_t uint8;
+	typedef int16_t int16;
+	typedef uint16_t uint16;
+	typedef int32_t int32;
+	typedef uint32_t uint32;
+	typedef int64_t int64;
+	typedef uint64_t uint64;
+
+	typedef std::string string;
+
+#define DISALLOW_COPY_AND_ASSIGN(TypeName) \
+	TypeName(const TypeName&);               \
+	void operator=(const TypeName&)
+
+}  // namespace snappy
+
+#endif  // UTIL_SNAPPY_OPENSOURCE_SNAPPY_STUBS_PUBLIC_H_
diff --git a/packages/Snappy.1.1.1.7/lib/native/include/snappy-test.h b/packages/Snappy.1.1.1.7/lib/native/include/snappy-test.h
new file mode 100644
index 0000000..7d88d97
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/include/snappy-test.h
@@ -0,0 +1,598 @@
+// Copyright 2011 Google Inc. All Rights Reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Various stubs for the unit tests for the open-source version of Snappy.
+
+#ifndef UTIL_SNAPPY_OPENSOURCE_SNAPPY_TEST_H_
+#define UTIL_SNAPPY_OPENSOURCE_SNAPPY_TEST_H_
+
+#ifndef SNAPPY_STATIC
+#ifdef SNAPPY_EXPORTS
+#define SNAPPY_API __declspec(dllexport)
+#else
+#define SNAPPY_API __declspec(dllimport)
+#endif
+#else
+#define SNAPPY_API
+#endif
+
+#include <iostream>
+#include <string>
+
+#include "snappy-stubs-internal.h"
+
+#include <stdio.h>
+#include <stdarg.h>
+
+#ifdef HAVE_SYS_MMAN_H
+#include <sys/mman.h>
+#endif
+
+#ifdef HAVE_SYS_RESOURCE_H
+#include <sys/resource.h>
+#endif
+
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
+#include <string>
+
+#ifdef HAVE_GTEST
+
+#include <gtest/gtest.h>
+#undef TYPED_TEST
+#define TYPED_TEST TEST
+#define INIT_GTEST(argc, argv) ::testing::InitGoogleTest(argc, *argv)
+
+#else
+
+// Stubs for if the user doesn't have Google Test installed.
+
+#define TEST(test_case, test_subcase) \
+  void Test_ ## test_case ## _ ## test_subcase()
+#define INIT_GTEST(argc, argv)
+
+#define TYPED_TEST TEST
+#define EXPECT_EQ CHECK_EQ
+#define EXPECT_NE CHECK_NE
+#define EXPECT_FALSE(cond) CHECK(!(cond))
+
+#endif
+
+#ifdef HAVE_GFLAGS
+
+#include <gflags/gflags.h>
+
+// This is tricky; both gflags and Google Test want to look at the command line
+// arguments. Google Test seems to be the most happy with unknown arguments,
+// though, so we call it first and hope for the best.
+#define InitGoogle(argv0, argc, argv, remove_flags) \
+  INIT_GTEST(argc, argv); \
+  google::ParseCommandLineFlags(argc, argv, remove_flags);
+
+#else
+
+// If we don't have the gflags package installed, these can only be
+// changed at compile time.
+#define DEFINE_int32(flag_name, default_value, description) \
+  static int FLAGS_ ## flag_name = default_value;
+
+#define InitGoogle(argv0, argc, argv, remove_flags) \
+  INIT_GTEST(argc, argv)
+
+#endif
+
+#ifdef HAVE_LIBZ
+#include "zlib.h"
+#endif
+
+#ifdef HAVE_LIBLZO2
+#include "lzo/lzo1x.h"
+#endif
+
+#ifdef HAVE_LIBLZF
+extern "C" {
+#include "lzf.h"
+}
+#endif
+
+#ifdef HAVE_LIBFASTLZ
+#include "fastlz.h"
+#endif
+
+#ifdef HAVE_LIBQUICKLZ
+#include "quicklz.h"
+#endif
+
+namespace {
+
+namespace File {
+  void Init() { }
+}  // namespace File
+
+namespace file {
+  int Defaults() { return 0; }
+
+  class DummyStatus {
+   public:
+    void CheckSuccess() { }
+  };
+
+  DummyStatus GetContents(const string& filename, string* data, int unused) {
+    FILE* fp = fopen(filename.c_str(), "rb");
+    if (fp == NULL) {
+      perror(filename.c_str());
+      exit(1);
+    }
+
+    data->clear();
+    while (!feof(fp)) {
+      char buf[4096];
+      size_t ret = fread(buf, 1, 4096, fp);
+      if (ret == 0 && ferror(fp)) {
+        perror("fread");
+        exit(1);
+      }
+      data->append(string(buf, ret));
+    }
+
+    fclose(fp);
+  }
+
+  DummyStatus SetContents(const string& filename,
+                          const string& str,
+                          int unused) {
+    FILE* fp = fopen(filename.c_str(), "wb");
+    if (fp == NULL) {
+      perror(filename.c_str());
+      exit(1);
+    }
+
+    int ret = fwrite(str.data(), str.size(), 1, fp);
+    if (ret != 1) {
+      perror("fwrite");
+      exit(1);
+    }
+
+    fclose(fp);
+  }
+}  // namespace file
+
+}  // namespace
+
+namespace snappy {
+
+#define FLAGS_test_random_seed 301
+typedef string TypeParam;
+
+void Test_CorruptedTest_VerifyCorrupted();
+void Test_Snappy_SimpleTests();
+void Test_Snappy_MaxBlowup();
+void Test_Snappy_RandomData();
+void Test_Snappy_FourByteOffset();
+void Test_SnappyCorruption_TruncatedVarint();
+void Test_SnappyCorruption_UnterminatedVarint();
+void Test_Snappy_ReadPastEndOfBuffer();
+void Test_Snappy_FindMatchLength();
+void Test_Snappy_FindMatchLengthRandom();
+
+string ReadTestDataFile(const string& base, size_t size_limit);
+
+string ReadTestDataFile(const string& base);
+
+// A sprintf() variant that returns a std::string.
+// Not safe for general use due to truncation issues.
+string StringPrintf(const char* format, ...);
+
+// A simple, non-cryptographically-secure random generator.
+class ACMRandom {
+ public:
+  explicit ACMRandom(uint32 seed) : seed_(seed) {}
+
+  int32 Next();
+
+  int32 Uniform(int32 n) {
+    return Next() % n;
+  }
+  uint8 Rand8() {
+    return static_cast<uint8>((Next() >> 1) & 0x000000ff);
+  }
+  bool OneIn(int X) { return Uniform(X) == 0; }
+
+  // Skewed: pick "base" uniformly from range [0,max_log] and then
+  // return "base" random bits.  The effect is to pick a number in the
+  // range [0,2^max_log-1] with bias towards smaller numbers.
+  int32 Skewed(int max_log);
+
+ private:
+  static const uint32 M = 2147483647L;   // 2^31-1
+  uint32 seed_;
+};
+
+inline int32 ACMRandom::Next() {
+  static const uint64 A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0
+  // We are computing
+  //       seed_ = (seed_ * A) % M,    where M = 2^31-1
+  //
+  // seed_ must not be zero or M, or else all subsequent computed values
+  // will be zero or M respectively.  For all other values, seed_ will end
+  // up cycling through every number in [1,M-1]
+  uint64 product = seed_ * A;
+
+  // Compute (product % M) using the fact that ((x << 31) % M) == x.
+  seed_ = (product >> 31) + (product & M);
+  // The first reduction may overflow by 1 bit, so we may need to repeat.
+  // mod == M is not possible; using > allows the faster sign-bit-based test.
+  if (seed_ > M) {
+    seed_ -= M;
+  }
+  return seed_;
+}
+
+inline int32 ACMRandom::Skewed(int max_log) {
+  const int32 base = (Next() - 1) % (max_log+1);
+  return (Next() - 1) & ((1u << base)-1);
+}
+
+// A wall-time clock. This stub is not super-accurate, nor resistant to the
+// system time changing.
+class CycleTimer {
+ public:
+  CycleTimer() : real_time_us_(0) {}
+
+  void Start() {
+#ifdef WIN32
+    QueryPerformanceCounter(&start_);
+#else
+    gettimeofday(&start_, NULL);
+#endif
+  }
+
+  void Stop() {
+#ifdef WIN32
+    LARGE_INTEGER stop;
+    LARGE_INTEGER frequency;
+    QueryPerformanceCounter(&stop);
+    QueryPerformanceFrequency(&frequency);
+
+    double elapsed = static_cast<double>(stop.QuadPart - start_.QuadPart) /
+        frequency.QuadPart;
+    real_time_us_ += elapsed * 1e6 + 0.5;
+#else
+    struct timeval stop;
+    gettimeofday(&stop, NULL);
+
+    real_time_us_ += 1000000 * (stop.tv_sec - start_.tv_sec);
+    real_time_us_ += (stop.tv_usec - start_.tv_usec);
+#endif
+  }
+
+  double Get() {
+    return real_time_us_ * 1e-6;
+  }
+
+ private:
+  int64 real_time_us_;
+#ifdef WIN32
+  LARGE_INTEGER start_;
+#else
+  struct timeval start_;
+#endif
+};
+
+// Minimalistic microbenchmark framework.
+
+typedef void (*BenchmarkFunction)(int, int);
+
+class Benchmark {
+ public:
+  Benchmark(const string& name, BenchmarkFunction function) :
+      name_(name), function_(function) {}
+
+  Benchmark* DenseRange(int start, int stop) {
+    start_ = start;
+    stop_ = stop;
+    return this;
+  }
+
+  void Run();
+
+ private:
+  const string name_;
+  const BenchmarkFunction function_;
+  int start_, stop_;
+};
+#define BENCHMARK(benchmark_name) \
+  Benchmark* Benchmark_ ## benchmark_name = \
+          (new Benchmark(#benchmark_name, benchmark_name))
+
+extern Benchmark* Benchmark_BM_UFlat;
+#ifndef WIN32
+extern Benchmark* Benchmark_BM_UIOVec;
+#endif
+extern Benchmark* Benchmark_BM_UValidate;
+extern Benchmark* Benchmark_BM_ZFlat;
+
+void ResetBenchmarkTiming();
+void StartBenchmarkTiming();
+void StopBenchmarkTiming();
+void SetBenchmarkLabel(const string& str);
+void SetBenchmarkBytesProcessed(int64 bytes);
+
+#ifdef HAVE_LIBZ
+
+// Object-oriented wrapper around zlib.
+class ZLib {
+ public:
+  ZLib();
+  ~ZLib();
+
+  // Wipe a ZLib object to a virgin state.  This differs from Reset()
+  // in that it also breaks any state.
+  void Reinit();
+
+  // Call this to make a zlib buffer as good as new.  Here's the only
+  // case where they differ:
+  //    CompressChunk(a); CompressChunk(b); CompressChunkDone();   vs
+  //    CompressChunk(a); Reset(); CompressChunk(b); CompressChunkDone();
+  // You'll want to use Reset(), then, when you interrupt a compress
+  // (or uncompress) in the middle of a chunk and want to start over.
+  void Reset();
+
+  // According to the zlib manual, when you Compress, the destination
+  // buffer must have size at least src + .1%*src + 12.  This function
+  // helps you calculate that.  Augment this to account for a potential
+  // gzip header and footer, plus a few bytes of slack.
+  static int MinCompressbufSize(int uncompress_size) {
+    return uncompress_size + uncompress_size/1000 + 40;
+  }
+
+  // Compresses the source buffer into the destination buffer.
+  // sourceLen is the byte length of the source buffer.
+  // Upon entry, destLen is the total size of the destination buffer,
+  // which must be of size at least MinCompressbufSize(sourceLen).
+  // Upon exit, destLen is the actual size of the compressed buffer.
+  //
+  // This function can be used to compress a whole file at once if the
+  // input file is mmap'ed.
+  //
+  // Returns Z_OK if success, Z_MEM_ERROR if there was not
+  // enough memory, Z_BUF_ERROR if there was not enough room in the
+  // output buffer. Note that if the output buffer is exactly the same
+  // size as the compressed result, we still return Z_BUF_ERROR.
+  // (check CL#1936076)
+  int Compress(Bytef *dest, uLongf *destLen,
+               const Bytef *source, uLong sourceLen);
+
+  // Uncompresses the source buffer into the destination buffer.
+  // The destination buffer must be long enough to hold the entire
+  // decompressed contents.
+  //
+  // Returns Z_OK on success, otherwise, it returns a zlib error code.
+  int Uncompress(Bytef *dest, uLongf *destLen,
+                 const Bytef *source, uLong sourceLen);
+
+  // Uncompress data one chunk at a time -- ie you can call this
+  // more than once.  To get this to work you need to call per-chunk
+  // and "done" routines.
+  //
+  // Returns Z_OK if success, Z_MEM_ERROR if there was not
+  // enough memory, Z_BUF_ERROR if there was not enough room in the
+  // output buffer.
+
+  int UncompressAtMost(Bytef *dest, uLongf *destLen,
+                       const Bytef *source, uLong *sourceLen);
+
+  // Checks gzip footer information, as needed.  Mostly this just
+  // makes sure the checksums match.  Whenever you call this, it
+  // will assume the last 8 bytes from the previous UncompressChunk
+  // call are the footer.  Returns true iff everything looks ok.
+  bool UncompressChunkDone();
+
+ private:
+  int InflateInit();       // sets up the zlib inflate structure
+  int DeflateInit();       // sets up the zlib deflate structure
+
+  // These init the zlib data structures for compressing/uncompressing
+  int CompressInit(Bytef *dest, uLongf *destLen,
+                   const Bytef *source, uLong *sourceLen);
+  int UncompressInit(Bytef *dest, uLongf *destLen,
+                     const Bytef *source, uLong *sourceLen);
+  // Initialization method to be called if we hit an error while
+  // uncompressing. On hitting an error, call this method before
+  // returning the error.
+  void UncompressErrorInit();
+
+  // Helper function for Compress
+  int CompressChunkOrAll(Bytef *dest, uLongf *destLen,
+                         const Bytef *source, uLong sourceLen,
+                         int flush_mode);
+  int CompressAtMostOrAll(Bytef *dest, uLongf *destLen,
+                          const Bytef *source, uLong *sourceLen,
+                          int flush_mode);
+
+  // Likewise for UncompressAndUncompressChunk
+  int UncompressChunkOrAll(Bytef *dest, uLongf *destLen,
+                           const Bytef *source, uLong sourceLen,
+                           int flush_mode);
+
+  int UncompressAtMostOrAll(Bytef *dest, uLongf *destLen,
+                            const Bytef *source, uLong *sourceLen,
+                            int flush_mode);
+
+  // Initialization method to be called if we hit an error while
+  // compressing. On hitting an error, call this method before
+  // returning the error.
+  void CompressErrorInit();
+
+  int compression_level_;   // compression level
+  int window_bits_;         // log base 2 of the window size used in compression
+  int mem_level_;           // specifies the amount of memory to be used by
+                            // compressor (1-9)
+  z_stream comp_stream_;    // Zlib stream data structure
+  bool comp_init_;          // True if we have initialized comp_stream_
+  z_stream uncomp_stream_;  // Zlib stream data structure
+  bool uncomp_init_;        // True if we have initialized uncomp_stream_
+
+  // These are used only with chunked compression.
+  bool first_chunk_;       // true if we need to emit headers with this chunk
+};
+
+#endif  // HAVE_LIBZ
+
+}  // namespace snappy
+
+DECLARE_bool(run_microbenchmarks);
+
+static void RunSpecifiedBenchmarks() {
+  if (!FLAGS_run_microbenchmarks) {
+    return;
+  }
+
+  fprintf(stderr, "Running microbenchmarks.\n");
+#ifndef NDEBUG
+  fprintf(stderr, "WARNING: Compiled with assertions enabled, will be slow.\n");
+#endif
+#ifndef WIN32
+#ifndef __OPTIMIZE__
+  fprintf(stderr, "WARNING: Compiled without optimization, will be slow.\n");
+#endif
+#endif
+  fprintf(stderr, "Benchmark            Time(ns)    CPU(ns) Iterations\n");
+  fprintf(stderr, "---------------------------------------------------\n");
+
+  snappy::Benchmark_BM_UFlat->Run();
+#ifndef WIN32
+  snappy::Benchmark_BM_UIOVec->Run();
+#endif
+  snappy::Benchmark_BM_UValidate->Run();
+  snappy::Benchmark_BM_ZFlat->Run();
+
+  fprintf(stderr, "\n");
+}
+
+#ifndef HAVE_GTEST
+
+static inline int RUN_ALL_TESTS() {
+  fprintf(stderr, "Running correctness tests.\n");
+  snappy::Test_CorruptedTest_VerifyCorrupted();
+  snappy::Test_Snappy_SimpleTests();
+  snappy::Test_Snappy_MaxBlowup();
+  snappy::Test_Snappy_RandomData();
+  snappy::Test_Snappy_FourByteOffset();
+  snappy::Test_SnappyCorruption_TruncatedVarint();
+  snappy::Test_SnappyCorruption_UnterminatedVarint();
+  snappy::Test_Snappy_ReadPastEndOfBuffer();
+  snappy::Test_Snappy_FindMatchLength();
+  snappy::Test_Snappy_FindMatchLengthRandom();
+  fprintf(stderr, "All tests passed.\n");
+
+  return 0;
+}
+
+#endif  // HAVE_GTEST
+
+// For main().
+namespace snappy {
+
+static void CompressFile(const char* fname);
+static void UncompressFile(const char* fname);
+static void MeasureFile(const char* fname);
+
+// Logging.
+
+#define LOG(level) LogMessage()
+#define VLOG(level) true ? (void)0 : \
+    snappy::LogMessageVoidify() & snappy::LogMessage()
+
+class LogMessage {
+ public:
+  LogMessage() { }
+  ~LogMessage() {
+    cerr << endl;
+  }
+
+  LogMessage& operator<<(const std::string& msg) {
+    cerr << msg;
+    return *this;
+  }
+  LogMessage& operator<<(int x) {
+    cerr << x;
+    return *this;
+  }
+};
+
+// Asserts, both versions activated in debug mode only,
+// and ones that are always active.
+
+#define CRASH_UNLESS(condition) \
+    PREDICT_TRUE(condition) ? (void)0 : \
+    snappy::LogMessageVoidify() & snappy::LogMessageCrash()
+
+class LogMessageCrash : public LogMessage {
+ public:
+  LogMessageCrash() { }
+  ~LogMessageCrash() {
+    cerr << endl;
+    abort();
+  }
+};
+
+// This class is used to explicitly ignore values in the conditional
+// logging macros.  This avoids compiler warnings like "value computed
+// is not used" and "statement has no effect".
+
+class LogMessageVoidify {
+ public:
+  LogMessageVoidify() { }
+  // This has to be an operator with a precedence lower than << but
+  // higher than ?:
+  void operator&(const LogMessage&) { }
+};
+
+#define CHECK(cond) CRASH_UNLESS(cond)
+#define CHECK_LE(a, b) CRASH_UNLESS((a) <= (b))
+#define CHECK_GE(a, b) CRASH_UNLESS((a) >= (b))
+#define CHECK_EQ(a, b) CRASH_UNLESS((a) == (b))
+#define CHECK_NE(a, b) CRASH_UNLESS((a) != (b))
+#define CHECK_LT(a, b) CRASH_UNLESS((a) < (b))
+#define CHECK_GT(a, b) CRASH_UNLESS((a) > (b))
+
+}  // namespace
+
+using snappy::CompressFile;
+using snappy::UncompressFile;
+using snappy::MeasureFile;
+
+extern "C" SNAPPY_API int snappy_unittests(int argc, char** argv);
+
+#endif  // UTIL_SNAPPY_OPENSOURCE_SNAPPY_TEST_H_
diff --git a/packages/Snappy.1.1.1.7/lib/native/include/snappy.h b/packages/Snappy.1.1.1.7/lib/native/include/snappy.h
new file mode 100644
index 0000000..e879e79
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/include/snappy.h
@@ -0,0 +1,184 @@
+// Copyright 2005 and onwards Google Inc.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// A light-weight compression algorithm.  It is designed for speed of
+// compression and decompression, rather than for the utmost in space
+// savings.
+//
+// For getting better compression ratios when you are compressing data
+// with long repeated sequences or compressing data that is similar to
+// other data, while still compressing fast, you might look at first
+// using BMDiff and then compressing the output of BMDiff with
+// Snappy.
+
+#ifndef UTIL_SNAPPY_SNAPPY_H__
+#define UTIL_SNAPPY_SNAPPY_H__
+
+#include <stddef.h>
+#include <string>
+
+#include "snappy-stubs-public.h"
+
+namespace snappy {
+  class Source;
+  class Sink;
+
+  // ------------------------------------------------------------------------
+  // Generic compression/decompression routines.
+  // ------------------------------------------------------------------------
+
+  // Compress the bytes read from "*source" and append to "*sink". Return the
+  // number of bytes written.
+  size_t Compress(Source* source, Sink* sink);
+
+  // Find the uncompressed length of the given stream, as given by the header.
+  // Note that the true length could deviate from this; the stream could e.g.
+  // be truncated.
+  //
+  // Also note that this leaves "*source" in a state that is unsuitable for
+  // further operations, such as RawUncompress(). You will need to rewind
+  // or recreate the source yourself before attempting any further calls.
+  bool GetUncompressedLength(Source* source, uint32* result);
+
+  // ------------------------------------------------------------------------
+  // Higher-level string based routines (should be sufficient for most users)
+  // ------------------------------------------------------------------------
+
+  // Sets "*output" to the compressed version of "input[0,input_length-1]".
+  // Original contents of *output are lost.
+  //
+  // REQUIRES: "input[]" is not an alias of "*output".
+  size_t Compress(const char* input, size_t input_length, string* output);
+
+  // Decompresses "compressed[0,compressed_length-1]" to "*uncompressed".
+  // Original contents of "*uncompressed" are lost.
+  //
+  // REQUIRES: "compressed[]" is not an alias of "*uncompressed".
+  //
+  // returns false if the message is corrupted and could not be decompressed
+  bool Uncompress(const char* compressed, size_t compressed_length,
+                  string* uncompressed);
+
+
+  // ------------------------------------------------------------------------
+  // Lower-level character array based routines.  May be useful for
+  // efficiency reasons in certain circumstances.
+  // ------------------------------------------------------------------------
+
+  // REQUIRES: "compressed" must point to an area of memory that is at
+  // least "MaxCompressedLength(input_length)" bytes in length.
+  //
+  // Takes the data stored in "input[0..input_length]" and stores
+  // it in the array pointed to by "compressed".
+  //
+  // "*compressed_length" is set to the length of the compressed output.
+  //
+  // Example:
+  //    char* output = new char[snappy::MaxCompressedLength(input_length)];
+  //    size_t output_length;
+  //    RawCompress(input, input_length, output, &output_length);
+  //    ... Process(output, output_length) ...
+  //    delete [] output;
+  void RawCompress(const char* input,
+                   size_t input_length,
+                   char* compressed,
+                   size_t* compressed_length);
+
+  // Given data in "compressed[0..compressed_length-1]" generated by
+  // calling the Snappy::Compress routine, this routine
+  // stores the uncompressed data to
+  //    uncompressed[0..GetUncompressedLength(compressed)-1]
+  // returns false if the message is corrupted and could not be decrypted
+  bool RawUncompress(const char* compressed, size_t compressed_length,
+                     char* uncompressed);
+
+  // Given data from the byte source 'compressed' generated by calling
+  // the Snappy::Compress routine, this routine stores the uncompressed
+  // data to
+  //    uncompressed[0..GetUncompressedLength(compressed,compressed_length)-1]
+  // returns false if the message is corrupted and could not be decrypted
+  bool RawUncompress(Source* compressed, char* uncompressed);
+
+  // Given data in "compressed[0..compressed_length-1]" generated by
+  // calling the Snappy::Compress routine, this routine
+  // stores the uncompressed data to the iovec "iov". The number of physical
+  // buffers in "iov" is given by iov_cnt and their cumulative size
+  // must be at least GetUncompressedLength(compressed). The individual buffers
+  // in "iov" must not overlap with each other.
+  //
+  // returns false if the message is corrupted and could not be decrypted
+  bool RawUncompressToIOVec(const char* compressed, size_t compressed_length,
+                            const struct iovec* iov, size_t iov_cnt);
+
+  // Given data from the byte source 'compressed' generated by calling
+  // the Snappy::Compress routine, this routine stores the uncompressed
+  // data to the iovec "iov". The number of physical
+  // buffers in "iov" is given by iov_cnt and their cumulative size
+  // must be at least GetUncompressedLength(compressed). The individual buffers
+  // in "iov" must not overlap with each other.
+  //
+  // returns false if the message is corrupted and could not be decrypted
+  bool RawUncompressToIOVec(Source* compressed, const struct iovec* iov,
+                            size_t iov_cnt);
+
+  // Returns the maximal size of the compressed representation of
+  // input data that is "source_bytes" bytes in length;
+  size_t MaxCompressedLength(size_t source_bytes);
+
+  // REQUIRES: "compressed[]" was produced by RawCompress() or Compress()
+  // Returns true and stores the length of the uncompressed data in
+  // *result normally.  Returns false on parsing error.
+  // This operation takes O(1) time.
+  bool GetUncompressedLength(const char* compressed, size_t compressed_length,
+                             size_t* result);
+
+  // Returns true iff the contents of "compressed[]" can be uncompressed
+  // successfully.  Does not return the uncompressed data.  Takes
+  // time proportional to compressed_length, but is usually at least
+  // a factor of four faster than actual decompression.
+  bool IsValidCompressedBuffer(const char* compressed,
+                               size_t compressed_length);
+
+  // The size of a compression block. Note that many parts of the compression
+  // code assumes that kBlockSize <= 65536; in particular, the hash table
+  // can only store 16-bit offsets, and EmitCopy() also assumes the offset
+  // is 65535 bytes or less. Note also that if you change this, it will
+  // affect the framing format (see framing_format.txt).
+  //
+  // Note that there might be older data around that is compressed with larger
+  // block sizes, so the decompression code should not rely on the
+  // non-existence of long backreferences.
+  static const int kBlockLog = 16;
+  static const size_t kBlockSize = 1 << kBlockLog;
+
+  static const int kMaxHashTableBits = 14;
+  static const size_t kMaxHashTableSize = 1 << kMaxHashTableBits;
+}  // end namespace snappy
+
+
+#endif  // UTIL_SNAPPY_SNAPPY_H__
diff --git a/packages/Snappy.1.1.1.7/lib/native/src/snappy-c.cc b/packages/Snappy.1.1.1.7/lib/native/src/snappy-c.cc
new file mode 100644
index 0000000..473a0b0
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/src/snappy-c.cc
@@ -0,0 +1,90 @@
+// Copyright 2011 Martin Gieseking <martin.gieseking@uos.de>.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "snappy.h"
+#include "snappy-c.h"
+
+extern "C" {
+
+snappy_status snappy_compress(const char* input,
+                              size_t input_length,
+                              char* compressed,
+                              size_t *compressed_length) {
+  if (*compressed_length < snappy_max_compressed_length(input_length)) {
+    return SNAPPY_BUFFER_TOO_SMALL;
+  }
+  snappy::RawCompress(input, input_length, compressed, compressed_length);
+  return SNAPPY_OK;
+}
+
+snappy_status snappy_uncompress(const char* compressed,
+                                size_t compressed_length,
+                                char* uncompressed,
+                                size_t* uncompressed_length) {
+  size_t real_uncompressed_length;
+  if (!snappy::GetUncompressedLength(compressed,
+                                     compressed_length,
+                                     &real_uncompressed_length)) {
+    return SNAPPY_INVALID_INPUT;
+  }
+  if (*uncompressed_length < real_uncompressed_length) {
+    return SNAPPY_BUFFER_TOO_SMALL;
+  }
+  if (!snappy::RawUncompress(compressed, compressed_length, uncompressed)) {
+    return SNAPPY_INVALID_INPUT;
+  }
+  *uncompressed_length = real_uncompressed_length;
+  return SNAPPY_OK;
+}
+
+size_t snappy_max_compressed_length(size_t source_length) {
+  return snappy::MaxCompressedLength(source_length);
+}
+
+snappy_status snappy_uncompressed_length(const char *compressed,
+                                         size_t compressed_length,
+                                         size_t *result) {
+  if (snappy::GetUncompressedLength(compressed,
+                                    compressed_length,
+                                    result)) {
+    return SNAPPY_OK;
+  } else {
+    return SNAPPY_INVALID_INPUT;
+  }
+}
+
+snappy_status snappy_validate_compressed_buffer(const char *compressed,
+                                                size_t compressed_length) {
+  if (snappy::IsValidCompressedBuffer(compressed, compressed_length)) {
+    return SNAPPY_OK;
+  } else {
+    return SNAPPY_INVALID_INPUT;
+  }
+}
+
+}  // extern "C"
diff --git a/packages/Snappy.1.1.1.7/lib/native/src/snappy-single-file.cpp b/packages/Snappy.1.1.1.7/lib/native/src/snappy-single-file.cpp
new file mode 100644
index 0000000..eb06bf7
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/src/snappy-single-file.cpp
@@ -0,0 +1,12 @@
+#ifndef _CRT_SECURE_NO_WARNINGS
+#define _CRT_SECURE_NO_WARNINGS
+#endif
+
+#pragma warning(disable: 4244 4018 4309 4005 4722 4715 4267)
+
+#include "snappy.cc"
+#include "snappy-sinksource.cc"
+#include "snappy-stubs-internal.cc"
+#include "snappy-c.cc"
+#include "snappy-test.cc"
+#include "snappy_unittest.cc"
diff --git a/packages/Snappy.1.1.1.7/lib/native/src/snappy-sinksource.cc b/packages/Snappy.1.1.1.7/lib/native/src/snappy-sinksource.cc
new file mode 100644
index 0000000..5844552
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/src/snappy-sinksource.cc
@@ -0,0 +1,71 @@
+// Copyright 2011 Google Inc. All Rights Reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <string.h>
+
+#include "snappy-sinksource.h"
+
+namespace snappy {
+
+Source::~Source() { }
+
+Sink::~Sink() { }
+
+char* Sink::GetAppendBuffer(size_t length, char* scratch) {
+  return scratch;
+}
+
+ByteArraySource::~ByteArraySource() { }
+
+size_t ByteArraySource::Available() const { return left_; }
+
+const char* ByteArraySource::Peek(size_t* len) {
+  *len = left_;
+  return ptr_;
+}
+
+void ByteArraySource::Skip(size_t n) {
+  left_ -= n;
+  ptr_ += n;
+}
+
+UncheckedByteArraySink::~UncheckedByteArraySink() { }
+
+void UncheckedByteArraySink::Append(const char* data, size_t n) {
+  // Do no copying if the caller filled in the result of GetAppendBuffer()
+  if (data != dest_) {
+    memcpy(dest_, data, n);
+  }
+  dest_ += n;
+}
+
+char* UncheckedByteArraySink::GetAppendBuffer(size_t len, char* scratch) {
+  return dest_;
+}
+
+}
diff --git a/packages/Snappy.1.1.1.7/lib/native/src/snappy-stubs-internal.cc b/packages/Snappy.1.1.1.7/lib/native/src/snappy-stubs-internal.cc
new file mode 100644
index 0000000..6ed3343
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/src/snappy-stubs-internal.cc
@@ -0,0 +1,42 @@
+// Copyright 2011 Google Inc. All Rights Reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <algorithm>
+#include <string>
+
+#include "snappy-stubs-internal.h"
+
+namespace snappy {
+
+void Varint::Append32(string* s, uint32 value) {
+  char buf[Varint::kMax32];
+  const char* p = Varint::Encode32(buf, value);
+  s->append(buf, p - buf);
+}
+
+}  // namespace snappy
diff --git a/packages/Snappy.1.1.1.7/lib/native/src/snappy-test.cc b/packages/Snappy.1.1.1.7/lib/native/src/snappy-test.cc
new file mode 100644
index 0000000..4619410
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/src/snappy-test.cc
@@ -0,0 +1,606 @@
+// Copyright 2011 Google Inc. All Rights Reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Various stubs for the unit tests for the open-source version of Snappy.
+
+#include "snappy-test.h"
+
+#ifdef HAVE_WINDOWS_H
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#endif
+
+#include <algorithm>
+
+DEFINE_bool(run_microbenchmarks, true,
+            "Run microbenchmarks before doing anything else.");
+
+namespace snappy {
+
+string ReadTestDataFile(const string& base, size_t size_limit) {
+  string contents;
+  const char* srcdir = getenv("srcdir");  // This is set by Automake.
+  string prefix;
+  if (srcdir) {
+    prefix = string(srcdir) + "/";
+  }
+  file::GetContents(prefix + "testdata/" + base, &contents, file::Defaults()
+      ).CheckSuccess();
+  if (size_limit > 0) {
+    contents = contents.substr(0, size_limit);
+  }
+  return contents;
+}
+
+string ReadTestDataFile(const string& base) {
+  return ReadTestDataFile(base, 0);
+}
+
+string StringPrintf(const char* format, ...) {
+  char buf[4096];
+  va_list ap;
+  va_start(ap, format);
+  vsnprintf(buf, sizeof(buf), format, ap);
+  va_end(ap);
+  return buf;
+}
+
+bool benchmark_running = false;
+int64 benchmark_real_time_us = 0;
+int64 benchmark_cpu_time_us = 0;
+string *benchmark_label = NULL;
+int64 benchmark_bytes_processed = 0;
+
+void ResetBenchmarkTiming() {
+  benchmark_real_time_us = 0;
+  benchmark_cpu_time_us = 0;
+}
+
+#ifdef WIN32
+LARGE_INTEGER benchmark_start_real;
+FILETIME benchmark_start_cpu;
+#else  // WIN32
+struct timeval benchmark_start_real;
+struct rusage benchmark_start_cpu;
+#endif  // WIN32
+
+void StartBenchmarkTiming() {
+#ifdef WIN32
+  QueryPerformanceCounter(&benchmark_start_real);
+  FILETIME dummy;
+  CHECK(GetProcessTimes(
+      GetCurrentProcess(), &dummy, &dummy, &dummy, &benchmark_start_cpu));
+#else
+  gettimeofday(&benchmark_start_real, NULL);
+  if (getrusage(RUSAGE_SELF, &benchmark_start_cpu) == -1) {
+    perror("getrusage(RUSAGE_SELF)");
+    exit(1);
+  }
+#endif
+  benchmark_running = true;
+}
+
+void StopBenchmarkTiming() {
+  if (!benchmark_running) {
+    return;
+  }
+
+#ifdef WIN32
+  LARGE_INTEGER benchmark_stop_real;
+  LARGE_INTEGER benchmark_frequency;
+  QueryPerformanceCounter(&benchmark_stop_real);
+  QueryPerformanceFrequency(&benchmark_frequency);
+
+  double elapsed_real = static_cast<double>(
+      benchmark_stop_real.QuadPart - benchmark_start_real.QuadPart) /
+      benchmark_frequency.QuadPart;
+  benchmark_real_time_us += elapsed_real * 1e6 + 0.5;
+
+  FILETIME benchmark_stop_cpu, dummy;
+  CHECK(GetProcessTimes(
+      GetCurrentProcess(), &dummy, &dummy, &dummy, &benchmark_stop_cpu));
+
+  ULARGE_INTEGER start_ulargeint;
+  start_ulargeint.LowPart = benchmark_start_cpu.dwLowDateTime;
+  start_ulargeint.HighPart = benchmark_start_cpu.dwHighDateTime;
+
+  ULARGE_INTEGER stop_ulargeint;
+  stop_ulargeint.LowPart = benchmark_stop_cpu.dwLowDateTime;
+  stop_ulargeint.HighPart = benchmark_stop_cpu.dwHighDateTime;
+
+  benchmark_cpu_time_us +=
+      (stop_ulargeint.QuadPart - start_ulargeint.QuadPart + 5) / 10;
+#else  // WIN32
+  struct timeval benchmark_stop_real;
+  gettimeofday(&benchmark_stop_real, NULL);
+  benchmark_real_time_us +=
+      1000000 * (benchmark_stop_real.tv_sec - benchmark_start_real.tv_sec);
+  benchmark_real_time_us +=
+      (benchmark_stop_real.tv_usec - benchmark_start_real.tv_usec);
+
+  struct rusage benchmark_stop_cpu;
+  if (getrusage(RUSAGE_SELF, &benchmark_stop_cpu) == -1) {
+    perror("getrusage(RUSAGE_SELF)");
+    exit(1);
+  }
+  benchmark_cpu_time_us += 1000000 * (benchmark_stop_cpu.ru_utime.tv_sec -
+                                      benchmark_start_cpu.ru_utime.tv_sec);
+  benchmark_cpu_time_us += (benchmark_stop_cpu.ru_utime.tv_usec -
+                            benchmark_start_cpu.ru_utime.tv_usec);
+#endif  // WIN32
+
+  benchmark_running = false;
+}
+
+void SetBenchmarkLabel(const string& str) {
+  if (benchmark_label) {
+    delete benchmark_label;
+  }
+  benchmark_label = new string(str);
+}
+
+void SetBenchmarkBytesProcessed(int64 bytes) {
+  benchmark_bytes_processed = bytes;
+}
+
+struct BenchmarkRun {
+  int64 real_time_us;
+  int64 cpu_time_us;
+};
+
+struct BenchmarkCompareCPUTime {
+  bool operator() (const BenchmarkRun& a, const BenchmarkRun& b) const {
+    return a.cpu_time_us < b.cpu_time_us;
+  }
+};
+
+void Benchmark::Run() {
+  for (int test_case_num = start_; test_case_num <= stop_; ++test_case_num) {
+    // Run a few iterations first to find out approximately how fast
+    // the benchmark is.
+    const int kCalibrateIterations = 100;
+    ResetBenchmarkTiming();
+    StartBenchmarkTiming();
+    (*function_)(kCalibrateIterations, test_case_num);
+    StopBenchmarkTiming();
+
+    // Let each test case run for about 200ms, but at least as many
+    // as we used to calibrate.
+    // Run five times and pick the median.
+    const int kNumRuns = 5;
+    const int kMedianPos = kNumRuns / 2;
+    int num_iterations = 0;
+    if (benchmark_real_time_us > 0) {
+      num_iterations = 200000 * kCalibrateIterations / benchmark_real_time_us;
+    }
+    num_iterations = max(num_iterations, kCalibrateIterations);
+    BenchmarkRun benchmark_runs[kNumRuns];
+
+    for (int run = 0; run < kNumRuns; ++run) {
+      ResetBenchmarkTiming();
+      StartBenchmarkTiming();
+      (*function_)(num_iterations, test_case_num);
+      StopBenchmarkTiming();
+
+      benchmark_runs[run].real_time_us = benchmark_real_time_us;
+      benchmark_runs[run].cpu_time_us = benchmark_cpu_time_us;
+    }
+
+    string heading = StringPrintf("%s/%d", name_.c_str(), test_case_num);
+    string human_readable_speed;
+
+    nth_element(benchmark_runs,
+                benchmark_runs + kMedianPos,
+                benchmark_runs + kNumRuns,
+                BenchmarkCompareCPUTime());
+    int64 real_time_us = benchmark_runs[kMedianPos].real_time_us;
+    int64 cpu_time_us = benchmark_runs[kMedianPos].cpu_time_us;
+    if (cpu_time_us <= 0) {
+      human_readable_speed = "?";
+    } else {
+      int64 bytes_per_second =
+          benchmark_bytes_processed * 1000000 / cpu_time_us;
+      if (bytes_per_second < 1024) {
+        human_readable_speed = StringPrintf("%dB/s", bytes_per_second);
+      } else if (bytes_per_second < 1024 * 1024) {
+        human_readable_speed = StringPrintf(
+            "%.1fkB/s", bytes_per_second / 1024.0f);
+      } else if (bytes_per_second < 1024 * 1024 * 1024) {
+        human_readable_speed = StringPrintf(
+            "%.1fMB/s", bytes_per_second / (1024.0f * 1024.0f));
+      } else {
+        human_readable_speed = StringPrintf(
+            "%.1fGB/s", bytes_per_second / (1024.0f * 1024.0f * 1024.0f));
+      }
+    }
+
+    fprintf(stderr,
+#ifdef WIN32
+            "%-18s %10I64d %10I64d %10d %s  %s\n",
+#else
+            "%-18s %10lld %10lld %10d %s  %s\n",
+#endif
+            heading.c_str(),
+            static_cast<long long>(real_time_us * 1000 / num_iterations),
+            static_cast<long long>(cpu_time_us * 1000 / num_iterations),
+            num_iterations,
+            human_readable_speed.c_str(),
+            benchmark_label->c_str());
+  }
+}
+
+#ifdef HAVE_LIBZ
+
+ZLib::ZLib()
+    : comp_init_(false),
+      uncomp_init_(false) {
+  Reinit();
+}
+
+ZLib::~ZLib() {
+  if (comp_init_)   { deflateEnd(&comp_stream_); }
+  if (uncomp_init_) { inflateEnd(&uncomp_stream_); }
+}
+
+void ZLib::Reinit() {
+  compression_level_ = Z_DEFAULT_COMPRESSION;
+  window_bits_ = MAX_WBITS;
+  mem_level_ =  8;  // DEF_MEM_LEVEL
+  if (comp_init_) {
+    deflateEnd(&comp_stream_);
+    comp_init_ = false;
+  }
+  if (uncomp_init_) {
+    inflateEnd(&uncomp_stream_);
+    uncomp_init_ = false;
+  }
+  first_chunk_ = true;
+}
+
+void ZLib::Reset() {
+  first_chunk_ = true;
+}
+
+// --------- COMPRESS MODE
+
+// Initialization method to be called if we hit an error while
+// compressing. On hitting an error, call this method before returning
+// the error.
+void ZLib::CompressErrorInit() {
+  deflateEnd(&comp_stream_);
+  comp_init_ = false;
+  Reset();
+}
+
+int ZLib::DeflateInit() {
+  return deflateInit2(&comp_stream_,
+                      compression_level_,
+                      Z_DEFLATED,
+                      window_bits_,
+                      mem_level_,
+                      Z_DEFAULT_STRATEGY);
+}
+
+int ZLib::CompressInit(Bytef *dest, uLongf *destLen,
+                       const Bytef *source, uLong *sourceLen) {
+  int err;
+
+  comp_stream_.next_in = (Bytef*)source;
+  comp_stream_.avail_in = (uInt)*sourceLen;
+  if ((uLong)comp_stream_.avail_in != *sourceLen) return Z_BUF_ERROR;
+  comp_stream_.next_out = dest;
+  comp_stream_.avail_out = (uInt)*destLen;
+  if ((uLong)comp_stream_.avail_out != *destLen) return Z_BUF_ERROR;
+
+  if ( !first_chunk_ )   // only need to set up stream the first time through
+    return Z_OK;
+
+  if (comp_init_) {      // we've already initted it
+    err = deflateReset(&comp_stream_);
+    if (err != Z_OK) {
+      LOG(WARNING) << "ERROR: Can't reset compress object; creating a new one";
+      deflateEnd(&comp_stream_);
+      comp_init_ = false;
+    }
+  }
+  if (!comp_init_) {     // first use
+    comp_stream_.zalloc = (alloc_func)0;
+    comp_stream_.zfree = (free_func)0;
+    comp_stream_.opaque = (voidpf)0;
+    err = DeflateInit();
+    if (err != Z_OK) return err;
+    comp_init_ = true;
+  }
+  return Z_OK;
+}
+
+// In a perfect world we'd always have the full buffer to compress
+// when the time came, and we could just call Compress().  Alas, we
+// want to do chunked compression on our webserver.  In this
+// application, we compress the header, send it off, then compress the
+// results, send them off, then compress the footer.  Thus we need to
+// use the chunked compression features of zlib.
+int ZLib::CompressAtMostOrAll(Bytef *dest, uLongf *destLen,
+                              const Bytef *source, uLong *sourceLen,
+                              int flush_mode) {   // Z_FULL_FLUSH or Z_FINISH
+  int err;
+
+  if ( (err=CompressInit(dest, destLen, source, sourceLen)) != Z_OK )
+    return err;
+
+  // This is used to figure out how many bytes we wrote *this chunk*
+  int compressed_size = comp_stream_.total_out;
+
+  // Some setup happens only for the first chunk we compress in a run
+  if ( first_chunk_ ) {
+    first_chunk_ = false;
+  }
+
+  // flush_mode is Z_FINISH for all mode, Z_SYNC_FLUSH for incremental
+  // compression.
+  err = deflate(&comp_stream_, flush_mode);
+
+  *sourceLen = comp_stream_.avail_in;
+
+  if ((err == Z_STREAM_END || err == Z_OK)
+      && comp_stream_.avail_in == 0
+      && comp_stream_.avail_out != 0 ) {
+    // we processed everything ok and the output buffer was large enough.
+    ;
+  } else if (err == Z_STREAM_END && comp_stream_.avail_in > 0) {
+    return Z_BUF_ERROR;                            // should never happen
+  } else if (err != Z_OK && err != Z_STREAM_END && err != Z_BUF_ERROR) {
+    // an error happened
+    CompressErrorInit();
+    return err;
+  } else if (comp_stream_.avail_out == 0) {     // not enough space
+    err = Z_BUF_ERROR;
+  }
+
+  assert(err == Z_OK || err == Z_STREAM_END || err == Z_BUF_ERROR);
+  if (err == Z_STREAM_END)
+    err = Z_OK;
+
+  // update the crc and other metadata
+  compressed_size = comp_stream_.total_out - compressed_size;  // delta
+  *destLen = compressed_size;
+
+  return err;
+}
+
+int ZLib::CompressChunkOrAll(Bytef *dest, uLongf *destLen,
+                             const Bytef *source, uLong sourceLen,
+                             int flush_mode) {   // Z_FULL_FLUSH or Z_FINISH
+  const int ret =
+    CompressAtMostOrAll(dest, destLen, source, &sourceLen, flush_mode);
+  if (ret == Z_BUF_ERROR)
+    CompressErrorInit();
+  return ret;
+}
+
+// This routine only initializes the compression stream once.  Thereafter, it
+// just does a deflateReset on the stream, which should be faster.
+int ZLib::Compress(Bytef *dest, uLongf *destLen,
+                   const Bytef *source, uLong sourceLen) {
+  int err;
+  if ( (err=CompressChunkOrAll(dest, destLen, source, sourceLen,
+                               Z_FINISH)) != Z_OK )
+    return err;
+  Reset();         // reset for next call to Compress
+
+  return Z_OK;
+}
+
+
+// --------- UNCOMPRESS MODE
+
+int ZLib::InflateInit() {
+  return inflateInit2(&uncomp_stream_, MAX_WBITS);
+}
+
+// Initialization method to be called if we hit an error while
+// uncompressing. On hitting an error, call this method before
+// returning the error.
+void ZLib::UncompressErrorInit() {
+  inflateEnd(&uncomp_stream_);
+  uncomp_init_ = false;
+  Reset();
+}
+
+int ZLib::UncompressInit(Bytef *dest, uLongf *destLen,
+                         const Bytef *source, uLong *sourceLen) {
+  int err;
+
+  uncomp_stream_.next_in = (Bytef*)source;
+  uncomp_stream_.avail_in = (uInt)*sourceLen;
+  // Check for source > 64K on 16-bit machine:
+  if ((uLong)uncomp_stream_.avail_in != *sourceLen) return Z_BUF_ERROR;
+
+  uncomp_stream_.next_out = dest;
+  uncomp_stream_.avail_out = (uInt)*destLen;
+  if ((uLong)uncomp_stream_.avail_out != *destLen) return Z_BUF_ERROR;
+
+  if ( !first_chunk_ )   // only need to set up stream the first time through
+    return Z_OK;
+
+  if (uncomp_init_) {    // we've already initted it
+    err = inflateReset(&uncomp_stream_);
+    if (err != Z_OK) {
+      LOG(WARNING)
+        << "ERROR: Can't reset uncompress object; creating a new one";
+      UncompressErrorInit();
+    }
+  }
+  if (!uncomp_init_) {
+    uncomp_stream_.zalloc = (alloc_func)0;
+    uncomp_stream_.zfree = (free_func)0;
+    uncomp_stream_.opaque = (voidpf)0;
+    err = InflateInit();
+    if (err != Z_OK) return err;
+    uncomp_init_ = true;
+  }
+  return Z_OK;
+}
+
+// If you compressed your data a chunk at a time, with CompressChunk,
+// you can uncompress it a chunk at a time with UncompressChunk.
+// Only difference bewteen chunked and unchunked uncompression
+// is the flush mode we use: Z_SYNC_FLUSH (chunked) or Z_FINISH (unchunked).
+int ZLib::UncompressAtMostOrAll(Bytef *dest, uLongf *destLen,
+                                const Bytef *source, uLong *sourceLen,
+                                int flush_mode) {  // Z_SYNC_FLUSH or Z_FINISH
+  int err = Z_OK;
+
+  if ( (err=UncompressInit(dest, destLen, source, sourceLen)) != Z_OK ) {
+    LOG(WARNING) << "UncompressInit: Error: " << err << " SourceLen: "
+                 << *sourceLen;
+    return err;
+  }
+
+  // This is used to figure out how many output bytes we wrote *this chunk*:
+  const uLong old_total_out = uncomp_stream_.total_out;
+
+  // This is used to figure out how many input bytes we read *this chunk*:
+  const uLong old_total_in = uncomp_stream_.total_in;
+
+  // Some setup happens only for the first chunk we compress in a run
+  if ( first_chunk_ ) {
+    first_chunk_ = false;                          // so we don't do this again
+
+    // For the first chunk *only* (to avoid infinite troubles), we let
+    // there be no actual data to uncompress.  This sometimes triggers
+    // when the input is only the gzip header, say.
+    if ( *sourceLen == 0 ) {
+      *destLen = 0;
+      return Z_OK;
+    }
+  }
+
+  // We'll uncompress as much as we can.  If we end OK great, otherwise
+  // if we get an error that seems to be the gzip footer, we store the
+  // gzip footer and return OK, otherwise we return the error.
+
+  // flush_mode is Z_SYNC_FLUSH for chunked mode, Z_FINISH for all mode.
+  err = inflate(&uncomp_stream_, flush_mode);
+
+  // Figure out how many bytes of the input zlib slurped up:
+  const uLong bytes_read = uncomp_stream_.total_in - old_total_in;
+  CHECK_LE(source + bytes_read, source + *sourceLen);
+  *sourceLen = uncomp_stream_.avail_in;
+
+  if ((err == Z_STREAM_END || err == Z_OK)  // everything went ok
+             && uncomp_stream_.avail_in == 0) {    // and we read it all
+    ;
+  } else if (err == Z_STREAM_END && uncomp_stream_.avail_in > 0) {
+    LOG(WARNING)
+      << "UncompressChunkOrAll: Received some extra data, bytes total: "
+      << uncomp_stream_.avail_in << " bytes: "
+      << string(reinterpret_cast<const char *>(uncomp_stream_.next_in),
+                min(int(uncomp_stream_.avail_in), 20));
+    UncompressErrorInit();
+    return Z_DATA_ERROR;       // what's the extra data for?
+  } else if (err != Z_OK && err != Z_STREAM_END && err != Z_BUF_ERROR) {
+    // an error happened
+    LOG(WARNING) << "UncompressChunkOrAll: Error: " << err
+                 << " avail_out: " << uncomp_stream_.avail_out;
+    UncompressErrorInit();
+    return err;
+  } else if (uncomp_stream_.avail_out == 0) {
+    err = Z_BUF_ERROR;
+  }
+
+  assert(err == Z_OK || err == Z_BUF_ERROR || err == Z_STREAM_END);
+  if (err == Z_STREAM_END)
+    err = Z_OK;
+
+  *destLen = uncomp_stream_.total_out - old_total_out;  // size for this call
+
+  return err;
+}
+
+int ZLib::UncompressChunkOrAll(Bytef *dest, uLongf *destLen,
+                               const Bytef *source, uLong sourceLen,
+                               int flush_mode) {  // Z_SYNC_FLUSH or Z_FINISH
+  const int ret =
+    UncompressAtMostOrAll(dest, destLen, source, &sourceLen, flush_mode);
+  if (ret == Z_BUF_ERROR)
+    UncompressErrorInit();
+  return ret;
+}
+
+int ZLib::UncompressAtMost(Bytef *dest, uLongf *destLen,
+                          const Bytef *source, uLong *sourceLen) {
+  return UncompressAtMostOrAll(dest, destLen, source, sourceLen, Z_SYNC_FLUSH);
+}
+
+// We make sure we've uncompressed everything, that is, the current
+// uncompress stream is at a compressed-buffer-EOF boundary.  In gzip
+// mode, we also check the gzip footer to make sure we pass the gzip
+// consistency checks.  We RETURN true iff both types of checks pass.
+bool ZLib::UncompressChunkDone() {
+  assert(!first_chunk_ && uncomp_init_);
+  // Make sure we're at the end-of-compressed-data point.  This means
+  // if we call inflate with Z_FINISH we won't consume any input or
+  // write any output
+  Bytef dummyin, dummyout;
+  uLongf dummylen = 0;
+  if ( UncompressChunkOrAll(&dummyout, &dummylen, &dummyin, 0, Z_FINISH)
+       != Z_OK ) {
+    return false;
+  }
+
+  // Make sure that when we exit, we can start a new round of chunks later
+  Reset();
+
+  return true;
+}
+
+// Uncompresses the source buffer into the destination buffer.
+// The destination buffer must be long enough to hold the entire
+// decompressed contents.
+//
+// We only initialize the uncomp_stream once.  Thereafter, we use
+// inflateReset, which should be faster.
+//
+// Returns Z_OK on success, otherwise, it returns a zlib error code.
+int ZLib::Uncompress(Bytef *dest, uLongf *destLen,
+                     const Bytef *source, uLong sourceLen) {
+  int err;
+  if ( (err=UncompressChunkOrAll(dest, destLen, source, sourceLen,
+                                 Z_FINISH)) != Z_OK ) {
+    Reset();                           // let us try to compress again
+    return err;
+  }
+  if ( !UncompressChunkDone() )        // calls Reset()
+    return Z_DATA_ERROR;
+  return Z_OK;  // stream_end is ok
+}
+
+#endif  // HAVE_LIBZ
+
+}  // namespace snappy
diff --git a/packages/Snappy.1.1.1.7/lib/native/src/snappy.cc b/packages/Snappy.1.1.1.7/lib/native/src/snappy.cc
new file mode 100644
index 0000000..5f66c13
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/src/snappy.cc
@@ -0,0 +1,1310 @@
+// Copyright 2005 Google Inc. All Rights Reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "snappy.h"
+#include "snappy-internal.h"
+#include "snappy-sinksource.h"
+
+#include <stdio.h>
+
+#include <algorithm>
+#include <string>
+#include <vector>
+
+
+namespace snappy {
+
+// Any hash function will produce a valid compressed bitstream, but a good
+// hash function reduces the number of collisions and thus yields better
+// compression for compressible input, and more speed for incompressible
+// input. Of course, it doesn't hurt if the hash function is reasonably fast
+// either, as it gets called a lot.
+static inline uint32 HashBytes(uint32 bytes, int shift) {
+  uint32 kMul = 0x1e35a7bd;
+  return (bytes * kMul) >> shift;
+}
+static inline uint32 Hash(const char* p, int shift) {
+  return HashBytes(UNALIGNED_LOAD32(p), shift);
+}
+
+size_t MaxCompressedLength(size_t source_len) {
+  // Compressed data can be defined as:
+  //    compressed := item* literal*
+  //    item       := literal* copy
+  //
+  // The trailing literal sequence has a space blowup of at most 62/60
+  // since a literal of length 60 needs one tag byte + one extra byte
+  // for length information.
+  //
+  // Item blowup is trickier to measure.  Suppose the "copy" op copies
+  // 4 bytes of data.  Because of a special check in the encoding code,
+  // we produce a 4-byte copy only if the offset is < 65536.  Therefore
+  // the copy op takes 3 bytes to encode, and this type of item leads
+  // to at most the 62/60 blowup for representing literals.
+  //
+  // Suppose the "copy" op copies 5 bytes of data.  If the offset is big
+  // enough, it will take 5 bytes to encode the copy op.  Therefore the
+  // worst case here is a one-byte literal followed by a five-byte copy.
+  // I.e., 6 bytes of input turn into 7 bytes of "compressed" data.
+  //
+  // This last factor dominates the blowup, so the final estimate is:
+  return 32 + source_len + source_len/6;
+}
+
+enum {
+  LITERAL = 0,
+  COPY_1_BYTE_OFFSET = 1,  // 3 bit length + 3 bits of offset in opcode
+  COPY_2_BYTE_OFFSET = 2,
+  COPY_4_BYTE_OFFSET = 3
+};
+static const int kMaximumTagLength = 5;  // COPY_4_BYTE_OFFSET plus the actual offset.
+
+// Copy "len" bytes from "src" to "op", one byte at a time.  Used for
+// handling COPY operations where the input and output regions may
+// overlap.  For example, suppose:
+//    src    == "ab"
+//    op     == src + 2
+//    len    == 20
+// After IncrementalCopy(src, op, len), the result will have
+// eleven copies of "ab"
+//    ababababababababababab
+// Note that this does not match the semantics of either memcpy()
+// or memmove().
+static inline void IncrementalCopy(const char* src, char* op, ssize_t len) {
+  assert(len > 0);
+  do {
+    *op++ = *src++;
+  } while (--len > 0);
+}
+
+// Equivalent to IncrementalCopy except that it can write up to ten extra
+// bytes after the end of the copy, and that it is faster.
+//
+// The main part of this loop is a simple copy of eight bytes at a time until
+// we've copied (at least) the requested amount of bytes.  However, if op and
+// src are less than eight bytes apart (indicating a repeating pattern of
+// length < 8), we first need to expand the pattern in order to get the correct
+// results. For instance, if the buffer looks like this, with the eight-byte
+// <src> and <op> patterns marked as intervals:
+//
+//    abxxxxxxxxxxxx
+//    [------]           src
+//      [------]         op
+//
+// a single eight-byte copy from <src> to <op> will repeat the pattern once,
+// after which we can move <op> two bytes without moving <src>:
+//
+//    ababxxxxxxxxxx
+//    [------]           src
+//        [------]       op
+//
+// and repeat the exercise until the two no longer overlap.
+//
+// This allows us to do very well in the special case of one single byte
+// repeated many times, without taking a big hit for more general cases.
+//
+// The worst case of extra writing past the end of the match occurs when
+// op - src == 1 and len == 1; the last copy will read from byte positions
+// [0..7] and write to [4..11], whereas it was only supposed to write to
+// position 1. Thus, ten excess bytes.
+
+namespace {
+
+const int kMaxIncrementCopyOverflow = 10;
+
+inline void IncrementalCopyFastPath(const char* src, char* op, ssize_t len) {
+  while (op - src < 8) {
+    UnalignedCopy64(src, op);
+    len -= op - src;
+    op += op - src;
+  }
+  while (len > 0) {
+    UnalignedCopy64(src, op);
+    src += 8;
+    op += 8;
+    len -= 8;
+  }
+}
+
+}  // namespace
+
+static inline char* EmitLiteral(char* op,
+                                const char* literal,
+                                int len,
+                                bool allow_fast_path) {
+  int n = len - 1;      // Zero-length literals are disallowed
+  if (n < 60) {
+    // Fits in tag byte
+    *op++ = LITERAL | (n << 2);
+
+    // The vast majority of copies are below 16 bytes, for which a
+    // call to memcpy is overkill. This fast path can sometimes
+    // copy up to 15 bytes too much, but that is okay in the
+    // main loop, since we have a bit to go on for both sides:
+    //
+    //   - The input will always have kInputMarginBytes = 15 extra
+    //     available bytes, as long as we're in the main loop, and
+    //     if not, allow_fast_path = false.
+    //   - The output will always have 32 spare bytes (see
+    //     MaxCompressedLength).
+    if (allow_fast_path && len <= 16) {
+      UnalignedCopy64(literal, op);
+      UnalignedCopy64(literal + 8, op + 8);
+      return op + len;
+    }
+  } else {
+    // Encode in upcoming bytes
+    char* base = op;
+    int count = 0;
+    op++;
+    while (n > 0) {
+      *op++ = n & 0xff;
+      n >>= 8;
+      count++;
+    }
+    assert(count >= 1);
+    assert(count <= 4);
+    *base = LITERAL | ((59+count) << 2);
+  }
+  memcpy(op, literal, len);
+  return op + len;
+}
+
+static inline char* EmitCopyLessThan64(char* op, size_t offset, int len) {
+  assert(len <= 64);
+  assert(len >= 4);
+  assert(offset < 65536);
+
+  if ((len < 12) && (offset < 2048)) {
+    size_t len_minus_4 = len - 4;
+    assert(len_minus_4 < 8);            // Must fit in 3 bits
+    *op++ = COPY_1_BYTE_OFFSET + ((len_minus_4) << 2) + ((offset >> 8) << 5);
+    *op++ = offset & 0xff;
+  } else {
+    *op++ = COPY_2_BYTE_OFFSET + ((len-1) << 2);
+    LittleEndian::Store16(op, offset);
+    op += 2;
+  }
+  return op;
+}
+
+static inline char* EmitCopy(char* op, size_t offset, int len) {
+  // Emit 64 byte copies but make sure to keep at least four bytes reserved
+  while (len >= 68) {
+    op = EmitCopyLessThan64(op, offset, 64);
+    len -= 64;
+  }
+
+  // Emit an extra 60 byte copy if have too much data to fit in one copy
+  if (len > 64) {
+    op = EmitCopyLessThan64(op, offset, 60);
+    len -= 60;
+  }
+
+  // Emit remainder
+  op = EmitCopyLessThan64(op, offset, len);
+  return op;
+}
+
+
+bool GetUncompressedLength(const char* start, size_t n, size_t* result) {
+  uint32 v = 0;
+  const char* limit = start + n;
+  if (Varint::Parse32WithLimit(start, limit, &v) != NULL) {
+    *result = v;
+    return true;
+  } else {
+    return false;
+  }
+}
+
+namespace internal {
+uint16* WorkingMemory::GetHashTable(size_t input_size, int* table_size) {
+  // Use smaller hash table when input.size() is smaller, since we
+  // fill the table, incurring O(hash table size) overhead for
+  // compression, and if the input is short, we won't need that
+  // many hash table entries anyway.
+  assert(kMaxHashTableSize >= 256);
+  size_t htsize = 256;
+  while (htsize < kMaxHashTableSize && htsize < input_size) {
+    htsize <<= 1;
+  }
+
+  uint16* table;
+  if (htsize <= ARRAYSIZE(small_table_)) {
+    table = small_table_;
+  } else {
+    if (large_table_ == NULL) {
+      large_table_ = new uint16[kMaxHashTableSize];
+    }
+    table = large_table_;
+  }
+
+  *table_size = htsize;
+  memset(table, 0, htsize * sizeof(*table));
+  return table;
+}
+}  // end namespace internal
+
+// For 0 <= offset <= 4, GetUint32AtOffset(GetEightBytesAt(p), offset) will
+// equal UNALIGNED_LOAD32(p + offset).  Motivation: On x86-64 hardware we have
+// empirically found that overlapping loads such as
+//  UNALIGNED_LOAD32(p) ... UNALIGNED_LOAD32(p+1) ... UNALIGNED_LOAD32(p+2)
+// are slower than UNALIGNED_LOAD64(p) followed by shifts and casts to uint32.
+//
+// We have different versions for 64- and 32-bit; ideally we would avoid the
+// two functions and just inline the UNALIGNED_LOAD64 call into
+// GetUint32AtOffset, but GCC (at least not as of 4.6) is seemingly not clever
+// enough to avoid loading the value multiple times then. For 64-bit, the load
+// is done when GetEightBytesAt() is called, whereas for 32-bit, the load is
+// done at GetUint32AtOffset() time.
+
+#ifdef ARCH_K8
+
+typedef uint64 EightBytesReference;
+
+static inline EightBytesReference GetEightBytesAt(const char* ptr) {
+  return UNALIGNED_LOAD64(ptr);
+}
+
+static inline uint32 GetUint32AtOffset(uint64 v, int offset) {
+  assert(offset >= 0);
+  assert(offset <= 4);
+  return v >> (LittleEndian::IsLittleEndian() ? 8 * offset : 32 - 8 * offset);
+}
+
+#else
+
+typedef const char* EightBytesReference;
+
+static inline EightBytesReference GetEightBytesAt(const char* ptr) {
+  return ptr;
+}
+
+static inline uint32 GetUint32AtOffset(const char* v, int offset) {
+  assert(offset >= 0);
+  assert(offset <= 4);
+  return UNALIGNED_LOAD32(v + offset);
+}
+
+#endif
+
+// Flat array compression that does not emit the "uncompressed length"
+// prefix. Compresses "input" string to the "*op" buffer.
+//
+// REQUIRES: "input" is at most "kBlockSize" bytes long.
+// REQUIRES: "op" points to an array of memory that is at least
+// "MaxCompressedLength(input.size())" in size.
+// REQUIRES: All elements in "table[0..table_size-1]" are initialized to zero.
+// REQUIRES: "table_size" is a power of two
+//
+// Returns an "end" pointer into "op" buffer.
+// "end - op" is the compressed size of "input".
+namespace internal {
+char* CompressFragment(const char* input,
+                       size_t input_size,
+                       char* op,
+                       uint16* table,
+                       const int table_size) {
+  // "ip" is the input pointer, and "op" is the output pointer.
+  const char* ip = input;
+  assert(input_size <= kBlockSize);
+  assert((table_size & (table_size - 1)) == 0); // table must be power of two
+  const int shift = 32 - Bits::Log2Floor(table_size);
+  assert(static_cast<int>(kuint32max >> shift) == table_size - 1);
+  const char* ip_end = input + input_size;
+  const char* base_ip = ip;
+  // Bytes in [next_emit, ip) will be emitted as literal bytes.  Or
+  // [next_emit, ip_end) after the main loop.
+  const char* next_emit = ip;
+
+  const size_t kInputMarginBytes = 15;
+  if (PREDICT_TRUE(input_size >= kInputMarginBytes)) {
+    const char* ip_limit = input + input_size - kInputMarginBytes;
+
+    for (uint32 next_hash = Hash(++ip, shift); ; ) {
+      assert(next_emit < ip);
+      // The body of this loop calls EmitLiteral once and then EmitCopy one or
+      // more times.  (The exception is that when we're close to exhausting
+      // the input we goto emit_remainder.)
+      //
+      // In the first iteration of this loop we're just starting, so
+      // there's nothing to copy, so calling EmitLiteral once is
+      // necessary.  And we only start a new iteration when the
+      // current iteration has determined that a call to EmitLiteral will
+      // precede the next call to EmitCopy (if any).
+      //
+      // Step 1: Scan forward in the input looking for a 4-byte-long match.
+      // If we get close to exhausting the input then goto emit_remainder.
+      //
+      // Heuristic match skipping: If 32 bytes are scanned with no matches
+      // found, start looking only at every other byte. If 32 more bytes are
+      // scanned, look at every third byte, etc.. When a match is found,
+      // immediately go back to looking at every byte. This is a small loss
+      // (~5% performance, ~0.1% density) for compressible data due to more
+      // bookkeeping, but for non-compressible data (such as JPEG) it's a huge
+      // win since the compressor quickly "realizes" the data is incompressible
+      // and doesn't bother looking for matches everywhere.
+      //
+      // The "skip" variable keeps track of how many bytes there are since the
+      // last match; dividing it by 32 (ie. right-shifting by five) gives the
+      // number of bytes to move ahead for each iteration.
+      uint32 skip = 32;
+
+      const char* next_ip = ip;
+      const char* candidate;
+      do {
+        ip = next_ip;
+        uint32 hash = next_hash;
+        assert(hash == Hash(ip, shift));
+        uint32 bytes_between_hash_lookups = skip++ >> 5;
+        next_ip = ip + bytes_between_hash_lookups;
+        if (PREDICT_FALSE(next_ip > ip_limit)) {
+          goto emit_remainder;
+        }
+        next_hash = Hash(next_ip, shift);
+        candidate = base_ip + table[hash];
+        assert(candidate >= base_ip);
+        assert(candidate < ip);
+
+        table[hash] = ip - base_ip;
+      } while (PREDICT_TRUE(UNALIGNED_LOAD32(ip) !=
+                            UNALIGNED_LOAD32(candidate)));
+
+      // Step 2: A 4-byte match has been found.  We'll later see if more
+      // than 4 bytes match.  But, prior to the match, input
+      // bytes [next_emit, ip) are unmatched.  Emit them as "literal bytes."
+      assert(next_emit + 16 <= ip_end);
+      op = EmitLiteral(op, next_emit, ip - next_emit, true);
+
+      // Step 3: Call EmitCopy, and then see if another EmitCopy could
+      // be our next move.  Repeat until we find no match for the
+      // input immediately after what was consumed by the last EmitCopy call.
+      //
+      // If we exit this loop normally then we need to call EmitLiteral next,
+      // though we don't yet know how big the literal will be.  We handle that
+      // by proceeding to the next iteration of the main loop.  We also can exit
+      // this loop via goto if we get close to exhausting the input.
+      EightBytesReference input_bytes;
+      uint32 candidate_bytes = 0;
+
+      do {
+        // We have a 4-byte match at ip, and no need to emit any
+        // "literal bytes" prior to ip.
+        const char* base = ip;
+        int matched = 4 + FindMatchLength(candidate + 4, ip + 4, ip_end);
+        ip += matched;
+        size_t offset = base - candidate;
+        assert(0 == memcmp(base, candidate, matched));
+        op = EmitCopy(op, offset, matched);
+        // We could immediately start working at ip now, but to improve
+        // compression we first update table[Hash(ip - 1, ...)].
+        const char* insert_tail = ip - 1;
+        next_emit = ip;
+        if (PREDICT_FALSE(ip >= ip_limit)) {
+          goto emit_remainder;
+        }
+        input_bytes = GetEightBytesAt(insert_tail);
+        uint32 prev_hash = HashBytes(GetUint32AtOffset(input_bytes, 0), shift);
+        table[prev_hash] = ip - base_ip - 1;
+        uint32 cur_hash = HashBytes(GetUint32AtOffset(input_bytes, 1), shift);
+        candidate = base_ip + table[cur_hash];
+        candidate_bytes = UNALIGNED_LOAD32(candidate);
+        table[cur_hash] = ip - base_ip;
+      } while (GetUint32AtOffset(input_bytes, 1) == candidate_bytes);
+
+      next_hash = HashBytes(GetUint32AtOffset(input_bytes, 2), shift);
+      ++ip;
+    }
+  }
+
+ emit_remainder:
+  // Emit the remaining bytes as a literal
+  if (next_emit < ip_end) {
+    op = EmitLiteral(op, next_emit, ip_end - next_emit, false);
+  }
+
+  return op;
+}
+}  // end namespace internal
+
+// Signature of output types needed by decompression code.
+// The decompression code is templatized on a type that obeys this
+// signature so that we do not pay virtual function call overhead in
+// the middle of a tight decompression loop.
+//
+// class DecompressionWriter {
+//  public:
+//   // Called before decompression
+//   void SetExpectedLength(size_t length);
+//
+//   // Called after decompression
+//   bool CheckLength() const;
+//
+//   // Called repeatedly during decompression
+//   bool Append(const char* ip, size_t length);
+//   bool AppendFromSelf(uint32 offset, size_t length);
+//
+//   // The rules for how TryFastAppend differs from Append are somewhat
+//   // convoluted:
+//   //
+//   //  - TryFastAppend is allowed to decline (return false) at any
+//   //    time, for any reason -- just "return false" would be
+//   //    a perfectly legal implementation of TryFastAppend.
+//   //    The intention is for TryFastAppend to allow a fast path
+//   //    in the common case of a small append.
+//   //  - TryFastAppend is allowed to read up to <available> bytes
+//   //    from the input buffer, whereas Append is allowed to read
+//   //    <length>. However, if it returns true, it must leave
+//   //    at least five (kMaximumTagLength) bytes in the input buffer
+//   //    afterwards, so that there is always enough space to read the
+//   //    next tag without checking for a refill.
+//   //  - TryFastAppend must always return decline (return false)
+//   //    if <length> is 61 or more, as in this case the literal length is not
+//   //    decoded fully. In practice, this should not be a big problem,
+//   //    as it is unlikely that one would implement a fast path accepting
+//   //    this much data.
+//   //
+//   bool TryFastAppend(const char* ip, size_t available, size_t length);
+// };
+
+// -----------------------------------------------------------------------
+// Lookup table for decompression code.  Generated by ComputeTable() below.
+// -----------------------------------------------------------------------
+
+// Mapping from i in range [0,4] to a mask to extract the bottom 8*i bits
+static const uint32 wordmask[] = {
+  0u, 0xffu, 0xffffu, 0xffffffu, 0xffffffffu
+};
+
+// Data stored per entry in lookup table:
+//      Range   Bits-used       Description
+//      ------------------------------------
+//      1..64   0..7            Literal/copy length encoded in opcode byte
+//      0..7    8..10           Copy offset encoded in opcode byte / 256
+//      0..4    11..13          Extra bytes after opcode
+//
+// We use eight bits for the length even though 7 would have sufficed
+// because of efficiency reasons:
+//      (1) Extracting a byte is faster than a bit-field
+//      (2) It properly aligns copy offset so we do not need a <<8
+static const uint16 char_table[256] = {
+  0x0001, 0x0804, 0x1001, 0x2001, 0x0002, 0x0805, 0x1002, 0x2002,
+  0x0003, 0x0806, 0x1003, 0x2003, 0x0004, 0x0807, 0x1004, 0x2004,
+  0x0005, 0x0808, 0x1005, 0x2005, 0x0006, 0x0809, 0x1006, 0x2006,
+  0x0007, 0x080a, 0x1007, 0x2007, 0x0008, 0x080b, 0x1008, 0x2008,
+  0x0009, 0x0904, 0x1009, 0x2009, 0x000a, 0x0905, 0x100a, 0x200a,
+  0x000b, 0x0906, 0x100b, 0x200b, 0x000c, 0x0907, 0x100c, 0x200c,
+  0x000d, 0x0908, 0x100d, 0x200d, 0x000e, 0x0909, 0x100e, 0x200e,
+  0x000f, 0x090a, 0x100f, 0x200f, 0x0010, 0x090b, 0x1010, 0x2010,
+  0x0011, 0x0a04, 0x1011, 0x2011, 0x0012, 0x0a05, 0x1012, 0x2012,
+  0x0013, 0x0a06, 0x1013, 0x2013, 0x0014, 0x0a07, 0x1014, 0x2014,
+  0x0015, 0x0a08, 0x1015, 0x2015, 0x0016, 0x0a09, 0x1016, 0x2016,
+  0x0017, 0x0a0a, 0x1017, 0x2017, 0x0018, 0x0a0b, 0x1018, 0x2018,
+  0x0019, 0x0b04, 0x1019, 0x2019, 0x001a, 0x0b05, 0x101a, 0x201a,
+  0x001b, 0x0b06, 0x101b, 0x201b, 0x001c, 0x0b07, 0x101c, 0x201c,
+  0x001d, 0x0b08, 0x101d, 0x201d, 0x001e, 0x0b09, 0x101e, 0x201e,
+  0x001f, 0x0b0a, 0x101f, 0x201f, 0x0020, 0x0b0b, 0x1020, 0x2020,
+  0x0021, 0x0c04, 0x1021, 0x2021, 0x0022, 0x0c05, 0x1022, 0x2022,
+  0x0023, 0x0c06, 0x1023, 0x2023, 0x0024, 0x0c07, 0x1024, 0x2024,
+  0x0025, 0x0c08, 0x1025, 0x2025, 0x0026, 0x0c09, 0x1026, 0x2026,
+  0x0027, 0x0c0a, 0x1027, 0x2027, 0x0028, 0x0c0b, 0x1028, 0x2028,
+  0x0029, 0x0d04, 0x1029, 0x2029, 0x002a, 0x0d05, 0x102a, 0x202a,
+  0x002b, 0x0d06, 0x102b, 0x202b, 0x002c, 0x0d07, 0x102c, 0x202c,
+  0x002d, 0x0d08, 0x102d, 0x202d, 0x002e, 0x0d09, 0x102e, 0x202e,
+  0x002f, 0x0d0a, 0x102f, 0x202f, 0x0030, 0x0d0b, 0x1030, 0x2030,
+  0x0031, 0x0e04, 0x1031, 0x2031, 0x0032, 0x0e05, 0x1032, 0x2032,
+  0x0033, 0x0e06, 0x1033, 0x2033, 0x0034, 0x0e07, 0x1034, 0x2034,
+  0x0035, 0x0e08, 0x1035, 0x2035, 0x0036, 0x0e09, 0x1036, 0x2036,
+  0x0037, 0x0e0a, 0x1037, 0x2037, 0x0038, 0x0e0b, 0x1038, 0x2038,
+  0x0039, 0x0f04, 0x1039, 0x2039, 0x003a, 0x0f05, 0x103a, 0x203a,
+  0x003b, 0x0f06, 0x103b, 0x203b, 0x003c, 0x0f07, 0x103c, 0x203c,
+  0x0801, 0x0f08, 0x103d, 0x203d, 0x1001, 0x0f09, 0x103e, 0x203e,
+  0x1801, 0x0f0a, 0x103f, 0x203f, 0x2001, 0x0f0b, 0x1040, 0x2040
+};
+
+// In debug mode, allow optional computation of the table at startup.
+// Also, check that the decompression table is correct.
+#ifndef NDEBUG
+DEFINE_bool(snappy_dump_decompression_table, false,
+            "If true, we print the decompression table at startup.");
+
+static uint16 MakeEntry(unsigned int extra,
+                        unsigned int len,
+                        unsigned int copy_offset) {
+  // Check that all of the fields fit within the allocated space
+  assert(extra       == (extra & 0x7));          // At most 3 bits
+  assert(copy_offset == (copy_offset & 0x7));    // At most 3 bits
+  assert(len         == (len & 0x7f));           // At most 7 bits
+  return len | (copy_offset << 8) | (extra << 11);
+}
+
+static void ComputeTable() {
+  uint16 dst[256];
+
+  // Place invalid entries in all places to detect missing initialization
+  int assigned = 0;
+  for (int i = 0; i < 256; i++) {
+    dst[i] = 0xffff;
+  }
+
+  // Small LITERAL entries.  We store (len-1) in the top 6 bits.
+  for (unsigned int len = 1; len <= 60; len++) {
+    dst[LITERAL | ((len-1) << 2)] = MakeEntry(0, len, 0);
+    assigned++;
+  }
+
+  // Large LITERAL entries.  We use 60..63 in the high 6 bits to
+  // encode the number of bytes of length info that follow the opcode.
+  for (unsigned int extra_bytes = 1; extra_bytes <= 4; extra_bytes++) {
+    // We set the length field in the lookup table to 1 because extra
+    // bytes encode len-1.
+    dst[LITERAL | ((extra_bytes+59) << 2)] = MakeEntry(extra_bytes, 1, 0);
+    assigned++;
+  }
+
+  // COPY_1_BYTE_OFFSET.
+  //
+  // The tag byte in the compressed data stores len-4 in 3 bits, and
+  // offset/256 in 5 bits.  offset%256 is stored in the next byte.
+  //
+  // This format is used for length in range [4..11] and offset in
+  // range [0..2047]
+  for (unsigned int len = 4; len < 12; len++) {
+    for (unsigned int offset = 0; offset < 2048; offset += 256) {
+      dst[COPY_1_BYTE_OFFSET | ((len-4)<<2) | ((offset>>8)<<5)] =
+        MakeEntry(1, len, offset>>8);
+      assigned++;
+    }
+  }
+
+  // COPY_2_BYTE_OFFSET.
+  // Tag contains len-1 in top 6 bits, and offset in next two bytes.
+  for (unsigned int len = 1; len <= 64; len++) {
+    dst[COPY_2_BYTE_OFFSET | ((len-1)<<2)] = MakeEntry(2, len, 0);
+    assigned++;
+  }
+
+  // COPY_4_BYTE_OFFSET.
+  // Tag contents len-1 in top 6 bits, and offset in next four bytes.
+  for (unsigned int len = 1; len <= 64; len++) {
+    dst[COPY_4_BYTE_OFFSET | ((len-1)<<2)] = MakeEntry(4, len, 0);
+    assigned++;
+  }
+
+  // Check that each entry was initialized exactly once.
+  if (assigned != 256) {
+    fprintf(stderr, "ComputeTable: assigned only %d of 256\n", assigned);
+    abort();
+  }
+  for (int i = 0; i < 256; i++) {
+    if (dst[i] == 0xffff) {
+      fprintf(stderr, "ComputeTable: did not assign byte %d\n", i);
+      abort();
+    }
+  }
+
+  if (FLAGS_snappy_dump_decompression_table) {
+    printf("static const uint16 char_table[256] = {\n  ");
+    for (int i = 0; i < 256; i++) {
+      printf("0x%04x%s",
+             dst[i],
+             ((i == 255) ? "\n" : (((i%8) == 7) ? ",\n  " : ", ")));
+    }
+    printf("};\n");
+  }
+
+  // Check that computed table matched recorded table
+  for (int i = 0; i < 256; i++) {
+    if (dst[i] != char_table[i]) {
+      fprintf(stderr, "ComputeTable: byte %d: computed (%x), expect (%x)\n",
+              i, static_cast<int>(dst[i]), static_cast<int>(char_table[i]));
+      abort();
+    }
+  }
+}
+#endif /* !NDEBUG */
+
+// Helper class for decompression
+class SnappyDecompressor {
+ private:
+  Source*       reader_;         // Underlying source of bytes to decompress
+  const char*   ip_;             // Points to next buffered byte
+  const char*   ip_limit_;       // Points just past buffered bytes
+  uint32        peeked_;         // Bytes peeked from reader (need to skip)
+  bool          eof_;            // Hit end of input without an error?
+  char          scratch_[kMaximumTagLength];  // See RefillTag().
+
+  // Ensure that all of the tag metadata for the next tag is available
+  // in [ip_..ip_limit_-1].  Also ensures that [ip,ip+4] is readable even
+  // if (ip_limit_ - ip_ < 5).
+  //
+  // Returns true on success, false on error or end of input.
+  bool RefillTag();
+
+ public:
+  explicit SnappyDecompressor(Source* reader)
+      : reader_(reader),
+        ip_(NULL),
+        ip_limit_(NULL),
+        peeked_(0),
+        eof_(false) {
+  }
+
+  ~SnappyDecompressor() {
+    // Advance past any bytes we peeked at from the reader
+    reader_->Skip(peeked_);
+  }
+
+  // Returns true iff we have hit the end of the input without an error.
+  bool eof() const {
+    return eof_;
+  }
+
+  // Read the uncompressed length stored at the start of the compressed data.
+  // On succcess, stores the length in *result and returns true.
+  // On failure, returns false.
+  bool ReadUncompressedLength(uint32* result) {
+    assert(ip_ == NULL);       // Must not have read anything yet
+    // Length is encoded in 1..5 bytes
+    *result = 0;
+    uint32 shift = 0;
+    while (true) {
+      if (shift >= 32) return false;
+      size_t n;
+      const char* ip = reader_->Peek(&n);
+      if (n == 0) return false;
+      const unsigned char c = *(reinterpret_cast<const unsigned char*>(ip));
+      reader_->Skip(1);
+      *result |= static_cast<uint32>(c & 0x7f) << shift;
+      if (c < 128) {
+        break;
+      }
+      shift += 7;
+    }
+    return true;
+  }
+
+  // Process the next item found in the input.
+  // Returns true if successful, false on error or end of input.
+  template <class Writer>
+  void DecompressAllTags(Writer* writer) {
+    const char* ip = ip_;
+
+    // We could have put this refill fragment only at the beginning of the loop.
+    // However, duplicating it at the end of each branch gives the compiler more
+    // scope to optimize the <ip_limit_ - ip> expression based on the local
+    // context, which overall increases speed.
+    #define MAYBE_REFILL() \
+        if (ip_limit_ - ip < kMaximumTagLength) { \
+          ip_ = ip; \
+          if (!RefillTag()) return; \
+          ip = ip_; \
+        }
+
+    MAYBE_REFILL();
+    for ( ;; ) {
+      const unsigned char c = *(reinterpret_cast<const unsigned char*>(ip++));
+
+      if ((c & 0x3) == LITERAL) {
+        size_t literal_length = (c >> 2) + 1u;
+        if (writer->TryFastAppend(ip, ip_limit_ - ip, literal_length)) {
+          assert(literal_length < 61);
+          ip += literal_length;
+          // NOTE(user): There is no MAYBE_REFILL() here, as TryFastAppend()
+          // will not return true unless there's already at least five spare
+          // bytes in addition to the literal.
+          continue;
+        }
+        if (PREDICT_FALSE(literal_length >= 61)) {
+          // Long literal.
+          const size_t literal_length_length = literal_length - 60;
+          literal_length =
+              (LittleEndian::Load32(ip) & wordmask[literal_length_length]) + 1;
+          ip += literal_length_length;
+        }
+
+        size_t avail = ip_limit_ - ip;
+        while (avail < literal_length) {
+          if (!writer->Append(ip, avail)) return;
+          literal_length -= avail;
+          reader_->Skip(peeked_);
+          size_t n;
+          ip = reader_->Peek(&n);
+          avail = n;
+          peeked_ = avail;
+          if (avail == 0) return;  // Premature end of input
+          ip_limit_ = ip + avail;
+        }
+        if (!writer->Append(ip, literal_length)) {
+          return;
+        }
+        ip += literal_length;
+        MAYBE_REFILL();
+      } else {
+        const uint32 entry = char_table[c];
+        const uint32 trailer = LittleEndian::Load32(ip) & wordmask[entry >> 11];
+        const uint32 length = entry & 0xff;
+        ip += entry >> 11;
+
+        // copy_offset/256 is encoded in bits 8..10.  By just fetching
+        // those bits, we get copy_offset (since the bit-field starts at
+        // bit 8).
+        const uint32 copy_offset = entry & 0x700;
+        if (!writer->AppendFromSelf(copy_offset + trailer, length)) {
+          return;
+        }
+        MAYBE_REFILL();
+      }
+    }
+
+#undef MAYBE_REFILL
+  }
+};
+
+bool SnappyDecompressor::RefillTag() {
+  const char* ip = ip_;
+  if (ip == ip_limit_) {
+    // Fetch a new fragment from the reader
+    reader_->Skip(peeked_);   // All peeked bytes are used up
+    size_t n;
+    ip = reader_->Peek(&n);
+    peeked_ = n;
+    if (n == 0) {
+      eof_ = true;
+      return false;
+    }
+    ip_limit_ = ip + n;
+  }
+
+  // Read the tag character
+  assert(ip < ip_limit_);
+  const unsigned char c = *(reinterpret_cast<const unsigned char*>(ip));
+  const uint32 entry = char_table[c];
+  const uint32 needed = (entry >> 11) + 1;  // +1 byte for 'c'
+  assert(needed <= sizeof(scratch_));
+
+  // Read more bytes from reader if needed
+  uint32 nbuf = ip_limit_ - ip;
+  if (nbuf < needed) {
+    // Stitch together bytes from ip and reader to form the word
+    // contents.  We store the needed bytes in "scratch_".  They
+    // will be consumed immediately by the caller since we do not
+    // read more than we need.
+    memmove(scratch_, ip, nbuf);
+    reader_->Skip(peeked_);  // All peeked bytes are used up
+    peeked_ = 0;
+    while (nbuf < needed) {
+      size_t length;
+      const char* src = reader_->Peek(&length);
+      if (length == 0) return false;
+      uint32 to_add = min<uint32>(needed - nbuf, length);
+      memcpy(scratch_ + nbuf, src, to_add);
+      nbuf += to_add;
+      reader_->Skip(to_add);
+    }
+    assert(nbuf == needed);
+    ip_ = scratch_;
+    ip_limit_ = scratch_ + needed;
+  } else if (nbuf < kMaximumTagLength) {
+    // Have enough bytes, but move into scratch_ so that we do not
+    // read past end of input
+    memmove(scratch_, ip, nbuf);
+    reader_->Skip(peeked_);  // All peeked bytes are used up
+    peeked_ = 0;
+    ip_ = scratch_;
+    ip_limit_ = scratch_ + nbuf;
+  } else {
+    // Pass pointer to buffer returned by reader_.
+    ip_ = ip;
+  }
+  return true;
+}
+
+template <typename Writer>
+static bool InternalUncompress(Source* r, Writer* writer) {
+  // Read the uncompressed length from the front of the compressed input
+  SnappyDecompressor decompressor(r);
+  uint32 uncompressed_len = 0;
+  if (!decompressor.ReadUncompressedLength(&uncompressed_len)) return false;
+  return InternalUncompressAllTags(&decompressor, writer, uncompressed_len);
+}
+
+template <typename Writer>
+static bool InternalUncompressAllTags(SnappyDecompressor* decompressor,
+                                      Writer* writer,
+                                      uint32 uncompressed_len) {
+  writer->SetExpectedLength(uncompressed_len);
+
+  // Process the entire input
+  decompressor->DecompressAllTags(writer);
+  return (decompressor->eof() && writer->CheckLength());
+}
+
+bool GetUncompressedLength(Source* source, uint32* result) {
+  SnappyDecompressor decompressor(source);
+  return decompressor.ReadUncompressedLength(result);
+}
+
+size_t Compress(Source* reader, Sink* writer) {
+  size_t written = 0;
+  size_t N = reader->Available();
+  char ulength[Varint::kMax32];
+  char* p = Varint::Encode32(ulength, N);
+  writer->Append(ulength, p-ulength);
+  written += (p - ulength);
+
+  internal::WorkingMemory wmem;
+  char* scratch = NULL;
+  char* scratch_output = NULL;
+
+  while (N > 0) {
+    // Get next block to compress (without copying if possible)
+    size_t fragment_size;
+    const char* fragment = reader->Peek(&fragment_size);
+    assert(fragment_size != 0);  // premature end of input
+    const size_t num_to_read = min(N, kBlockSize);
+    size_t bytes_read = fragment_size;
+
+    size_t pending_advance = 0;
+    if (bytes_read >= num_to_read) {
+      // Buffer returned by reader is large enough
+      pending_advance = num_to_read;
+      fragment_size = num_to_read;
+    } else {
+      // Read into scratch buffer
+      if (scratch == NULL) {
+        // If this is the last iteration, we want to allocate N bytes
+        // of space, otherwise the max possible kBlockSize space.
+        // num_to_read contains exactly the correct value
+        scratch = new char[num_to_read];
+      }
+      memcpy(scratch, fragment, bytes_read);
+      reader->Skip(bytes_read);
+
+      while (bytes_read < num_to_read) {
+        fragment = reader->Peek(&fragment_size);
+        size_t n = min<size_t>(fragment_size, num_to_read - bytes_read);
+        memcpy(scratch + bytes_read, fragment, n);
+        bytes_read += n;
+        reader->Skip(n);
+      }
+      assert(bytes_read == num_to_read);
+      fragment = scratch;
+      fragment_size = num_to_read;
+    }
+    assert(fragment_size == num_to_read);
+
+    // Get encoding table for compression
+    int table_size;
+    uint16* table = wmem.GetHashTable(num_to_read, &table_size);
+
+    // Compress input_fragment and append to dest
+    const int max_output = MaxCompressedLength(num_to_read);
+
+    // Need a scratch buffer for the output, in case the byte sink doesn't
+    // have room for us directly.
+    if (scratch_output == NULL) {
+      scratch_output = new char[max_output];
+    } else {
+      // Since we encode kBlockSize regions followed by a region
+      // which is <= kBlockSize in length, a previously allocated
+      // scratch_output[] region is big enough for this iteration.
+    }
+    char* dest = writer->GetAppendBuffer(max_output, scratch_output);
+    char* end = internal::CompressFragment(fragment, fragment_size,
+                                           dest, table, table_size);
+    writer->Append(dest, end - dest);
+    written += (end - dest);
+
+    N -= num_to_read;
+    reader->Skip(pending_advance);
+  }
+
+  delete[] scratch;
+  delete[] scratch_output;
+
+  return written;
+}
+
+#ifndef WIN32
+
+// -----------------------------------------------------------------------
+// IOVec interfaces
+// -----------------------------------------------------------------------
+
+// A type that writes to an iovec.
+// Note that this is not a "ByteSink", but a type that matches the
+// Writer template argument to SnappyDecompressor::DecompressAllTags().
+class SnappyIOVecWriter {
+ private:
+  const struct iovec* output_iov_;
+  const size_t output_iov_count_;
+
+  // We are currently writing into output_iov_[curr_iov_index_].
+  int curr_iov_index_;
+
+  // Bytes written to output_iov_[curr_iov_index_] so far.
+  size_t curr_iov_written_;
+
+  // Total bytes decompressed into output_iov_ so far.
+  size_t total_written_;
+
+  // Maximum number of bytes that will be decompressed into output_iov_.
+  size_t output_limit_;
+
+  inline char* GetIOVecPointer(int index, size_t offset) {
+    return reinterpret_cast<char*>(output_iov_[index].iov_base) +
+        offset;
+  }
+
+ public:
+  // Does not take ownership of iov. iov must be valid during the
+  // entire lifetime of the SnappyIOVecWriter.
+  inline SnappyIOVecWriter(const struct iovec* iov, size_t iov_count)
+      : output_iov_(iov),
+        output_iov_count_(iov_count),
+        curr_iov_index_(0),
+        curr_iov_written_(0),
+        total_written_(0),
+        output_limit_(-1) {
+  }
+
+  inline void SetExpectedLength(size_t len) {
+    output_limit_ = len;
+  }
+
+  inline bool CheckLength() const {
+    return total_written_ == output_limit_;
+  }
+
+  inline bool Append(const char* ip, size_t len) {
+    if (total_written_ + len > output_limit_) {
+      return false;
+    }
+
+    while (len > 0) {
+      assert(curr_iov_written_ <= output_iov_[curr_iov_index_].iov_len);
+      if (curr_iov_written_ >= output_iov_[curr_iov_index_].iov_len) {
+        // This iovec is full. Go to the next one.
+        if (curr_iov_index_ + 1 >= output_iov_count_) {
+          return false;
+        }
+        curr_iov_written_ = 0;
+        ++curr_iov_index_;
+      }
+
+      const size_t to_write = std::min(
+          len, output_iov_[curr_iov_index_].iov_len - curr_iov_written_);
+      memcpy(GetIOVecPointer(curr_iov_index_, curr_iov_written_),
+             ip,
+             to_write);
+      curr_iov_written_ += to_write;
+      total_written_ += to_write;
+      ip += to_write;
+      len -= to_write;
+    }
+
+    return true;
+  }
+
+  inline bool TryFastAppend(const char* ip, size_t available, size_t len) {
+    const size_t space_left = output_limit_ - total_written_;
+    if (len <= 16 && available >= 16 + kMaximumTagLength && space_left >= 16 &&
+        output_iov_[curr_iov_index_].iov_len - curr_iov_written_ >= 16) {
+      // Fast path, used for the majority (about 95%) of invocations.
+      char* ptr = GetIOVecPointer(curr_iov_index_, curr_iov_written_);
+      UnalignedCopy64(ip, ptr);
+      UnalignedCopy64(ip + 8, ptr + 8);
+      curr_iov_written_ += len;
+      total_written_ += len;
+      return true;
+    }
+
+    return false;
+  }
+
+  inline bool AppendFromSelf(size_t offset, size_t len) {
+    if (offset > total_written_ || offset == 0) {
+      return false;
+    }
+    const size_t space_left = output_limit_ - total_written_;
+    if (len > space_left) {
+      return false;
+    }
+
+    // Locate the iovec from which we need to start the copy.
+    int from_iov_index = curr_iov_index_;
+    size_t from_iov_offset = curr_iov_written_;
+    while (offset > 0) {
+      if (from_iov_offset >= offset) {
+        from_iov_offset -= offset;
+        break;
+      }
+
+      offset -= from_iov_offset;
+      --from_iov_index;
+      assert(from_iov_index >= 0);
+      from_iov_offset = output_iov_[from_iov_index].iov_len;
+    }
+
+    // Copy <len> bytes starting from the iovec pointed to by from_iov_index to
+    // the current iovec.
+    while (len > 0) {
+      assert(from_iov_index <= curr_iov_index_);
+      if (from_iov_index != curr_iov_index_) {
+        const size_t to_copy = std::min(
+            output_iov_[from_iov_index].iov_len - from_iov_offset,
+            len);
+        Append(GetIOVecPointer(from_iov_index, from_iov_offset), to_copy);
+        len -= to_copy;
+        if (len > 0) {
+          ++from_iov_index;
+          from_iov_offset = 0;
+        }
+      } else {
+        assert(curr_iov_written_ <= output_iov_[curr_iov_index_].iov_len);
+        size_t to_copy = std::min(output_iov_[curr_iov_index_].iov_len -
+                                      curr_iov_written_,
+                                  len);
+        if (to_copy == 0) {
+          // This iovec is full. Go to the next one.
+          if (curr_iov_index_ + 1 >= output_iov_count_) {
+            return false;
+          }
+          ++curr_iov_index_;
+          curr_iov_written_ = 0;
+          continue;
+        }
+        if (to_copy > len) {
+          to_copy = len;
+        }
+        IncrementalCopy(GetIOVecPointer(from_iov_index, from_iov_offset),
+                        GetIOVecPointer(curr_iov_index_, curr_iov_written_),
+                        to_copy);
+        curr_iov_written_ += to_copy;
+        from_iov_offset += to_copy;
+        total_written_ += to_copy;
+        len -= to_copy;
+      }
+    }
+
+    return true;
+  }
+
+};
+
+bool RawUncompressToIOVec(const char* compressed, size_t compressed_length,
+                          const struct iovec* iov, size_t iov_cnt) {
+  ByteArraySource reader(compressed, compressed_length);
+  return RawUncompressToIOVec(&reader, iov, iov_cnt);
+}
+
+bool RawUncompressToIOVec(Source* compressed, const struct iovec* iov,
+                          size_t iov_cnt) {
+  SnappyIOVecWriter output(iov, iov_cnt);
+  return InternalUncompress(compressed, &output);
+}
+
+#endif
+
+// -----------------------------------------------------------------------
+// Flat array interfaces
+// -----------------------------------------------------------------------
+
+// A type that writes to a flat array.
+// Note that this is not a "ByteSink", but a type that matches the
+// Writer template argument to SnappyDecompressor::DecompressAllTags().
+class SnappyArrayWriter {
+ private:
+  char* base_;
+  char* op_;
+  char* op_limit_;
+
+ public:
+  inline explicit SnappyArrayWriter(char* dst)
+      : base_(dst),
+        op_(dst) {
+  }
+
+  inline void SetExpectedLength(size_t len) {
+    op_limit_ = op_ + len;
+  }
+
+  inline bool CheckLength() const {
+    return op_ == op_limit_;
+  }
+
+  inline bool Append(const char* ip, size_t len) {
+    char* op = op_;
+    const size_t space_left = op_limit_ - op;
+    if (space_left < len) {
+      return false;
+    }
+    memcpy(op, ip, len);
+    op_ = op + len;
+    return true;
+  }
+
+  inline bool TryFastAppend(const char* ip, size_t available, size_t len) {
+    char* op = op_;
+    const size_t space_left = op_limit_ - op;
+    if (len <= 16 && available >= 16 + kMaximumTagLength && space_left >= 16) {
+      // Fast path, used for the majority (about 95%) of invocations.
+      UnalignedCopy64(ip, op);
+      UnalignedCopy64(ip + 8, op + 8);
+      op_ = op + len;
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  inline bool AppendFromSelf(size_t offset, size_t len) {
+    char* op = op_;
+    const size_t space_left = op_limit_ - op;
+
+    // Check if we try to append from before the start of the buffer.
+    // Normally this would just be a check for "produced < offset",
+    // but "produced <= offset - 1u" is equivalent for every case
+    // except the one where offset==0, where the right side will wrap around
+    // to a very big number. This is convenient, as offset==0 is another
+    // invalid case that we also want to catch, so that we do not go
+    // into an infinite loop.
+    assert(op >= base_);
+    size_t produced = op - base_;
+    if (produced <= offset - 1u) {
+      return false;
+    }
+    if (len <= 16 && offset >= 8 && space_left >= 16) {
+      // Fast path, used for the majority (70-80%) of dynamic invocations.
+      UnalignedCopy64(op - offset, op);
+      UnalignedCopy64(op - offset + 8, op + 8);
+    } else {
+      if (space_left >= len + kMaxIncrementCopyOverflow) {
+        IncrementalCopyFastPath(op - offset, op, len);
+      } else {
+        if (space_left < len) {
+          return false;
+        }
+        IncrementalCopy(op - offset, op, len);
+      }
+    }
+
+    op_ = op + len;
+    return true;
+  }
+};
+
+bool RawUncompress(const char* compressed, size_t n, char* uncompressed) {
+  ByteArraySource reader(compressed, n);
+  return RawUncompress(&reader, uncompressed);
+}
+
+bool RawUncompress(Source* compressed, char* uncompressed) {
+  SnappyArrayWriter output(uncompressed);
+  return InternalUncompress(compressed, &output);
+}
+
+bool Uncompress(const char* compressed, size_t n, string* uncompressed) {
+  size_t ulength;
+  if (!GetUncompressedLength(compressed, n, &ulength)) {
+    return false;
+  }
+  // On 32-bit builds: max_size() < kuint32max.  Check for that instead
+  // of crashing (e.g., consider externally specified compressed data).
+  if (ulength > uncompressed->max_size()) {
+    return false;
+  }
+  STLStringResizeUninitialized(uncompressed, ulength);
+  return RawUncompress(compressed, n, string_as_array(uncompressed));
+}
+
+
+// A Writer that drops everything on the floor and just does validation
+class SnappyDecompressionValidator {
+ private:
+  size_t expected_;
+  size_t produced_;
+
+ public:
+  inline SnappyDecompressionValidator() : produced_(0) { }
+  inline void SetExpectedLength(size_t len) {
+    expected_ = len;
+  }
+  inline bool CheckLength() const {
+    return expected_ == produced_;
+  }
+  inline bool Append(const char* ip, size_t len) {
+    produced_ += len;
+    return produced_ <= expected_;
+  }
+  inline bool TryFastAppend(const char* ip, size_t available, size_t length) {
+    return false;
+  }
+  inline bool AppendFromSelf(size_t offset, size_t len) {
+    // See SnappyArrayWriter::AppendFromSelf for an explanation of
+    // the "offset - 1u" trick.
+    if (produced_ <= offset - 1u) return false;
+    produced_ += len;
+    return produced_ <= expected_;
+  }
+};
+
+bool IsValidCompressedBuffer(const char* compressed, size_t n) {
+  ByteArraySource reader(compressed, n);
+  SnappyDecompressionValidator writer;
+  return InternalUncompress(&reader, &writer);
+}
+
+void RawCompress(const char* input,
+                 size_t input_length,
+                 char* compressed,
+                 size_t* compressed_length) {
+  ByteArraySource reader(input, input_length);
+  UncheckedByteArraySink writer(compressed);
+  Compress(&reader, &writer);
+
+  // Compute how many bytes were added
+  *compressed_length = (writer.CurrentDestination() - compressed);
+}
+
+size_t Compress(const char* input, size_t input_length, string* compressed) {
+  // Pre-grow the buffer to the max length of the compressed output
+  compressed->resize(MaxCompressedLength(input_length));
+
+  size_t compressed_length;
+  RawCompress(input, input_length, string_as_array(compressed),
+              &compressed_length);
+  compressed->resize(compressed_length);
+  return compressed_length;
+}
+
+
+} // end namespace snappy
+
diff --git a/packages/Snappy.1.1.1.7/lib/native/src/snappy_unittest.cc b/packages/Snappy.1.1.1.7/lib/native/src/snappy_unittest.cc
new file mode 100644
index 0000000..d6f10ea
--- /dev/null
+++ b/packages/Snappy.1.1.1.7/lib/native/src/snappy_unittest.cc
@@ -0,0 +1,1371 @@
+// Copyright 2005 and onwards Google Inc.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include <math.h>
+#include <stdlib.h>
+
+
+#include <algorithm>
+#include <string>
+#include <vector>
+
+#include "snappy.h"
+#include "snappy-internal.h"
+#include "snappy-test.h"
+#include "snappy-sinksource.h"
+
+DEFINE_int32(start_len, -1,
+             "Starting prefix size for testing (-1: just full file contents)");
+DEFINE_int32(end_len, -1,
+             "Starting prefix size for testing (-1: just full file contents)");
+DEFINE_int32(bytes, 10485760,
+             "How many bytes to compress/uncompress per file for timing");
+
+DEFINE_bool(zlib, false,
+            "Run zlib compression (http://www.zlib.net)");
+DEFINE_bool(lzo, false,
+            "Run LZO compression (http://www.oberhumer.com/opensource/lzo/)");
+DEFINE_bool(quicklz, false,
+            "Run quickLZ compression (http://www.quicklz.com/)");
+DEFINE_bool(liblzf, false,
+            "Run libLZF compression "
+            "(http://www.goof.com/pcg/marc/liblzf.html)");
+DEFINE_bool(fastlz, false,
+            "Run FastLZ compression (http://www.fastlz.org/");
+DEFINE_bool(snappy, true, "Run snappy compression");
+
+
+DEFINE_bool(write_compressed, false,
+            "Write compressed versions of each file to <file>.comp");
+DEFINE_bool(write_uncompressed, false,
+            "Write uncompressed versions of each file to <file>.uncomp");
+
+namespace snappy {
+
+
+#ifdef HAVE_FUNC_MMAP
+
+// To test against code that reads beyond its input, this class copies a
+// string to a newly allocated group of pages, the last of which
+// is made unreadable via mprotect. Note that we need to allocate the
+// memory with mmap(), as POSIX allows mprotect() only on memory allocated
+// with mmap(), and some malloc/posix_memalign implementations expect to
+// be able to read previously allocated memory while doing heap allocations.
+class DataEndingAtUnreadablePage {
+ public:
+  explicit DataEndingAtUnreadablePage(const string& s) {
+    const size_t page_size = getpagesize();
+    const size_t size = s.size();
+    // Round up space for string to a multiple of page_size.
+    size_t space_for_string = (size + page_size - 1) & ~(page_size - 1);
+    alloc_size_ = space_for_string + page_size;
+    mem_ = mmap(NULL, alloc_size_,
+                PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
+    CHECK_NE(MAP_FAILED, mem_);
+    protected_page_ = reinterpret_cast<char*>(mem_) + space_for_string;
+    char* dst = protected_page_ - size;
+    memcpy(dst, s.data(), size);
+    data_ = dst;
+    size_ = size;
+    // Make guard page unreadable.
+    CHECK_EQ(0, mprotect(protected_page_, page_size, PROT_NONE));
+  }
+
+  ~DataEndingAtUnreadablePage() {
+    // Undo the mprotect.
+    CHECK_EQ(0, mprotect(protected_page_, getpagesize(), PROT_READ|PROT_WRITE));
+    CHECK_EQ(0, munmap(mem_, alloc_size_));
+  }
+
+  const char* data() const { return data_; }
+  size_t size() const { return size_; }
+
+ private:
+  size_t alloc_size_;
+  void* mem_;
+  char* protected_page_;
+  const char* data_;
+  size_t size_;
+};
+
+#else  // HAVE_FUNC_MMAP
+
+// Fallback for systems without mmap.
+typedef string DataEndingAtUnreadablePage;
+
+#endif
+
+enum CompressorType {
+  ZLIB, LZO, LIBLZF, QUICKLZ, FASTLZ, SNAPPY
+};
+
+const char* names[] = {
+  "ZLIB", "LZO", "LIBLZF", "QUICKLZ", "FASTLZ", "SNAPPY"
+};
+
+static size_t MinimumRequiredOutputSpace(size_t input_size,
+                                         CompressorType comp) {
+  switch (comp) {
+#ifdef ZLIB_VERSION
+    case ZLIB:
+      return ZLib::MinCompressbufSize(input_size);
+#endif  // ZLIB_VERSION
+
+#ifdef LZO_VERSION
+    case LZO:
+      return input_size + input_size/64 + 16 + 3;
+#endif  // LZO_VERSION
+
+#ifdef LZF_VERSION
+    case LIBLZF:
+      return input_size;
+#endif  // LZF_VERSION
+
+#ifdef QLZ_VERSION_MAJOR
+    case QUICKLZ:
+      return input_size + 36000;  // 36000 is used for scratch.
+#endif  // QLZ_VERSION_MAJOR
+
+#ifdef FASTLZ_VERSION
+    case FASTLZ:
+      return max(static_cast<int>(ceil(input_size * 1.05)), 66);
+#endif  // FASTLZ_VERSION
+
+    case SNAPPY:
+      return snappy::MaxCompressedLength(input_size);
+
+    default:
+      LOG(FATAL) << "Unknown compression type number " << comp;
+  }
+}
+
+// Returns true if we successfully compressed, false otherwise.
+//
+// If compressed_is_preallocated is set, do not resize the compressed buffer.
+// This is typically what you want for a benchmark, in order to not spend
+// time in the memory allocator. If you do set this flag, however,
+// "compressed" must be preinitialized to at least MinCompressbufSize(comp)
+// number of bytes, and may contain junk bytes at the end after return.
+static bool Compress(const char* input, size_t input_size, CompressorType comp,
+                     string* compressed, bool compressed_is_preallocated) {
+  if (!compressed_is_preallocated) {
+    compressed->resize(MinimumRequiredOutputSpace(input_size, comp));
+  }
+
+  switch (comp) {
+#ifdef ZLIB_VERSION
+    case ZLIB: {
+      ZLib zlib;
+      uLongf destlen = compressed->size();
+      int ret = zlib.Compress(
+          reinterpret_cast<Bytef*>(string_as_array(compressed)),
+          &destlen,
+          reinterpret_cast<const Bytef*>(input),
+          input_size);
+      CHECK_EQ(Z_OK, ret);
+      if (!compressed_is_preallocated) {
+        compressed->resize(destlen);
+      }
+      return true;
+    }
+#endif  // ZLIB_VERSION
+
+#ifdef LZO_VERSION
+    case LZO: {
+      unsigned char* mem = new unsigned char[LZO1X_1_15_MEM_COMPRESS];
+      lzo_uint destlen;
+      int ret = lzo1x_1_15_compress(
+          reinterpret_cast<const uint8*>(input),
+          input_size,
+          reinterpret_cast<uint8*>(string_as_array(compressed)),
+          &destlen,
+          mem);
+      CHECK_EQ(LZO_E_OK, ret);
+      delete[] mem;
+      if (!compressed_is_preallocated) {
+        compressed->resize(destlen);
+      }
+      break;
+    }
+#endif  // LZO_VERSION
+
+#ifdef LZF_VERSION
+    case LIBLZF: {
+      int destlen = lzf_compress(input,
+                                 input_size,
+                                 string_as_array(compressed),
+                                 input_size);
+      if (destlen == 0) {
+        // lzf *can* cause lots of blowup when compressing, so they
+        // recommend to limit outsize to insize, and just not compress
+        // if it's bigger.  Ideally, we'd just swap input and output.
+        compressed->assign(input, input_size);
+        destlen = input_size;
+      }
+      if (!compressed_is_preallocated) {
+        compressed->resize(destlen);
+      }
+      break;
+    }
+#endif  // LZF_VERSION
+
+#ifdef QLZ_VERSION_MAJOR
+    case QUICKLZ: {
+      qlz_state_compress *state_compress = new qlz_state_compress;
+      int destlen = qlz_compress(input,
+                                 string_as_array(compressed),
+                                 input_size,
+                                 state_compress);
+      delete state_compress;
+      CHECK_NE(0, destlen);
+      if (!compressed_is_preallocated) {
+        compressed->resize(destlen);
+      }
+      break;
+    }
+#endif  // QLZ_VERSION_MAJOR
+
+#ifdef FASTLZ_VERSION
+    case FASTLZ: {
+      // Use level 1 compression since we mostly care about speed.
+      int destlen = fastlz_compress_level(
+          1,
+          input,
+          input_size,
+          string_as_array(compressed));
+      if (!compressed_is_preallocated) {
+        compressed->resize(destlen);
+      }
+      CHECK_NE(destlen, 0);
+      break;
+    }
+#endif  // FASTLZ_VERSION
+
+    case SNAPPY: {
+      size_t destlen;
+      snappy::RawCompress(input, input_size,
+                          string_as_array(compressed),
+                          &destlen);
+      CHECK_LE(destlen, snappy::MaxCompressedLength(input_size));
+      if (!compressed_is_preallocated) {
+        compressed->resize(destlen);
+      }
+      break;
+    }
+
+
+    default: {
+      return false;     // the asked-for library wasn't compiled in
+    }
+  }
+  return true;
+}
+
+static bool Uncompress(const string& compressed, CompressorType comp,
+                       int size, string* output) {
+  switch (comp) {
+#ifdef ZLIB_VERSION
+    case ZLIB: {
+      output->resize(size);
+      ZLib zlib;
+      uLongf destlen = output->size();
+      int ret = zlib.Uncompress(
+          reinterpret_cast<Bytef*>(string_as_array(output)),
+          &destlen,
+          reinterpret_cast<const Bytef*>(compressed.data()),
+          compressed.size());
+      CHECK_EQ(Z_OK, ret);
+      CHECK_EQ(static_cast<uLongf>(size), destlen);
+      break;
+    }
+#endif  // ZLIB_VERSION
+
+#ifdef LZO_VERSION
+    case LZO: {
+      output->resize(size);
+      lzo_uint destlen;
+      int ret = lzo1x_decompress(
+          reinterpret_cast<const uint8*>(compressed.data()),
+          compressed.size(),
+          reinterpret_cast<uint8*>(string_as_array(output)),
+          &destlen,
+          NULL);
+      CHECK_EQ(LZO_E_OK, ret);
+      CHECK_EQ(static_cast<lzo_uint>(size), destlen);
+      break;
+    }
+#endif  // LZO_VERSION
+
+#ifdef LZF_VERSION
+    case LIBLZF: {
+      output->resize(size);
+      int destlen = lzf_decompress(compressed.data(),
+                                   compressed.size(),
+                                   string_as_array(output),
+                                   output->size());
+      if (destlen == 0) {
+        // This error probably means we had decided not to compress,
+        // and thus have stored input in output directly.
+        output->assign(compressed.data(), compressed.size());
+        destlen = compressed.size();
+      }
+      CHECK_EQ(destlen, size);
+      break;
+    }
+#endif  // LZF_VERSION
+
+#ifdef QLZ_VERSION_MAJOR
+    case QUICKLZ: {
+      output->resize(size);
+      qlz_state_decompress *state_decompress = new qlz_state_decompress;
+      int destlen = qlz_decompress(compressed.data(),
+                                   string_as_array(output),
+                                   state_decompress);
+      delete state_decompress;
+      CHECK_EQ(destlen, size);
+      break;
+    }
+#endif  // QLZ_VERSION_MAJOR
+
+#ifdef FASTLZ_VERSION
+    case FASTLZ: {
+      output->resize(size);
+      int destlen = fastlz_decompress(compressed.data(),
+                                      compressed.length(),
+                                      string_as_array(output),
+                                      size);
+      CHECK_EQ(destlen, size);
+      break;
+    }
+#endif  // FASTLZ_VERSION
+
+    case SNAPPY: {
+      snappy::RawUncompress(compressed.data(), compressed.size(),
+                            string_as_array(output));
+      break;
+    }
+
+
+    default: {
+      return false;     // the asked-for library wasn't compiled in
+    }
+  }
+  return true;
+}
+
+static void Measure(const char* data,
+                    size_t length,
+                    CompressorType comp,
+                    int repeats,
+                    int block_size) {
+  // Run tests a few time and pick median running times
+  static const int kRuns = 5;
+  double ctime[kRuns];
+  double utime[kRuns];
+  int compressed_size = 0;
+
+  {
+    // Chop the input into blocks
+    int num_blocks = (length + block_size - 1) / block_size;
+    vector<const char*> input(num_blocks);
+    vector<size_t> input_length(num_blocks);
+    vector<string> compressed(num_blocks);
+    vector<string> output(num_blocks);
+    for (int b = 0; b < num_blocks; b++) {
+      int input_start = b * block_size;
+      int input_limit = min<int>((b+1)*block_size, length);
+      input[b] = data+input_start;
+      input_length[b] = input_limit-input_start;
+
+      // Pre-grow the output buffer so we don't measure string append time.
+      compressed[b].resize(MinimumRequiredOutputSpace(block_size, comp));
+    }
+
+    // First, try one trial compression to make sure the code is compiled in
+    if (!Compress(input[0], input_length[0], comp, &compressed[0], true)) {
+      LOG(WARNING) << "Skipping " << names[comp] << ": "
+                   << "library not compiled in";
+      return;
+    }
+
+    for (int run = 0; run < kRuns; run++) {
+      CycleTimer ctimer, utimer;
+
+      for (int b = 0; b < num_blocks; b++) {
+        // Pre-grow the output buffer so we don't measure string append time.
+        compressed[b].resize(MinimumRequiredOutputSpace(block_size, comp));
+      }
+
+      ctimer.Start();
+      for (int b = 0; b < num_blocks; b++)
+        for (int i = 0; i < repeats; i++)
+          Compress(input[b], input_length[b], comp, &compressed[b], true);
+      ctimer.Stop();
+
+      // Compress once more, with resizing, so we don't leave junk
+      // at the end that will confuse the decompressor.
+      for (int b = 0; b < num_blocks; b++) {
+        Compress(input[b], input_length[b], comp, &compressed[b], false);
+      }
+
+      for (int b = 0; b < num_blocks; b++) {
+        output[b].resize(input_length[b]);
+      }
+
+      utimer.Start();
+      for (int i = 0; i < repeats; i++)
+        for (int b = 0; b < num_blocks; b++)
+          Uncompress(compressed[b], comp, input_length[b], &output[b]);
+      utimer.Stop();
+
+      ctime[run] = ctimer.Get();
+      utime[run] = utimer.Get();
+    }
+
+    compressed_size = 0;
+    for (int i = 0; i < compressed.size(); i++) {
+      compressed_size += compressed[i].size();
+    }
+  }
+
+  sort(ctime, ctime + kRuns);
+  sort(utime, utime + kRuns);
+  const int med = kRuns/2;
+
+  float comp_rate = (length / ctime[med]) * repeats / 1048576.0;
+  float uncomp_rate = (length / utime[med]) * repeats / 1048576.0;
+  string x = names[comp];
+  x += ":";
+  string urate = (uncomp_rate >= 0)
+                 ? StringPrintf("%.1f", uncomp_rate)
+                 : string("?");
+  printf("%-7s [b %dM] bytes %6d -> %6d %4.1f%%  "
+         "comp %5.1f MB/s  uncomp %5s MB/s\n",
+         x.c_str(),
+         block_size/(1<<20),
+         static_cast<int>(length), static_cast<uint32>(compressed_size),
+         (compressed_size * 100.0) / max<int>(1, length),
+         comp_rate,
+         urate.c_str());
+}
+
+
+static int VerifyString(const string& input) {
+  string compressed;
+  DataEndingAtUnreadablePage i(input);
+  const size_t written = snappy::Compress(i.data(), i.size(), &compressed);
+  CHECK_EQ(written, compressed.size());
+  CHECK_LE(compressed.size(),
+           snappy::MaxCompressedLength(input.size()));
+  CHECK(snappy::IsValidCompressedBuffer(compressed.data(), compressed.size()));
+
+  string uncompressed;
+  DataEndingAtUnreadablePage c(compressed);
+  CHECK(snappy::Uncompress(c.data(), c.size(), &uncompressed));
+  CHECK_EQ(uncompressed, input);
+  return uncompressed.size();
+}
+
+#ifndef WIN32
+static void VerifyIOVec(const string& input) {
+  string compressed;
+  DataEndingAtUnreadablePage i(input);
+  const size_t written = snappy::Compress(i.data(), i.size(), &compressed);
+  CHECK_EQ(written, compressed.size());
+  CHECK_LE(compressed.size(),
+           snappy::MaxCompressedLength(input.size()));
+  CHECK(snappy::IsValidCompressedBuffer(compressed.data(), compressed.size()));
+
+  // Try uncompressing into an iovec containing a random number of entries
+  // ranging from 1 to 10.
+  char* buf = new char[input.size()];
+  ACMRandom rnd(input.size());
+  int num = rnd.Next() % 10 + 1;
+  if (input.size() < num) {
+    num = input.size();
+  }
+  struct iovec* iov = new iovec[num];
+  int used_so_far = 0;
+  for (int i = 0; i < num; ++i) {
+    iov[i].iov_base = buf + used_so_far;
+    if (i == num - 1) {
+      iov[i].iov_len = input.size() - used_so_far;
+    } else {
+      // Randomly choose to insert a 0 byte entry.
+      if (rnd.OneIn(5)) {
+        iov[i].iov_len = 0;
+      } else {
+        iov[i].iov_len = rnd.Uniform(input.size());
+      }
+    }
+    used_so_far += iov[i].iov_len;
+  }
+  CHECK(snappy::RawUncompressToIOVec(
+      compressed.data(), compressed.size(), iov, num));
+  CHECK(!memcmp(buf, input.data(), input.size()));
+  delete[] iov;
+  delete[] buf;
+}
+#endif
+
+// Test that data compressed by a compressor that does not
+// obey block sizes is uncompressed properly.
+static void VerifyNonBlockedCompression(const string& input) {
+  if (input.length() > snappy::kBlockSize) {
+    // We cannot test larger blocks than the maximum block size, obviously.
+    return;
+  }
+
+  string prefix;
+  Varint::Append32(&prefix, input.size());
+
+  // Setup compression table
+  snappy::internal::WorkingMemory wmem;
+  int table_size;
+  uint16* table = wmem.GetHashTable(input.size(), &table_size);
+
+  // Compress entire input in one shot
+  string compressed;
+  compressed += prefix;
+  compressed.resize(prefix.size()+snappy::MaxCompressedLength(input.size()));
+  char* dest = string_as_array(&compressed) + prefix.size();
+  char* end = snappy::internal::CompressFragment(input.data(), input.size(),
+                                                dest, table, table_size);
+  compressed.resize(end - compressed.data());
+
+  // Uncompress into string
+  string uncomp_str;
+  CHECK(snappy::Uncompress(compressed.data(), compressed.size(), &uncomp_str));
+  CHECK_EQ(uncomp_str, input);
+
+}
+
+// Expand the input so that it is at least K times as big as block size
+static string Expand(const string& input) {
+  static const int K = 3;
+  string data = input;
+  while (data.size() < K * snappy::kBlockSize) {
+    data += input;
+  }
+  return data;
+}
+
+static int Verify(const string& input) {
+  VLOG(1) << "Verifying input of size " << input.size();
+
+  // Compress using string based routines
+  const int result = VerifyString(input);
+
+
+  VerifyNonBlockedCompression(input);
+#ifndef WIN32
+  VerifyIOVec(input);
+#endif
+  if (!input.empty()) {
+    const string expanded = Expand(input);
+    VerifyNonBlockedCompression(expanded);
+#ifndef WIN32
+	VerifyIOVec(input);
+#endif
+  }
+
+
+  return result;
+}
+
+// This test checks to ensure that snappy doesn't coredump if it gets
+// corrupted data.
+
+static bool IsValidCompressedBuffer(const string& c) {
+  return snappy::IsValidCompressedBuffer(c.data(), c.size());
+}
+static bool Uncompress(const string& c, string* u) {
+  return snappy::Uncompress(c.data(), c.size(), u);
+}
+
+TYPED_TEST(CorruptedTest, VerifyCorrupted) {
+  string source = "making sure we don't crash with corrupted input";
+  VLOG(1) << source;
+  string dest;
+  TypeParam uncmp;
+  snappy::Compress(source.data(), source.size(), &dest);
+
+  // Mess around with the data. It's hard to simulate all possible
+  // corruptions; this is just one example ...
+  CHECK_GT(dest.size(), 3);
+  dest[1]--;
+  dest[3]++;
+  // this really ought to fail.
+  CHECK(!IsValidCompressedBuffer(TypeParam(dest)));
+  CHECK(!Uncompress(TypeParam(dest), &uncmp));
+
+  // This is testing for a security bug - a buffer that decompresses to 100k
+  // but we lie in the snappy header and only reserve 0 bytes of memory :)
+  source.resize(100000);
+  for (int i = 0; i < source.length(); ++i) {
+    source[i] = 'A';
+  }
+  snappy::Compress(source.data(), source.size(), &dest);
+  dest[0] = dest[1] = dest[2] = dest[3] = 0;
+  CHECK(!IsValidCompressedBuffer(TypeParam(dest)));
+  CHECK(!Uncompress(TypeParam(dest), &uncmp));
+
+  if (sizeof(void *) == 4) {
+    // Another security check; check a crazy big length can't DoS us with an
+    // over-allocation.
+    // Currently this is done only for 32-bit builds.  On 64-bit builds,
+    // where 3 GB might be an acceptable allocation size, Uncompress()
+    // attempts to decompress, and sometimes causes the test to run out of
+    // memory.
+    dest[0] = dest[1] = dest[2] = dest[3] = 0xff;
+    // This decodes to a really large size, i.e., about 3 GB.
+    dest[4] = 'k';
+    CHECK(!IsValidCompressedBuffer(TypeParam(dest)));
+    CHECK(!Uncompress(TypeParam(dest), &uncmp));
+  } else {
+    LOG(WARNING) << "Crazy decompression lengths not checked on 64-bit build";
+  }
+
+  // This decodes to about 2 MB; much smaller, but should still fail.
+  dest[0] = dest[1] = dest[2] = 0xff;
+  dest[3] = 0x00;
+  CHECK(!IsValidCompressedBuffer(TypeParam(dest)));
+  CHECK(!Uncompress(TypeParam(dest), &uncmp));
+
+  // try reading stuff in from a bad file.
+  for (int i = 1; i <= 3; ++i) {
+    string data = ReadTestDataFile(StringPrintf("baddata%d.snappy", i).c_str(),
+                                   0);
+    string uncmp;
+    // check that we don't return a crazy length
+    size_t ulen;
+    CHECK(!snappy::GetUncompressedLength(data.data(), data.size(), &ulen)
+          || (ulen < (1<<20)));
+    uint32 ulen2;
+    snappy::ByteArraySource source(data.data(), data.size());
+    CHECK(!snappy::GetUncompressedLength(&source, &ulen2) ||
+          (ulen2 < (1<<20)));
+    CHECK(!IsValidCompressedBuffer(TypeParam(data)));
+    CHECK(!Uncompress(TypeParam(data), &uncmp));
+  }
+}
+
+// Helper routines to construct arbitrary compressed strings.
+// These mirror the compression code in snappy.cc, but are copied
+// here so that we can bypass some limitations in the how snappy.cc
+// invokes these routines.
+static void AppendLiteral(string* dst, const string& literal) {
+  if (literal.empty()) return;
+  int n = literal.size() - 1;
+  if (n < 60) {
+    // Fit length in tag byte
+    dst->push_back(0 | (n << 2));
+  } else {
+    // Encode in upcoming bytes
+    char number[4];
+    int count = 0;
+    while (n > 0) {
+      number[count++] = n & 0xff;
+      n >>= 8;
+    }
+    dst->push_back(0 | ((59+count) << 2));
+    *dst += string(number, count);
+  }
+  *dst += literal;
+}
+
+static void AppendCopy(string* dst, int offset, int length) {
+  while (length > 0) {
+    // Figure out how much to copy in one shot
+    int to_copy;
+    if (length >= 68) {
+      to_copy = 64;
+    } else if (length > 64) {
+      to_copy = 60;
+    } else {
+      to_copy = length;
+    }
+    length -= to_copy;
+
+    if ((to_copy >= 4) && (to_copy < 12) && (offset < 2048)) {
+      assert(to_copy-4 < 8);            // Must fit in 3 bits
+      dst->push_back(1 | ((to_copy-4) << 2) | ((offset >> 8) << 5));
+      dst->push_back(offset & 0xff);
+    } else if (offset < 65536) {
+      dst->push_back(2 | ((to_copy-1) << 2));
+      dst->push_back(offset & 0xff);
+      dst->push_back(offset >> 8);
+    } else {
+      dst->push_back(3 | ((to_copy-1) << 2));
+      dst->push_back(offset & 0xff);
+      dst->push_back((offset >> 8) & 0xff);
+      dst->push_back((offset >> 16) & 0xff);
+      dst->push_back((offset >> 24) & 0xff);
+    }
+  }
+}
+
+TEST(Snappy, SimpleTests) {
+  Verify("");
+  Verify("a");
+  Verify("ab");
+  Verify("abc");
+
+  Verify("aaaaaaa" + string(16, 'b') + string("aaaaa") + "abc");
+  Verify("aaaaaaa" + string(256, 'b') + string("aaaaa") + "abc");
+  Verify("aaaaaaa" + string(2047, 'b') + string("aaaaa") + "abc");
+  Verify("aaaaaaa" + string(65536, 'b') + string("aaaaa") + "abc");
+  Verify("abcaaaaaaa" + string(65536, 'b') + string("aaaaa") + "abc");
+}
+
+// Verify max blowup (lots of four-byte copies)
+TEST(Snappy, MaxBlowup) {
+  string input;
+  for (int i = 0; i < 20000; i++) {
+    ACMRandom rnd(i);
+    uint32 bytes = static_cast<uint32>(rnd.Next());
+    input.append(reinterpret_cast<char*>(&bytes), sizeof(bytes));
+  }
+  for (int i = 19999; i >= 0; i--) {
+    ACMRandom rnd(i);
+    uint32 bytes = static_cast<uint32>(rnd.Next());
+    input.append(reinterpret_cast<char*>(&bytes), sizeof(bytes));
+  }
+  Verify(input);
+}
+
+TEST(Snappy, RandomData) {
+  ACMRandom rnd(FLAGS_test_random_seed);
+
+  const int num_ops = 20000;
+  for (int i = 0; i < num_ops; i++) {
+    if ((i % 1000) == 0) {
+      VLOG(0) << "Random op " << i << " of " << num_ops;
+    }
+
+    string x;
+    int len = rnd.Uniform(4096);
+    if (i < 100) {
+      len = 65536 + rnd.Uniform(65536);
+    }
+    while (x.size() < len) {
+      int run_len = 1;
+      if (rnd.OneIn(10)) {
+        run_len = rnd.Skewed(8);
+      }
+      char c = (i < 100) ? rnd.Uniform(256) : rnd.Skewed(3);
+      while (run_len-- > 0 && x.size() < len) {
+        x += c;
+      }
+    }
+
+    Verify(x);
+  }
+}
+
+TEST(Snappy, FourByteOffset) {
+  // The new compressor cannot generate four-byte offsets since
+  // it chops up the input into 32KB pieces.  So we hand-emit the
+  // copy manually.
+
+  // The two fragments that make up the input string.
+  string fragment1 = "012345689abcdefghijklmnopqrstuvwxyz";
+  string fragment2 = "some other string";
+
+  // How many times each fragment is emitted.
+  const int n1 = 2;
+  const int n2 = 100000 / fragment2.size();
+  const int length = n1 * fragment1.size() + n2 * fragment2.size();
+
+  string compressed;
+  Varint::Append32(&compressed, length);
+
+  AppendLiteral(&compressed, fragment1);
+  string src = fragment1;
+  for (int i = 0; i < n2; i++) {
+    AppendLiteral(&compressed, fragment2);
+    src += fragment2;
+  }
+  AppendCopy(&compressed, src.size(), fragment1.size());
+  src += fragment1;
+  CHECK_EQ(length, src.size());
+
+  string uncompressed;
+  CHECK(snappy::IsValidCompressedBuffer(compressed.data(), compressed.size()));
+  CHECK(snappy::Uncompress(compressed.data(), compressed.size(),
+                           &uncompressed));
+  CHECK_EQ(uncompressed, src);
+}
+
+#ifndef WIN32
+TEST(Snappy, IOVecEdgeCases) {
+  // Test some tricky edge cases in the iovec output that are not necessarily
+  // exercised by random tests.
+
+  // Our output blocks look like this initially (the last iovec is bigger
+  // than depicted):
+  // [  ] [ ] [    ] [        ] [        ]
+  static const int kLengths[] = { 2, 1, 4, 8, 128 };
+
+  struct iovec iov[ARRAYSIZE(kLengths)];
+  for (int i = 0; i < ARRAYSIZE(kLengths); ++i) {
+    iov[i].iov_base = new char[kLengths[i]];
+    iov[i].iov_len = kLengths[i];
+  }
+
+  string compressed;
+  Varint::Append32(&compressed, 22);
+
+  // A literal whose output crosses three blocks.
+  // [ab] [c] [123 ] [        ] [        ]
+  AppendLiteral(&compressed, "abc123");
+
+  // A copy whose output crosses two blocks (source and destination
+  // segments marked).
+  // [ab] [c] [1231] [23      ] [        ]
+  //           ^--^   --
+  AppendCopy(&compressed, 3, 3);
+
+  // A copy where the input is, at first, in the block before the output:
+  //
+  // [ab] [c] [1231] [231231  ] [        ]
+  //           ^---     ^---
+  // Then during the copy, the pointers move such that the input and
+  // output pointers are in the same block:
+  //
+  // [ab] [c] [1231] [23123123] [        ]
+  //                  ^-    ^-
+  // And then they move again, so that the output pointer is no longer
+  // in the same block as the input pointer:
+  // [ab] [c] [1231] [23123123] [123     ]
+  //                    ^--      ^--
+  AppendCopy(&compressed, 6, 9);
+
+  // Finally, a copy where the input is from several blocks back,
+  // and it also crosses three blocks:
+  //
+  // [ab] [c] [1231] [23123123] [123b    ]
+  //   ^                            ^
+  // [ab] [c] [1231] [23123123] [123bc   ]
+  //       ^                         ^
+  // [ab] [c] [1231] [23123123] [123bc12 ]
+  //           ^-                     ^-
+  AppendCopy(&compressed, 17, 4);
+
+  CHECK(snappy::RawUncompressToIOVec(
+      compressed.data(), compressed.size(), iov, ARRAYSIZE(iov)));
+  CHECK_EQ(0, memcmp(iov[0].iov_base, "ab", 2));
+  CHECK_EQ(0, memcmp(iov[1].iov_base, "c", 1));
+  CHECK_EQ(0, memcmp(iov[2].iov_base, "1231", 4));
+  CHECK_EQ(0, memcmp(iov[3].iov_base, "23123123", 8));
+  CHECK_EQ(0, memcmp(iov[4].iov_base, "123bc12", 7));
+
+  for (int i = 0; i < ARRAYSIZE(kLengths); ++i) {
+    delete[] reinterpret_cast<char *>(iov[i].iov_base);
+  }
+}
+
+TEST(Snappy, IOVecLiteralOverflow) {
+  static const int kLengths[] = { 3, 4 };
+
+  struct iovec iov[ARRAYSIZE(kLengths)];
+  for (int i = 0; i < ARRAYSIZE(kLengths); ++i) {
+    iov[i].iov_base = new char[kLengths[i]];
+    iov[i].iov_len = kLengths[i];
+  }
+
+  string compressed;
+  Varint::Append32(&compressed, 8);
+
+  AppendLiteral(&compressed, "12345678");
+
+  CHECK(!snappy::RawUncompressToIOVec(
+      compressed.data(), compressed.size(), iov, ARRAYSIZE(iov)));
+
+  for (int i = 0; i < ARRAYSIZE(kLengths); ++i) {
+    delete[] reinterpret_cast<char *>(iov[i].iov_base);
+  }
+}
+
+TEST(Snappy, IOVecCopyOverflow) {
+  static const int kLengths[] = { 3, 4 };
+
+  struct iovec iov[ARRAYSIZE(kLengths)];
+  for (int i = 0; i < ARRAYSIZE(kLengths); ++i) {
+    iov[i].iov_base = new char[kLengths[i]];
+    iov[i].iov_len = kLengths[i];
+  }
+
+  string compressed;
+  Varint::Append32(&compressed, 8);
+
+  AppendLiteral(&compressed, "123");
+  AppendCopy(&compressed, 3, 5);
+
+  CHECK(!snappy::RawUncompressToIOVec(
+      compressed.data(), compressed.size(), iov, ARRAYSIZE(iov)));
+
+  for (int i = 0; i < ARRAYSIZE(kLengths); ++i) {
+    delete[] reinterpret_cast<char *>(iov[i].iov_base);
+  }
+}
+#endif
+
+static bool CheckUncompressedLength(const string& compressed,
+                                    size_t* ulength) {
+  const bool result1 = snappy::GetUncompressedLength(compressed.data(),
+                                                     compressed.size(),
+                                                     ulength);
+
+  snappy::ByteArraySource source(compressed.data(), compressed.size());
+  uint32 length;
+  const bool result2 = snappy::GetUncompressedLength(&source, &length);
+  CHECK_EQ(result1, result2);
+  return result1;
+}
+
+TEST(SnappyCorruption, TruncatedVarint) {
+  string compressed, uncompressed;
+  size_t ulength;
+  compressed.push_back('\xf0');
+  CHECK(!CheckUncompressedLength(compressed, &ulength));
+  CHECK(!snappy::IsValidCompressedBuffer(compressed.data(), compressed.size()));
+  CHECK(!snappy::Uncompress(compressed.data(), compressed.size(),
+                            &uncompressed));
+}
+
+TEST(SnappyCorruption, UnterminatedVarint) {
+  string compressed, uncompressed;
+  size_t ulength;
+  compressed.push_back(128);
+  compressed.push_back(128);
+  compressed.push_back(128);
+  compressed.push_back(128);
+  compressed.push_back(128);
+  compressed.push_back(10);
+  CHECK(!CheckUncompressedLength(compressed, &ulength));
+  CHECK(!snappy::IsValidCompressedBuffer(compressed.data(), compressed.size()));
+  CHECK(!snappy::Uncompress(compressed.data(), compressed.size(),
+                            &uncompressed));
+}
+
+TEST(Snappy, ReadPastEndOfBuffer) {
+  // Check that we do not read past end of input
+
+  // Make a compressed string that ends with a single-byte literal
+  string compressed;
+  Varint::Append32(&compressed, 1);
+  AppendLiteral(&compressed, "x");
+
+  string uncompressed;
+  DataEndingAtUnreadablePage c(compressed);
+  CHECK(snappy::Uncompress(c.data(), c.size(), &uncompressed));
+  CHECK_EQ(uncompressed, string("x"));
+}
+
+// Check for an infinite loop caused by a copy with offset==0
+TEST(Snappy, ZeroOffsetCopy) {
+  const char* compressed = "\x40\x12\x00\x00";
+  //  \x40              Length (must be > kMaxIncrementCopyOverflow)
+  //  \x12\x00\x00      Copy with offset==0, length==5
+  char uncompressed[100];
+  EXPECT_FALSE(snappy::RawUncompress(compressed, 4, uncompressed));
+}
+
+TEST(Snappy, ZeroOffsetCopyValidation) {
+  const char* compressed = "\x05\x12\x00\x00";
+  //  \x05              Length
+  //  \x12\x00\x00      Copy with offset==0, length==5
+  EXPECT_FALSE(snappy::IsValidCompressedBuffer(compressed, 4));
+}
+
+
+namespace {
+
+int TestFindMatchLength(const char* s1, const char *s2, unsigned length) {
+  return snappy::internal::FindMatchLength(s1, s2, s2 + length);
+}
+
+}  // namespace
+
+TEST(Snappy, FindMatchLength) {
+  // Exercise all different code paths through the function.
+  // 64-bit version:
+
+  // Hit s1_limit in 64-bit loop, hit s1_limit in single-character loop.
+  EXPECT_EQ(6, TestFindMatchLength("012345", "012345", 6));
+  EXPECT_EQ(11, TestFindMatchLength("01234567abc", "01234567abc", 11));
+
+  // Hit s1_limit in 64-bit loop, find a non-match in single-character loop.
+  EXPECT_EQ(9, TestFindMatchLength("01234567abc", "01234567axc", 9));
+
+  // Same, but edge cases.
+  EXPECT_EQ(11, TestFindMatchLength("01234567abc!", "01234567abc!", 11));
+  EXPECT_EQ(11, TestFindMatchLength("01234567abc!", "01234567abc?", 11));
+
+  // Find non-match at once in first loop.
+  EXPECT_EQ(0, TestFindMatchLength("01234567xxxxxxxx", "?1234567xxxxxxxx", 16));
+  EXPECT_EQ(1, TestFindMatchLength("01234567xxxxxxxx", "0?234567xxxxxxxx", 16));
+  EXPECT_EQ(4, TestFindMatchLength("01234567xxxxxxxx", "01237654xxxxxxxx", 16));
+  EXPECT_EQ(7, TestFindMatchLength("01234567xxxxxxxx", "0123456?xxxxxxxx", 16));
+
+  // Find non-match in first loop after one block.
+  EXPECT_EQ(8, TestFindMatchLength("abcdefgh01234567xxxxxxxx",
+                                   "abcdefgh?1234567xxxxxxxx", 24));
+  EXPECT_EQ(9, TestFindMatchLength("abcdefgh01234567xxxxxxxx",
+                                   "abcdefgh0?234567xxxxxxxx", 24));
+  EXPECT_EQ(12, TestFindMatchLength("abcdefgh01234567xxxxxxxx",
+                                    "abcdefgh01237654xxxxxxxx", 24));
+  EXPECT_EQ(15, TestFindMatchLength("abcdefgh01234567xxxxxxxx",
+                                    "abcdefgh0123456?xxxxxxxx", 24));
+
+  // 32-bit version:
+
+  // Short matches.
+  EXPECT_EQ(0, TestFindMatchLength("01234567", "?1234567", 8));
+  EXPECT_EQ(1, TestFindMatchLength("01234567", "0?234567", 8));
+  EXPECT_EQ(2, TestFindMatchLength("01234567", "01?34567", 8));
+  EXPECT_EQ(3, TestFindMatchLength("01234567", "012?4567", 8));
+  EXPECT_EQ(4, TestFindMatchLength("01234567", "0123?567", 8));
+  EXPECT_EQ(5, TestFindMatchLength("01234567", "01234?67", 8));
+  EXPECT_EQ(6, TestFindMatchLength("01234567", "012345?7", 8));
+  EXPECT_EQ(7, TestFindMatchLength("01234567", "0123456?", 8));
+  EXPECT_EQ(7, TestFindMatchLength("01234567", "0123456?", 7));
+  EXPECT_EQ(7, TestFindMatchLength("01234567!", "0123456??", 7));
+
+  // Hit s1_limit in 32-bit loop, hit s1_limit in single-character loop.
+  EXPECT_EQ(10, TestFindMatchLength("xxxxxxabcd", "xxxxxxabcd", 10));
+  EXPECT_EQ(10, TestFindMatchLength("xxxxxxabcd?", "xxxxxxabcd?", 10));
+  EXPECT_EQ(13, TestFindMatchLength("xxxxxxabcdef", "xxxxxxabcdef", 13));
+
+  // Same, but edge cases.
+  EXPECT_EQ(12, TestFindMatchLength("xxxxxx0123abc!", "xxxxxx0123abc!", 12));
+  EXPECT_EQ(12, TestFindMatchLength("xxxxxx0123abc!", "xxxxxx0123abc?", 12));
+
+  // Hit s1_limit in 32-bit loop, find a non-match in single-character loop.
+  EXPECT_EQ(11, TestFindMatchLength("xxxxxx0123abc", "xxxxxx0123axc", 13));
+
+  // Find non-match at once in first loop.
+  EXPECT_EQ(6, TestFindMatchLength("xxxxxx0123xxxxxxxx",
+                                   "xxxxxx?123xxxxxxxx", 18));
+  EXPECT_EQ(7, TestFindMatchLength("xxxxxx0123xxxxxxxx",
+                                   "xxxxxx0?23xxxxxxxx", 18));
+  EXPECT_EQ(8, TestFindMatchLength("xxxxxx0123xxxxxxxx",
+                                   "xxxxxx0132xxxxxxxx", 18));
+  EXPECT_EQ(9, TestFindMatchLength("xxxxxx0123xxxxxxxx",
+                                   "xxxxxx012?xxxxxxxx", 18));
+
+  // Same, but edge cases.
+  EXPECT_EQ(6, TestFindMatchLength("xxxxxx0123", "xxxxxx?123", 10));
+  EXPECT_EQ(7, TestFindMatchLength("xxxxxx0123", "xxxxxx0?23", 10));
+  EXPECT_EQ(8, TestFindMatchLength("xxxxxx0123", "xxxxxx0132", 10));
+  EXPECT_EQ(9, TestFindMatchLength("xxxxxx0123", "xxxxxx012?", 10));
+
+  // Find non-match in first loop after one block.
+  EXPECT_EQ(10, TestFindMatchLength("xxxxxxabcd0123xx",
+                                    "xxxxxxabcd?123xx", 16));
+  EXPECT_EQ(11, TestFindMatchLength("xxxxxxabcd0123xx",
+                                    "xxxxxxabcd0?23xx", 16));
+  EXPECT_EQ(12, TestFindMatchLength("xxxxxxabcd0123xx",
+                                    "xxxxxxabcd0132xx", 16));
+  EXPECT_EQ(13, TestFindMatchLength("xxxxxxabcd0123xx",
+                                    "xxxxxxabcd012?xx", 16));
+
+  // Same, but edge cases.
+  EXPECT_EQ(10, TestFindMatchLength("xxxxxxabcd0123", "xxxxxxabcd?123", 14));
+  EXPECT_EQ(11, TestFindMatchLength("xxxxxxabcd0123", "xxxxxxabcd0?23", 14));
+  EXPECT_EQ(12, TestFindMatchLength("xxxxxxabcd0123", "xxxxxxabcd0132", 14));
+  EXPECT_EQ(13, TestFindMatchLength("xxxxxxabcd0123", "xxxxxxabcd012?", 14));
+}
+
+TEST(Snappy, FindMatchLengthRandom) {
+  const int kNumTrials = 10000;
+  const int kTypicalLength = 10;
+  ACMRandom rnd(FLAGS_test_random_seed);
+
+  for (int i = 0; i < kNumTrials; i++) {
+    string s, t;
+    char a = rnd.Rand8();
+    char b = rnd.Rand8();
+    while (!rnd.OneIn(kTypicalLength)) {
+      s.push_back(rnd.OneIn(2) ? a : b);
+      t.push_back(rnd.OneIn(2) ? a : b);
+    }
+    DataEndingAtUnreadablePage u(s);
+    DataEndingAtUnreadablePage v(t);
+    int matched = snappy::internal::FindMatchLength(
+        u.data(), v.data(), v.data() + t.size());
+    if (matched == t.size()) {
+      EXPECT_EQ(s, t);
+    } else {
+      EXPECT_NE(s[matched], t[matched]);
+      for (int j = 0; j < matched; j++) {
+        EXPECT_EQ(s[j], t[j]);
+      }
+    }
+  }
+}
+
+
+static void CompressFile(const char* fname) {
+  string fullinput;
+  file::GetContents(fname, &fullinput, file::Defaults()).CheckSuccess();
+
+  string compressed;
+  Compress(fullinput.data(), fullinput.size(), SNAPPY, &compressed, false);
+
+  file::SetContents(string(fname).append(".comp"), compressed, file::Defaults())
+      .CheckSuccess();
+}
+
+static void UncompressFile(const char* fname) {
+  string fullinput;
+  file::GetContents(fname, &fullinput, file::Defaults()).CheckSuccess();
+
+  size_t uncompLength;
+  CHECK(CheckUncompressedLength(fullinput, &uncompLength));
+
+  string uncompressed;
+  uncompressed.resize(uncompLength);
+  CHECK(snappy::Uncompress(fullinput.data(), fullinput.size(), &uncompressed));
+
+  file::SetContents(string(fname).append(".uncomp"), uncompressed,
+                    file::Defaults()).CheckSuccess();
+}
+
+static void MeasureFile(const char* fname) {
+  string fullinput;
+  file::GetContents(fname, &fullinput, file::Defaults()).CheckSuccess();
+  printf("%-40s :\n", fname);
+
+  int start_len = (FLAGS_start_len < 0) ? fullinput.size() : FLAGS_start_len;
+  int end_len = fullinput.size();
+  if (FLAGS_end_len >= 0) {
+    end_len = min<int>(fullinput.size(), FLAGS_end_len);
+  }
+  for (int len = start_len; len <= end_len; len++) {
+    const char* const input = fullinput.data();
+    int repeats = (FLAGS_bytes + len) / (len + 1);
+    if (FLAGS_zlib)     Measure(input, len, ZLIB, repeats, 1024<<10);
+    if (FLAGS_lzo)      Measure(input, len, LZO, repeats, 1024<<10);
+    if (FLAGS_liblzf)   Measure(input, len, LIBLZF, repeats, 1024<<10);
+    if (FLAGS_quicklz)  Measure(input, len, QUICKLZ, repeats, 1024<<10);
+    if (FLAGS_fastlz)   Measure(input, len, FASTLZ, repeats, 1024<<10);
+    if (FLAGS_snappy)    Measure(input, len, SNAPPY, repeats, 4096<<10);
+
+    // For block-size based measurements
+    if (0 && FLAGS_snappy) {
+      Measure(input, len, SNAPPY, repeats, 8<<10);
+      Measure(input, len, SNAPPY, repeats, 16<<10);
+      Measure(input, len, SNAPPY, repeats, 32<<10);
+      Measure(input, len, SNAPPY, repeats, 64<<10);
+      Measure(input, len, SNAPPY, repeats, 256<<10);
+      Measure(input, len, SNAPPY, repeats, 1024<<10);
+    }
+  }
+}
+
+static struct {
+  const char* label;
+  const char* filename;
+  size_t size_limit;
+} files[] = {
+  { "html", "html", 0 },
+  { "urls", "urls.10K", 0 },
+  { "jpg", "house.jpg", 0 },
+  { "jpg_200", "house.jpg", 200 },
+  { "pdf", "mapreduce-osdi-1.pdf", 0 },
+  { "html4", "html_x_4", 0 },
+  { "cp", "cp.html", 0 },
+  { "c", "fields.c", 0 },
+  { "lsp", "grammar.lsp", 0 },
+  { "xls", "kennedy.xls", 0 },
+  { "xls_200", "kennedy.xls", 200 },
+  { "txt1", "alice29.txt", 0 },
+  { "txt2", "asyoulik.txt", 0 },
+  { "txt3", "lcet10.txt", 0 },
+  { "txt4", "plrabn12.txt", 0 },
+  { "bin", "ptt5", 0 },
+  { "bin_200", "ptt5", 200 },
+  { "sum", "sum", 0 },
+  { "man", "xargs.1", 0 },
+  { "pb", "geo.protodata", 0 },
+  { "gaviota", "kppkn.gtb", 0 },
+};
+
+static void BM_UFlat(int iters, int arg) {
+  StopBenchmarkTiming();
+
+  // Pick file to process based on "arg"
+  CHECK_GE(arg, 0);
+  CHECK_LT(arg, ARRAYSIZE(files));
+  string contents = ReadTestDataFile(files[arg].filename,
+                                     files[arg].size_limit);
+
+  string zcontents;
+  snappy::Compress(contents.data(), contents.size(), &zcontents);
+  char* dst = new char[contents.size()];
+
+  SetBenchmarkBytesProcessed(static_cast<int64>(iters) *
+                             static_cast<int64>(contents.size()));
+  SetBenchmarkLabel(files[arg].label);
+  StartBenchmarkTiming();
+  while (iters-- > 0) {
+    CHECK(snappy::RawUncompress(zcontents.data(), zcontents.size(), dst));
+  }
+  StopBenchmarkTiming();
+
+  delete[] dst;
+}
+BENCHMARK(BM_UFlat)->DenseRange(0, ARRAYSIZE(files) - 1);
+
+static void BM_UValidate(int iters, int arg) {
+  StopBenchmarkTiming();
+
+  // Pick file to process based on "arg"
+  CHECK_GE(arg, 0);
+  CHECK_LT(arg, ARRAYSIZE(files));
+  string contents = ReadTestDataFile(files[arg].filename,
+                                     files[arg].size_limit);
+
+  string zcontents;
+  snappy::Compress(contents.data(), contents.size(), &zcontents);
+
+  SetBenchmarkBytesProcessed(static_cast<int64>(iters) *
+                             static_cast<int64>(contents.size()));
+  SetBenchmarkLabel(files[arg].label);
+  StartBenchmarkTiming();
+  while (iters-- > 0) {
+    CHECK(snappy::IsValidCompressedBuffer(zcontents.data(), zcontents.size()));
+  }
+  StopBenchmarkTiming();
+}
+BENCHMARK(BM_UValidate)->DenseRange(0, 4);
+
+#ifndef WIN32
+static void BM_UIOVec(int iters, int arg) {
+  StopBenchmarkTiming();
+
+  // Pick file to process based on "arg"
+  CHECK_GE(arg, 0);
+  CHECK_LT(arg, ARRAYSIZE(files));
+  string contents = ReadTestDataFile(files[arg].filename,
+                                     files[arg].size_limit);
+
+  string zcontents;
+  snappy::Compress(contents.data(), contents.size(), &zcontents);
+
+  // Uncompress into an iovec containing ten entries.
+  const int kNumEntries = 10;
+  struct iovec iov[kNumEntries];
+  char *dst = new char[contents.size()];
+  int used_so_far = 0;
+  for (int i = 0; i < kNumEntries; ++i) {
+    iov[i].iov_base = dst + used_so_far;
+    if (used_so_far == contents.size()) {
+      iov[i].iov_len = 0;
+      continue;
+    }
+
+    if (i == kNumEntries - 1) {
+      iov[i].iov_len = contents.size() - used_so_far;
+    } else {
+      iov[i].iov_len = contents.size() / kNumEntries;
+    }
+    used_so_far += iov[i].iov_len;
+  }
+
+  SetBenchmarkBytesProcessed(static_cast<int64>(iters) *
+                             static_cast<int64>(contents.size()));
+  SetBenchmarkLabel(files[arg].label);
+  StartBenchmarkTiming();
+  while (iters-- > 0) {
+    CHECK(snappy::RawUncompressToIOVec(zcontents.data(), zcontents.size(), iov,
+                                       kNumEntries));
+  }
+  StopBenchmarkTiming();
+
+  delete[] dst;
+}
+BENCHMARK(BM_UIOVec)->DenseRange(0, 4);
+#endif
+
+static void BM_ZFlat(int iters, int arg) {
+  StopBenchmarkTiming();
+
+  // Pick file to process based on "arg"
+  CHECK_GE(arg, 0);
+  CHECK_LT(arg, ARRAYSIZE(files));
+  string contents = ReadTestDataFile(files[arg].filename,
+                                     files[arg].size_limit);
+
+  char* dst = new char[snappy::MaxCompressedLength(contents.size())];
+
+  SetBenchmarkBytesProcessed(static_cast<int64>(iters) *
+                             static_cast<int64>(contents.size()));
+  StartBenchmarkTiming();
+
+  size_t zsize = 0;
+  while (iters-- > 0) {
+    snappy::RawCompress(contents.data(), contents.size(), dst, &zsize);
+  }
+  StopBenchmarkTiming();
+  const double compression_ratio =
+      static_cast<double>(zsize) / std::max<size_t>(1, contents.size());
+  SetBenchmarkLabel(StringPrintf("%s (%.2f %%)",
+                                 files[arg].label, 100.0 * compression_ratio));
+  VLOG(0) << StringPrintf("compression for %s: %zd -> %zd bytes",
+                          files[arg].label, contents.size(), zsize);
+  delete[] dst;
+}
+BENCHMARK(BM_ZFlat)->DenseRange(0, ARRAYSIZE(files) - 1);
+
+
+}  // namespace snappy
+
+extern "C" SNAPPY_API int snappy_unittests(int argc, char** argv) {
+  InitGoogle(argv[0], &argc, &argv, true);
+  File::Init();
+  RunSpecifiedBenchmarks();
+
+
+  if (argc >= 2) {
+    for (int arg = 1; arg < argc; arg++) {
+      if (FLAGS_write_compressed) {
+        CompressFile(argv[arg]);
+      } else if (FLAGS_write_uncompressed) {
+        UncompressFile(argv[arg]);
+      } else {
+        MeasureFile(argv[arg]);
+      }
+    }
+    return 0;
+  }
+
+  return RUN_ALL_TESTS();
+}
diff --git a/packages/repositories.config b/packages/repositories.config
new file mode 100644
index 0000000..e091ff8
--- /dev/null
+++ b/packages/repositories.config
@@ -0,0 +1,6 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<repositories>
+  <repository path="..\LevelDB\packages.config" />
+  <repository path="..\PackageTest\packages.config" />
+  <repository path="..\RunTests\packages.config" />
+</repositories>
\ No newline at end of file
diff --git a/port/win/crc32c_win.cc b/port/win/crc32c_win.cc
new file mode 100644
index 0000000..5d88e96
--- /dev/null
+++ b/port/win/crc32c_win.cc
@@ -0,0 +1,13 @@
+#include <stdint.h>
+#include "crc32c.h"
+
+namespace leveldb {
+namespace crc32c {
+
+uint32_t Extend(uint32_t init_crc, const char* data, size_t n)
+{
+    return crc32c_append(init_crc, (const unsigned char *)data, n);
+}
+
+}  // namespace crc32c
+}  // namespace leveldb
diff --git a/port/win/unistd.h b/port/win/unistd.h
new file mode 100644
index 0000000..e69de29
-- 
2.11.1

